; vvvvv
; ^^^^^
    
    ORG 0x8000
    

    
     
     
     
     
    
      
      
      
      
    
     
     
     
     
    
    

    
    
    
    
    
    
    
    
    
    
    

min equ 0x8000
xFEFD equ 0xFEFD
xFEFE equ 0xFEFE
xFEFF equ 0xFEFF
m1 equ -1
zero equ 0
p1 equ 1
x3332 equ 0x3332
x3333 equ 0x3333
x3334 equ 0x3334
max equ 0x7FFF



            
      
               
     
 

            
      
              
     
 
    

            
      
               
     
 
    
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 



            
      
               
     
 
    
            
      
              
     
 

            
      
               
     
 
        
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 
    
            
      
              
     
 

            
      
               
     
 
        
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 
    
            
      
              
     
 

            
      
               
     
 
        
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 
    
            
      
               
     
 

            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 
       

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 

; ----- unsigned --------

m2 equ -2

    
    
    
    
    
    
    

    


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 

    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 
    
            
      
               
     
 

            
      
              
     
 
    

            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 


            
      
               
     
 

            
      
              
     
 

            
      
               
     
 
    
            
      
              
     
 

; -------------
      
       
    
    

    ; signed
                         
                  
                  
           
                         
                  
                  
           
                         
                  
                  
           
                         
                  
                  
           
                         
                  
                  
           
                         
                  
                  
           
          
    ; unsigned
                        
                 
                 
          
                        
                 
                 
          
                        
                 
                 
          
                        
                 
                 
          
                        
                 
                 
          
                        
                 
                 
          
       



    ;# signed
         
       
        
         
       
        
         
       
        
         
       
        
         
       
        
         
       
        
        
    ;# unsigned
        
      
       
        
      
       
        
      
       
        
      
       
        
      
       
        
      
       
       




      
      
      
      
      
      
         
      
      
      
      
      
      
       




      
      
      
      
      
      
         
      
      
      
      
      
      
       


;   ===  b e g i n  ===
    ld  (Stop+1), SP    ; 4:20      init   storing the original SP value when the "bye" word is used
    ld    L, 0x1A       ; 2:7       init   Upper screen
    call 0x1605         ; 3:17      init   Open channel
    ld  HL, PRINT_OUT   ; 3:10      init
    ld (CURCHL),HL      ; 3:16      init
    ld  HL, putchar     ; 3:10      init
    ld (PRINT_OUT),HL   ; 3:10      init
  if 0
    ld   HL, 0x0000     ; 3:10      init
    ld  (putchar_yx),HL ; 3:16      init
  else
    ld   HL, 0x1821     ; 3:10      init
    ld   DE,(0x5C88)    ; 4:20      init
    or    A             ; 1:4       init
    sbc  HL, DE         ; 2:15      init
    ld    A, L          ; 1:4       init   x
    add   A, A          ; 1:4       init   2*x
    inc   A             ; 1:4       init   2*2+1
    add   A, A          ; 1:4       init   4*x+2
    add   A, A          ; 1:4       init   8*x+4
    ld    L, 0xFF       ; 2:7       init
    inc   L             ; 1:4       init
    sub 0x05            ; 2:7       init
    jr   nc, $-3        ; 2:7/12    init
    ld  (putchar_yx),HL ; 3:16      init
  endif
    ld   HL, 0xEA60     ; 3:10      init   Return address stack = 60000
    exx                 ; 1:4       init
    ld   BC, string101  ; 3:10      print_i   Address of string101 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
                        ;[8:42]     5 -5   ( -- 5 -5 )
    push DE             ; 1:11      5 -5
    push HL             ; 1:11      5 -5
    ld   DE, 0x0005     ; 3:10      5 -5
    ld   HL, 0xFFFB     ; 3:10      5 -5
    call x_x_test       ; 3:17      call ( -- )
                        ;[7:40]     5 5   ( -- 5 5 )
    push DE             ; 1:11      5 5
    push HL             ; 1:11      5 5
    ld   DE, 0x0005     ; 3:10      5 5
    ld    H, D          ; 1:4       5 5   H = D = 0x00
    ld    L, E          ; 1:4       5 5   L = E = 0x05
    call x_x_test       ; 3:17      call ( -- )
                        ;[7:40]     -5 -5   ( -- -5 -5 )
    push DE             ; 1:11      -5 -5
    push HL             ; 1:11      -5 -5
    ld   DE, 0xFFFB     ; 3:10      -5 -5
    ld    H, D          ; 1:4       -5 -5   H = D = 0xFF
    ld    L, E          ; 1:4       -5 -5   L = E = 0xFB
    call x_x_test       ; 3:17      call ( -- )
                        ;[8:42]     -5 5   ( -- -5 5 )
    push DE             ; 1:11      -5 5
    push HL             ; 1:11      -5 5
    ld   DE, 0xFFFB     ; 3:10      -5 5
    ld   HL, 0x0005     ; 3:10      -5 5
    call x_x_test       ; 3:17      call ( -- )
    ld   BC, string102  ; 3:10      print_i   Address of string102 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    push DE             ; 1:11      5. -5.
    push HL             ; 1:11      5. -5.
    ld   DE, 0x0000     ; 3:10      5. -5.
    push DE             ; 1:11      5. -5.
    ld    E, 0x05       ; 2:7       5. -5.
    push DE             ; 1:11      5. -5.
    dec   D             ; 1:4       5. -5.
    ld    E, D          ; 1:4       5. -5.   E = D = 0xFF
    ld   HL, 0xFFFB     ; 3:10      5. -5.
    call d_d_test       ; 3:17      call ( -- )
    push DE             ; 1:11      5. 5.
    push HL             ; 1:11      5. 5.
    ld   HL, 0x0005     ; 3:10      5. 5.
    ld    E, H          ; 1:4       5. 5.   E = H = 0x00
    ld    D, E          ; 1:4       5. 5.   D = E = 0x00
    push DE             ; 1:11      5. 5.
    push HL             ; 1:11      5. 5.
    call d_d_test       ; 3:17      call ( -- )
    push DE             ; 1:11      -5. -5.
    push HL             ; 1:11      -5. -5.
    ld   HL, 0xFFFB     ; 3:10      -5. -5.
    ld    E, H          ; 1:4       -5. -5.   E = H = 0xFF
    ld    D, E          ; 1:4       -5. -5.   D = E = 0xFF
    push DE             ; 1:11      -5. -5.
    push HL             ; 1:11      -5. -5.
    call d_d_test       ; 3:17      call ( -- )
    push DE             ; 1:11      -5. 5.
    push HL             ; 1:11      -5. 5.
    ld   DE, 0xFFFF     ; 3:10      -5. 5.
    push DE             ; 1:11      -5. 5.
    ld    E, 0xFB       ; 2:7       -5. 5.
    push DE             ; 1:11      -5. 5.
    inc   D             ; 1:4       -5. 5.
    ld    E, D          ; 1:4       -5. 5.   E = D = 0x00
    ld   HL, 0x0005     ; 3:10      -5. 5.
    call d_d_test       ; 3:17      call ( -- )
    push DE             ; 1:11      3
    ex   DE, HL         ; 1:4       3
    ld   HL, 3          ; 3:10      3
    call x_p3_test      ; 3:17      call ( -- )
    push DE             ; 1:11      -3
    ex   DE, HL         ; 1:4       -3
    ld   HL, 0-3        ; 3:10      -3
    call x_p3_test      ; 3:17      call ( -- )
    push DE             ; 1:11      3
    ex   DE, HL         ; 1:4       3
    ld   HL, 3          ; 3:10      3
    call x_m3_test      ; 3:17      call ( -- )
    push DE             ; 1:11      -3
    ex   DE, HL         ; 1:4       -3
    ld   HL, 0-3        ; 3:10      -3
    call x_m3_test      ; 3:17      call ( -- )
    ld   BC, string103  ; 3:10      print_i   Address of string103 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- min ------
    ld   BC, 10         ; 3:10      0 10 do_101(xm)
do101save:              ;           0 10 do_101(xm)
    ld  (idx101),BC     ; 4:20      0 10 do_101(xm)
do101:                  ;           0 10 do_101(xm)
    push DE             ; 1:11      i_101(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_101(m)
    ld   HL, (idx101)   ; 3:16      i_101(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[3:10]      < 0x8000   _TMP_STACK_INFO variant: <min
  .warning The condition is always False!
    jp   else101        ; 3:10       < 0x8000
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif101       ; 3:10      else
else101:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif101:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_101(xm)   variant -1.A: step -1 and stop 0, run 11x
idx101 EQU $+1          ;           -1 +loop_101(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_101(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_101(xm)
    or    B             ; 1:4       -1 +loop_101(xm)
    dec  BC             ; 1:6       -1 +loop_101(xm)   index--
    jp   nz, do101save  ; 3:10      -1 +loop_101(xm)
leave101:               ;           -1 +loop_101(xm)
exit101:                ;           xloop LOOP_STACK
    ld   BC, string104  ; 3:10      print_i   Address of string104 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_102(xm)
do102save:              ;           0 10 do_102(xm)
    ld  (idx102),BC     ; 4:20      0 10 do_102(xm)
do102:                  ;           0 10 do_102(xm)
    push DE             ; 1:11      i_102(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_102(m)
    ld   HL, (idx102)   ; 3:16      i_102(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[5:24]      < 0x8000   _TMP_STACK_INFO variant: min
  .warning The condition is always False!
    ex   DE, HL         ; 1:4        < 0x8000   HL<min --> false
    pop  DE             ; 1:10       < 0x8000
    jp   else102        ; 3:10       < 0x8000
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif102       ; 3:10      else
else102:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif102:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_102(xm)   variant -1.A: step -1 and stop 0, run 11x
idx102 EQU $+1          ;           -1 +loop_102(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_102(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_102(xm)
    or    B             ; 1:4       -1 +loop_102(xm)
    dec  BC             ; 1:6       -1 +loop_102(xm)   index--
    jp   nz, do102save  ; 3:10      -1 +loop_102(xm)
leave102:               ;           -1 +loop_102(xm)
exit102:                ;           xloop LOOP_STACK
    ld   BC, string104  ; 3:10      print_i   Address of string105 ending with inverted most significant bit == string104
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_103(xm)
do103save:              ;           0 10 do_103(xm)
    ld  (idx103),BC     ; 4:20      0 10 do_103(xm)
do103:                  ;           0 10 do_103(xm)
    push DE             ; 1:11      i_103(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_103(m)
    ld   HL, (idx103)   ; 3:16      i_103(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < min   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "min" cannot be evaluated
    ld    A, L          ; 1:4        < min   HL<min --> HL-min<0 --> false if not carry
    sub   low min       ; 2:7        < min   HL<min --> HL-min<0 --> false if not carry
    ld    A, H          ; 1:4        < min   HL<min --> HL-min<0 --> false if not carry
    sbc   A, high min   ; 2:7        < min   HL<min --> HL-min<0 --> false if not carry
    rra                 ; 1:4        < min
    xor   H             ; 1:4        < min   invert sign if HL is negative
  if ((min)>=0x8000 || (min)<0)
    jp    m, else103    ; 3:10       < min   negative constant --> false if sign
  else
    jp    p, else103    ; 3:10       < min   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif103       ; 3:10      else
else103:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif103:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_103(xm)   variant -1.A: step -1 and stop 0, run 11x
idx103 EQU $+1          ;           -1 +loop_103(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_103(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_103(xm)
    or    B             ; 1:4       -1 +loop_103(xm)
    dec  BC             ; 1:6       -1 +loop_103(xm)   index--
    jp   nz, do103save  ; 3:10      -1 +loop_103(xm)
leave103:               ;           -1 +loop_103(xm)
exit103:                ;           xloop LOOP_STACK
    ld   BC, string106  ; 3:10      print_i   Address of string106 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_104(xm)
do104save:              ;           0 10 do_104(xm)
    ld  (idx104),BC     ; 4:20      0 10 do_104(xm)
do104:                  ;           0 10 do_104(xm)
    push DE             ; 1:11      i_104(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_104(m)
    ld   HL, (idx104)   ; 3:16      i_104(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < min   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        < min   HL<min --> L-min<0
    sub  low min        ; 2:7        < min   HL<min --> L-min<0
    ld    A, H          ; 1:4        < min   HL<min --> H-min<0
    sbc   A, high min   ; 2:7        < min   HL<min --> H-min<0 --> false if not carry
    rra                 ; 1:4        < min
    xor   H             ; 1:4        < min   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < min
    pop  DE             ; 1:10       < min
  .warning The condition "min" cannot be evaluated
  if ((min)>=0x8000 || (min)<0)
    jp    m, else104    ; 3:10       < min
  else
    jp    p, else104    ; 3:10       < min
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif104       ; 3:10      else
else104:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif104:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_104(xm)   variant -1.A: step -1 and stop 0, run 11x
idx104 EQU $+1          ;           -1 +loop_104(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_104(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_104(xm)
    or    B             ; 1:4       -1 +loop_104(xm)
    dec  BC             ; 1:6       -1 +loop_104(xm)   index--
    jp   nz, do104save  ; 3:10      -1 +loop_104(xm)
leave104:               ;           -1 +loop_104(xm)
exit104:                ;           xloop LOOP_STACK
    ld   BC, string107  ; 3:10      print_i   Address of string107 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0xFEFD = 65277 ------
    ld   BC, 10         ; 3:10      0 10 do_105(xm)
do105save:              ;           0 10 do_105(xm)
    ld  (idx105),BC     ; 4:20      0 10 do_105(xm)
do105:                  ;           0 10 do_105(xm)
    push DE             ; 1:11      i_105(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_105(m)
    ld   HL, (idx105)   ; 3:16      i_105(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < +65277   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4        < +65277   HL<65277 --> L-0xFD<0 --> false if not carry
    sub  0xFD           ; 2:7        < +65277   HL<65277 --> L-0xFD<0 --> false if not carry
    ld    A, H          ; 1:4        < +65277   HL<65277 --> H-0xFE<0 --> false if not carry
    sbc   A, 0xFE       ; 2:7        < +65277   HL<65277 --> H-0xFE<0 --> false if not carry
    rra                 ; 1:4        < +65277
    xor   H             ; 1:4        < +65277   invert sign if HL is negative
    jp    m, else105    ; 3:10       < +65277   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif105       ; 3:10      else
else105:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif105:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_105(xm)   variant -1.A: step -1 and stop 0, run 11x
idx105 EQU $+1          ;           -1 +loop_105(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_105(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_105(xm)
    or    B             ; 1:4       -1 +loop_105(xm)
    dec  BC             ; 1:6       -1 +loop_105(xm)   index--
    jp   nz, do105save  ; 3:10      -1 +loop_105(xm)
leave105:               ;           -1 +loop_105(xm)
exit105:                ;           xloop LOOP_STACK
    ld   BC, string108  ; 3:10      print_i   Address of string108 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_106(xm)
do106save:              ;           0 10 do_106(xm)
    ld  (idx106),BC     ; 4:20      0 10 do_106(xm)
do106:                  ;           0 10 do_106(xm)
    push DE             ; 1:11      i_106(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_106(m)
    ld   HL, (idx106)   ; 3:16      i_106(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < +65277   _TMP_STACK_INFO variant: default
    ld    A, L          ; 1:4        < +65277   HL<65277 --> L-0xFD<0
    sub   0xFD          ; 2:7        < +65277   HL<65277 --> L-0xFD<0
    ld    A, H          ; 1:4        < +65277   HL<65277 --> H-0xFE<0
    sbc   A, 0xFE       ; 2:7        < +65277   HL<65277 --> H-0xFE<0 --> false if not carry
    rra                 ; 1:4        < +65277
    xor   H             ; 1:4        < +65277   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < +65277
    pop  DE             ; 1:10       < +65277
    jp    m, else106    ; 3:10       < +65277   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif106       ; 3:10      else
else106:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif106:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_106(xm)   variant -1.A: step -1 and stop 0, run 11x
idx106 EQU $+1          ;           -1 +loop_106(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_106(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_106(xm)
    or    B             ; 1:4       -1 +loop_106(xm)
    dec  BC             ; 1:6       -1 +loop_106(xm)   index--
    jp   nz, do106save  ; 3:10      -1 +loop_106(xm)
leave106:               ;           -1 +loop_106(xm)
exit106:                ;           xloop LOOP_STACK
    ld   BC, string108  ; 3:10      print_i   Address of string109 ending with inverted most significant bit == string108
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_107(xm)
do107save:              ;           0 10 do_107(xm)
    ld  (idx107),BC     ; 4:20      0 10 do_107(xm)
do107:                  ;           0 10 do_107(xm)
    push DE             ; 1:11      i_107(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_107(m)
    ld   HL, (idx107)   ; 3:16      i_107(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < xFEFD   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "xFEFD" cannot be evaluated
    ld    A, L          ; 1:4        < xFEFD   HL<xFEFD --> HL-xFEFD<0 --> false if not carry
    sub   low xFEFD     ; 2:7        < xFEFD   HL<xFEFD --> HL-xFEFD<0 --> false if not carry
    ld    A, H          ; 1:4        < xFEFD   HL<xFEFD --> HL-xFEFD<0 --> false if not carry
    sbc   A, high xFEFD ; 2:7        < xFEFD   HL<xFEFD --> HL-xFEFD<0 --> false if not carry
    rra                 ; 1:4        < xFEFD
    xor   H             ; 1:4        < xFEFD   invert sign if HL is negative
  if ((xFEFD)>=0x8000 || (xFEFD)<0)
    jp    m, else107    ; 3:10       < xFEFD   negative constant --> false if sign
  else
    jp    p, else107    ; 3:10       < xFEFD   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif107       ; 3:10      else
else107:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif107:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_107(xm)   variant -1.A: step -1 and stop 0, run 11x
idx107 EQU $+1          ;           -1 +loop_107(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_107(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_107(xm)
    or    B             ; 1:4       -1 +loop_107(xm)
    dec  BC             ; 1:6       -1 +loop_107(xm)   index--
    jp   nz, do107save  ; 3:10      -1 +loop_107(xm)
leave107:               ;           -1 +loop_107(xm)
exit107:                ;           xloop LOOP_STACK
    ld   BC, string110  ; 3:10      print_i   Address of string110 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_108(xm)
do108save:              ;           0 10 do_108(xm)
    ld  (idx108),BC     ; 4:20      0 10 do_108(xm)
do108:                  ;           0 10 do_108(xm)
    push DE             ; 1:11      i_108(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_108(m)
    ld   HL, (idx108)   ; 3:16      i_108(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < xFEFD   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        < xFEFD   HL<xFEFD --> L-xFEFD<0
    sub  low xFEFD      ; 2:7        < xFEFD   HL<xFEFD --> L-xFEFD<0
    ld    A, H          ; 1:4        < xFEFD   HL<xFEFD --> H-xFEFD<0
    sbc   A, high xFEFD ; 2:7        < xFEFD   HL<xFEFD --> H-xFEFD<0 --> false if not carry
    rra                 ; 1:4        < xFEFD
    xor   H             ; 1:4        < xFEFD   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < xFEFD
    pop  DE             ; 1:10       < xFEFD
  .warning The condition "xFEFD" cannot be evaluated
  if ((xFEFD)>=0x8000 || (xFEFD)<0)
    jp    m, else108    ; 3:10       < xFEFD
  else
    jp    p, else108    ; 3:10       < xFEFD
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif108       ; 3:10      else
else108:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif108:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_108(xm)   variant -1.A: step -1 and stop 0, run 11x
idx108 EQU $+1          ;           -1 +loop_108(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_108(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_108(xm)
    or    B             ; 1:4       -1 +loop_108(xm)
    dec  BC             ; 1:6       -1 +loop_108(xm)   index--
    jp   nz, do108save  ; 3:10      -1 +loop_108(xm)
leave108:               ;           -1 +loop_108(xm)
exit108:                ;           xloop LOOP_STACK
    ld   BC, string111  ; 3:10      print_i   Address of string111 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0xFEFE = 65278 ------
    ld   BC, 10         ; 3:10      0 10 do_109(xm)
do109save:              ;           0 10 do_109(xm)
    ld  (idx109),BC     ; 4:20      0 10 do_109(xm)
do109:                  ;           0 10 do_109(xm)
    push DE             ; 1:11      i_109(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_109(m)
    ld   HL, (idx109)   ; 3:16      i_109(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < +65278   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4        < +65278   HL<65278 --> L-0xFE<0 --> false if not carry
    sub  0xFE           ; 2:7        < +65278   HL<65278 --> L-0xFE<0 --> false if not carry
    ld    A, H          ; 1:4        < +65278   HL<65278 --> H-0xFE<0 --> false if not carry
    sbc   A, 0xFE       ; 2:7        < +65278   HL<65278 --> H-0xFE<0 --> false if not carry
    rra                 ; 1:4        < +65278
    xor   H             ; 1:4        < +65278   invert sign if HL is negative
    jp    m, else109    ; 3:10       < +65278   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif109       ; 3:10      else
else109:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif109:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_109(xm)   variant -1.A: step -1 and stop 0, run 11x
idx109 EQU $+1          ;           -1 +loop_109(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_109(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_109(xm)
    or    B             ; 1:4       -1 +loop_109(xm)
    dec  BC             ; 1:6       -1 +loop_109(xm)   index--
    jp   nz, do109save  ; 3:10      -1 +loop_109(xm)
leave109:               ;           -1 +loop_109(xm)
exit109:                ;           xloop LOOP_STACK
    ld   BC, string112  ; 3:10      print_i   Address of string112 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_110(xm)
do110save:              ;           0 10 do_110(xm)
    ld  (idx110),BC     ; 4:20      0 10 do_110(xm)
do110:                  ;           0 10 do_110(xm)
    push DE             ; 1:11      i_110(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_110(m)
    ld   HL, (idx110)   ; 3:16      i_110(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < +65278   _TMP_STACK_INFO variant: default
    ld    A, L          ; 1:4        < +65278   HL<65278 --> L-0xFE<0
    sub   0xFE          ; 2:7        < +65278   HL<65278 --> L-0xFE<0
    ld    A, H          ; 1:4        < +65278   HL<65278 --> H-0xFE<0
    sbc   A, 0xFE       ; 2:7        < +65278   HL<65278 --> H-0xFE<0 --> false if not carry
    rra                 ; 1:4        < +65278
    xor   H             ; 1:4        < +65278   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < +65278
    pop  DE             ; 1:10       < +65278
    jp    m, else110    ; 3:10       < +65278   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif110       ; 3:10      else
else110:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif110:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_110(xm)   variant -1.A: step -1 and stop 0, run 11x
idx110 EQU $+1          ;           -1 +loop_110(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_110(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_110(xm)
    or    B             ; 1:4       -1 +loop_110(xm)
    dec  BC             ; 1:6       -1 +loop_110(xm)   index--
    jp   nz, do110save  ; 3:10      -1 +loop_110(xm)
leave110:               ;           -1 +loop_110(xm)
exit110:                ;           xloop LOOP_STACK
    ld   BC, string112  ; 3:10      print_i   Address of string113 ending with inverted most significant bit == string112
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_111(xm)
do111save:              ;           0 10 do_111(xm)
    ld  (idx111),BC     ; 4:20      0 10 do_111(xm)
do111:                  ;           0 10 do_111(xm)
    push DE             ; 1:11      i_111(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_111(m)
    ld   HL, (idx111)   ; 3:16      i_111(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < xFEFE   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "xFEFE" cannot be evaluated
    ld    A, L          ; 1:4        < xFEFE   HL<xFEFE --> HL-xFEFE<0 --> false if not carry
    sub   low xFEFE     ; 2:7        < xFEFE   HL<xFEFE --> HL-xFEFE<0 --> false if not carry
    ld    A, H          ; 1:4        < xFEFE   HL<xFEFE --> HL-xFEFE<0 --> false if not carry
    sbc   A, high xFEFE ; 2:7        < xFEFE   HL<xFEFE --> HL-xFEFE<0 --> false if not carry
    rra                 ; 1:4        < xFEFE
    xor   H             ; 1:4        < xFEFE   invert sign if HL is negative
  if ((xFEFE)>=0x8000 || (xFEFE)<0)
    jp    m, else111    ; 3:10       < xFEFE   negative constant --> false if sign
  else
    jp    p, else111    ; 3:10       < xFEFE   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif111       ; 3:10      else
else111:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif111:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_111(xm)   variant -1.A: step -1 and stop 0, run 11x
idx111 EQU $+1          ;           -1 +loop_111(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_111(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_111(xm)
    or    B             ; 1:4       -1 +loop_111(xm)
    dec  BC             ; 1:6       -1 +loop_111(xm)   index--
    jp   nz, do111save  ; 3:10      -1 +loop_111(xm)
leave111:               ;           -1 +loop_111(xm)
exit111:                ;           xloop LOOP_STACK
    ld   BC, string114  ; 3:10      print_i   Address of string114 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_112(xm)
do112save:              ;           0 10 do_112(xm)
    ld  (idx112),BC     ; 4:20      0 10 do_112(xm)
do112:                  ;           0 10 do_112(xm)
    push DE             ; 1:11      i_112(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_112(m)
    ld   HL, (idx112)   ; 3:16      i_112(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < xFEFE   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        < xFEFE   HL<xFEFE --> L-xFEFE<0
    sub  low xFEFE      ; 2:7        < xFEFE   HL<xFEFE --> L-xFEFE<0
    ld    A, H          ; 1:4        < xFEFE   HL<xFEFE --> H-xFEFE<0
    sbc   A, high xFEFE ; 2:7        < xFEFE   HL<xFEFE --> H-xFEFE<0 --> false if not carry
    rra                 ; 1:4        < xFEFE
    xor   H             ; 1:4        < xFEFE   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < xFEFE
    pop  DE             ; 1:10       < xFEFE
  .warning The condition "xFEFE" cannot be evaluated
  if ((xFEFE)>=0x8000 || (xFEFE)<0)
    jp    m, else112    ; 3:10       < xFEFE
  else
    jp    p, else112    ; 3:10       < xFEFE
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif112       ; 3:10      else
else112:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif112:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_112(xm)   variant -1.A: step -1 and stop 0, run 11x
idx112 EQU $+1          ;           -1 +loop_112(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_112(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_112(xm)
    or    B             ; 1:4       -1 +loop_112(xm)
    dec  BC             ; 1:6       -1 +loop_112(xm)   index--
    jp   nz, do112save  ; 3:10      -1 +loop_112(xm)
leave112:               ;           -1 +loop_112(xm)
exit112:                ;           xloop LOOP_STACK
    ld   BC, string115  ; 3:10      print_i   Address of string115 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0xFEFF = 65279 ------
    ld   BC, 10         ; 3:10      0 10 do_113(xm)
do113save:              ;           0 10 do_113(xm)
    ld  (idx113),BC     ; 4:20      0 10 do_113(xm)
do113:                  ;           0 10 do_113(xm)
    push DE             ; 1:11      i_113(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_113(m)
    ld   HL, (idx113)   ; 3:16      i_113(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:33]      < +65279   _TMP_STACK_INFO #variant: hi == lo-1, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0xFE       ; 2:7        < +65279   HL< 0xFEFF --> HL<=0xFEFE
    cp    L             ; 1:4        < +65279   HL<=0xFEFE -->  0<=0xFE-L --> false if carry
    sbc   A, H          ; 1:4        < +65279   HL<=0xFEFE -->  0<=0xFE-H --> false if carry
    rra                 ; 1:4        < +65279
    xor   H             ; 1:4        < +65279   invert sign if HL is negative
    jp    p, else113    ; 3:10       < +65279   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif113       ; 3:10      else
else113:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif113:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_113(xm)   variant -1.A: step -1 and stop 0, run 11x
idx113 EQU $+1          ;           -1 +loop_113(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_113(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_113(xm)
    or    B             ; 1:4       -1 +loop_113(xm)
    dec  BC             ; 1:6       -1 +loop_113(xm)   index--
    jp   nz, do113save  ; 3:10      -1 +loop_113(xm)
leave113:               ;           -1 +loop_113(xm)
exit113:                ;           xloop LOOP_STACK
    ld   BC, string116  ; 3:10      print_i   Address of string116 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_114(xm)
do114save:              ;           0 10 do_114(xm)
    ld  (idx114),BC     ; 4:20      0 10 do_114(xm)
do114:                  ;           0 10 do_114(xm)
    push DE             ; 1:11      i_114(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_114(m)
    ld   HL, (idx114)   ; 3:16      i_114(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:47]      < +65279   _TMP_STACK_INFO variant: hi == lo-1
    ld    A, 0xFE       ; 2:7        < +65279   HL< 0xFEFF --> HL<=0xFEFE
    cp    L             ; 1:4        < +65279   HL<=0xFEFE -->  0<=0xFE-L
    sbc   A, H          ; 1:4        < +65279   HL<=0xFEFE -->  0<=0xFE-H --> false if carry
    rra                 ; 1:4        < +65279
    xor   H             ; 1:4        < +65279   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < +65279
    pop  DE             ; 1:10       < +65279
    jp    p, else114    ; 3:10       < +65279   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif114       ; 3:10      else
else114:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif114:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_114(xm)   variant -1.A: step -1 and stop 0, run 11x
idx114 EQU $+1          ;           -1 +loop_114(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_114(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_114(xm)
    or    B             ; 1:4       -1 +loop_114(xm)
    dec  BC             ; 1:6       -1 +loop_114(xm)   index--
    jp   nz, do114save  ; 3:10      -1 +loop_114(xm)
leave114:               ;           -1 +loop_114(xm)
exit114:                ;           xloop LOOP_STACK
    ld   BC, string116  ; 3:10      print_i   Address of string117 ending with inverted most significant bit == string116
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_115(xm)
do115save:              ;           0 10 do_115(xm)
    ld  (idx115),BC     ; 4:20      0 10 do_115(xm)
do115:                  ;           0 10 do_115(xm)
    push DE             ; 1:11      i_115(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_115(m)
    ld   HL, (idx115)   ; 3:16      i_115(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < xFEFF   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "xFEFF" cannot be evaluated
    ld    A, L          ; 1:4        < xFEFF   HL<xFEFF --> HL-xFEFF<0 --> false if not carry
    sub   low xFEFF     ; 2:7        < xFEFF   HL<xFEFF --> HL-xFEFF<0 --> false if not carry
    ld    A, H          ; 1:4        < xFEFF   HL<xFEFF --> HL-xFEFF<0 --> false if not carry
    sbc   A, high xFEFF ; 2:7        < xFEFF   HL<xFEFF --> HL-xFEFF<0 --> false if not carry
    rra                 ; 1:4        < xFEFF
    xor   H             ; 1:4        < xFEFF   invert sign if HL is negative
  if ((xFEFF)>=0x8000 || (xFEFF)<0)
    jp    m, else115    ; 3:10       < xFEFF   negative constant --> false if sign
  else
    jp    p, else115    ; 3:10       < xFEFF   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif115       ; 3:10      else
else115:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif115:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_115(xm)   variant -1.A: step -1 and stop 0, run 11x
idx115 EQU $+1          ;           -1 +loop_115(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_115(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_115(xm)
    or    B             ; 1:4       -1 +loop_115(xm)
    dec  BC             ; 1:6       -1 +loop_115(xm)   index--
    jp   nz, do115save  ; 3:10      -1 +loop_115(xm)
leave115:               ;           -1 +loop_115(xm)
exit115:                ;           xloop LOOP_STACK
    ld   BC, string118  ; 3:10      print_i   Address of string118 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_116(xm)
do116save:              ;           0 10 do_116(xm)
    ld  (idx116),BC     ; 4:20      0 10 do_116(xm)
do116:                  ;           0 10 do_116(xm)
    push DE             ; 1:11      i_116(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_116(m)
    ld   HL, (idx116)   ; 3:16      i_116(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < xFEFF   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        < xFEFF   HL<xFEFF --> L-xFEFF<0
    sub  low xFEFF      ; 2:7        < xFEFF   HL<xFEFF --> L-xFEFF<0
    ld    A, H          ; 1:4        < xFEFF   HL<xFEFF --> H-xFEFF<0
    sbc   A, high xFEFF ; 2:7        < xFEFF   HL<xFEFF --> H-xFEFF<0 --> false if not carry
    rra                 ; 1:4        < xFEFF
    xor   H             ; 1:4        < xFEFF   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < xFEFF
    pop  DE             ; 1:10       < xFEFF
  .warning The condition "xFEFF" cannot be evaluated
  if ((xFEFF)>=0x8000 || (xFEFF)<0)
    jp    m, else116    ; 3:10       < xFEFF
  else
    jp    p, else116    ; 3:10       < xFEFF
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif116       ; 3:10      else
else116:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif116:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_116(xm)   variant -1.A: step -1 and stop 0, run 11x
idx116 EQU $+1          ;           -1 +loop_116(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_116(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_116(xm)
    or    B             ; 1:4       -1 +loop_116(xm)
    dec  BC             ; 1:6       -1 +loop_116(xm)   index--
    jp   nz, do116save  ; 3:10      -1 +loop_116(xm)
leave116:               ;           -1 +loop_116(xm)
exit116:                ;           xloop LOOP_STACK
    ld   BC, string119  ; 3:10      print_i   Address of string119 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- -1 ------
    ld   BC, 10         ; 3:10      0 10 do_117(xm)
do117save:              ;           0 10 do_117(xm)
    ld  (idx117),BC     ; 4:20      0 10 do_117(xm)
do117:                  ;           0 10 do_117(xm)
    push DE             ; 1:11      i_117(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_117(m)
    ld   HL, (idx117)   ; 3:16      i_117(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < -1   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4        < -1   HL<-1 --> L-0xFF<0 --> false if not carry
    sub  0xFF           ; 2:7        < -1   HL<-1 --> L-0xFF<0 --> false if not carry
    ld    A, H          ; 1:4        < -1   HL<-1 --> H-0xFF<0 --> false if not carry
    sbc   A, 0xFF       ; 2:7        < -1   HL<-1 --> H-0xFF<0 --> false if not carry
    rra                 ; 1:4        < -1
    xor   H             ; 1:4        < -1   invert sign if HL is negative
    jp    m, else117    ; 3:10       < -1   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif117       ; 3:10      else
else117:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif117:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_117(xm)   variant -1.A: step -1 and stop 0, run 11x
idx117 EQU $+1          ;           -1 +loop_117(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_117(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_117(xm)
    or    B             ; 1:4       -1 +loop_117(xm)
    dec  BC             ; 1:6       -1 +loop_117(xm)   index--
    jp   nz, do117save  ; 3:10      -1 +loop_117(xm)
leave117:               ;           -1 +loop_117(xm)
exit117:                ;           xloop LOOP_STACK
    ld   BC, string120  ; 3:10      print_i   Address of string120 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_118(xm)
do118save:              ;           0 10 do_118(xm)
    ld  (idx118),BC     ; 4:20      0 10 do_118(xm)
do118:                  ;           0 10 do_118(xm)
    push DE             ; 1:11      i_118(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_118(m)
    ld   HL, (idx118)   ; 3:16      i_118(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < -1   _TMP_STACK_INFO variant: default
    ld    A, L          ; 1:4        < -1   HL<-1 --> L-0xFF<0
    sub   0xFF          ; 2:7        < -1   HL<-1 --> L-0xFF<0
    ld    A, H          ; 1:4        < -1   HL<-1 --> H-0xFF<0
    sbc   A, 0xFF       ; 2:7        < -1   HL<-1 --> H-0xFF<0 --> false if not carry
    rra                 ; 1:4        < -1
    xor   H             ; 1:4        < -1   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < -1
    pop  DE             ; 1:10       < -1
    jp    m, else118    ; 3:10       < -1   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif118       ; 3:10      else
else118:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif118:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_118(xm)   variant -1.A: step -1 and stop 0, run 11x
idx118 EQU $+1          ;           -1 +loop_118(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_118(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_118(xm)
    or    B             ; 1:4       -1 +loop_118(xm)
    dec  BC             ; 1:6       -1 +loop_118(xm)   index--
    jp   nz, do118save  ; 3:10      -1 +loop_118(xm)
leave118:               ;           -1 +loop_118(xm)
exit118:                ;           xloop LOOP_STACK
    ld   BC, string120  ; 3:10      print_i   Address of string121 ending with inverted most significant bit == string120
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_119(xm)
do119save:              ;           0 10 do_119(xm)
    ld  (idx119),BC     ; 4:20      0 10 do_119(xm)
do119:                  ;           0 10 do_119(xm)
    push DE             ; 1:11      i_119(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_119(m)
    ld   HL, (idx119)   ; 3:16      i_119(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < m1   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "m1" cannot be evaluated
    ld    A, L          ; 1:4        < m1   HL<m1 --> HL-m1<0 --> false if not carry
    sub   low m1        ; 2:7        < m1   HL<m1 --> HL-m1<0 --> false if not carry
    ld    A, H          ; 1:4        < m1   HL<m1 --> HL-m1<0 --> false if not carry
    sbc   A, high m1    ; 2:7        < m1   HL<m1 --> HL-m1<0 --> false if not carry
    rra                 ; 1:4        < m1
    xor   H             ; 1:4        < m1   invert sign if HL is negative
  if ((m1)>=0x8000 || (m1)<0)
    jp    m, else119    ; 3:10       < m1   negative constant --> false if sign
  else
    jp    p, else119    ; 3:10       < m1   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif119       ; 3:10      else
else119:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif119:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_119(xm)   variant -1.A: step -1 and stop 0, run 11x
idx119 EQU $+1          ;           -1 +loop_119(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_119(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_119(xm)
    or    B             ; 1:4       -1 +loop_119(xm)
    dec  BC             ; 1:6       -1 +loop_119(xm)   index--
    jp   nz, do119save  ; 3:10      -1 +loop_119(xm)
leave119:               ;           -1 +loop_119(xm)
exit119:                ;           xloop LOOP_STACK
    ld   BC, string122  ; 3:10      print_i   Address of string122 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_120(xm)
do120save:              ;           0 10 do_120(xm)
    ld  (idx120),BC     ; 4:20      0 10 do_120(xm)
do120:                  ;           0 10 do_120(xm)
    push DE             ; 1:11      i_120(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_120(m)
    ld   HL, (idx120)   ; 3:16      i_120(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < m1   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        < m1   HL<m1 --> L-m1<0
    sub  low m1         ; 2:7        < m1   HL<m1 --> L-m1<0
    ld    A, H          ; 1:4        < m1   HL<m1 --> H-m1<0
    sbc   A, high m1    ; 2:7        < m1   HL<m1 --> H-m1<0 --> false if not carry
    rra                 ; 1:4        < m1
    xor   H             ; 1:4        < m1   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < m1
    pop  DE             ; 1:10       < m1
  .warning The condition "m1" cannot be evaluated
  if ((m1)>=0x8000 || (m1)<0)
    jp    m, else120    ; 3:10       < m1
  else
    jp    p, else120    ; 3:10       < m1
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif120       ; 3:10      else
else120:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif120:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_120(xm)   variant -1.A: step -1 and stop 0, run 11x
idx120 EQU $+1          ;           -1 +loop_120(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_120(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_120(xm)
    or    B             ; 1:4       -1 +loop_120(xm)
    dec  BC             ; 1:6       -1 +loop_120(xm)   index--
    jp   nz, do120save  ; 3:10      -1 +loop_120(xm)
leave120:               ;           -1 +loop_120(xm)
exit120:                ;           xloop LOOP_STACK
    ld   BC, string123  ; 3:10      print_i   Address of string123 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0 ------
    ld   BC, 10         ; 3:10      0 10 do_121(xm)
do121save:              ;           0 10 do_121(xm)
    ld  (idx121),BC     ; 4:20      0 10 do_121(xm)
do121:                  ;           0 10 do_121(xm)
    push DE             ; 1:11      i_121(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_121(m)
    ld   HL, (idx121)   ; 3:16      i_121(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[5:18]      < 0   _TMP_STACK_INFO variant: <zero
    bit   7, H          ; 2:8        < 0
    jp    z, else121    ; 3:10       < 0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif121       ; 3:10      else
else121:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif121:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_121(xm)   variant -1.A: step -1 and stop 0, run 11x
idx121 EQU $+1          ;           -1 +loop_121(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_121(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_121(xm)
    or    B             ; 1:4       -1 +loop_121(xm)
    dec  BC             ; 1:6       -1 +loop_121(xm)   index--
    jp   nz, do121save  ; 3:10      -1 +loop_121(xm)
leave121:               ;           -1 +loop_121(xm)
exit121:                ;           xloop LOOP_STACK
    ld   BC, string124  ; 3:10      print_i   Address of string124 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_122(xm)
do122save:              ;           0 10 do_122(xm)
    ld  (idx122),BC     ; 4:20      0 10 do_122(xm)
do122:                  ;           0 10 do_122(xm)
    push DE             ; 1:11      i_122(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_122(m)
    ld   HL, (idx122)   ; 3:16      i_122(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:32]      < 0   _TMP_STACK_INFO variant: 0
    rl    H             ; 2:8        < 0   HL<0 --> no sign if false
    ex   DE, HL         ; 1:4        < 0
    pop  DE             ; 1:10       < 0
    jp   nc, else122    ; 3:10       < 0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif122       ; 3:10      else
else122:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif122:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_122(xm)   variant -1.A: step -1 and stop 0, run 11x
idx122 EQU $+1          ;           -1 +loop_122(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_122(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_122(xm)
    or    B             ; 1:4       -1 +loop_122(xm)
    dec  BC             ; 1:6       -1 +loop_122(xm)   index--
    jp   nz, do122save  ; 3:10      -1 +loop_122(xm)
leave122:               ;           -1 +loop_122(xm)
exit122:                ;           xloop LOOP_STACK
    ld   BC, string124  ; 3:10      print_i   Address of string125 ending with inverted most significant bit == string124
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_123(xm)
do123save:              ;           0 10 do_123(xm)
    ld  (idx123),BC     ; 4:20      0 10 do_123(xm)
do123:                  ;           0 10 do_123(xm)
    push DE             ; 1:11      i_123(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_123(m)
    ld   HL, (idx123)   ; 3:16      i_123(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < zero   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "zero" cannot be evaluated
    ld    A, L          ; 1:4        < zero   HL<zero --> HL-zero<0 --> false if not carry
    sub   low zero      ; 2:7        < zero   HL<zero --> HL-zero<0 --> false if not carry
    ld    A, H          ; 1:4        < zero   HL<zero --> HL-zero<0 --> false if not carry
    sbc   A, high zero  ; 2:7        < zero   HL<zero --> HL-zero<0 --> false if not carry
    rra                 ; 1:4        < zero
    xor   H             ; 1:4        < zero   invert sign if HL is negative
  if ((zero)>=0x8000 || (zero)<0)
    jp    m, else123    ; 3:10       < zero   negative constant --> false if sign
  else
    jp    p, else123    ; 3:10       < zero   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif123       ; 3:10      else
else123:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif123:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_123(xm)   variant -1.A: step -1 and stop 0, run 11x
idx123 EQU $+1          ;           -1 +loop_123(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_123(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_123(xm)
    or    B             ; 1:4       -1 +loop_123(xm)
    dec  BC             ; 1:6       -1 +loop_123(xm)   index--
    jp   nz, do123save  ; 3:10      -1 +loop_123(xm)
leave123:               ;           -1 +loop_123(xm)
exit123:                ;           xloop LOOP_STACK
    ld   BC, string126  ; 3:10      print_i   Address of string126 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_124(xm)
do124save:              ;           0 10 do_124(xm)
    ld  (idx124),BC     ; 4:20      0 10 do_124(xm)
do124:                  ;           0 10 do_124(xm)
    push DE             ; 1:11      i_124(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_124(m)
    ld   HL, (idx124)   ; 3:16      i_124(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < zero   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        < zero   HL<zero --> L-zero<0
    sub  low zero       ; 2:7        < zero   HL<zero --> L-zero<0
    ld    A, H          ; 1:4        < zero   HL<zero --> H-zero<0
    sbc   A, high zero  ; 2:7        < zero   HL<zero --> H-zero<0 --> false if not carry
    rra                 ; 1:4        < zero
    xor   H             ; 1:4        < zero   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < zero
    pop  DE             ; 1:10       < zero
  .warning The condition "zero" cannot be evaluated
  if ((zero)>=0x8000 || (zero)<0)
    jp    m, else124    ; 3:10       < zero
  else
    jp    p, else124    ; 3:10       < zero
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif124       ; 3:10      else
else124:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif124:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_124(xm)   variant -1.A: step -1 and stop 0, run 11x
idx124 EQU $+1          ;           -1 +loop_124(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_124(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_124(xm)
    or    B             ; 1:4       -1 +loop_124(xm)
    dec  BC             ; 1:6       -1 +loop_124(xm)   index--
    jp   nz, do124save  ; 3:10      -1 +loop_124(xm)
leave124:               ;           -1 +loop_124(xm)
exit124:                ;           xloop LOOP_STACK
    ld   BC, string127  ; 3:10      print_i   Address of string127 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 1 ------
    ld   BC, 10         ; 3:10      0 10 do_125(xm)
do125save:              ;           0 10 do_125(xm)
    ld  (idx125),BC     ; 4:20      0 10 do_125(xm)
do125:                  ;           0 10 do_125(xm)
    push DE             ; 1:11      i_125(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_125(m)
    ld   HL, (idx125)   ; 3:16      i_125(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:30]      < +1   _TMP_STACK_INFO variant: <1
    ld    A, H          ; 1:4        < +1   save sign
    dec  HL             ; 1:6        < +1   zero to negative
    or    H             ; 1:4        < +1
    inc  HL             ; 1:6        < +1
    jp    p, else125    ; 3:10       < +1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif125       ; 3:10      else
else125:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif125:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_125(xm)   variant -1.A: step -1 and stop 0, run 11x
idx125 EQU $+1          ;           -1 +loop_125(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_125(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_125(xm)
    or    B             ; 1:4       -1 +loop_125(xm)
    dec  BC             ; 1:6       -1 +loop_125(xm)   index--
    jp   nz, do125save  ; 3:10      -1 +loop_125(xm)
leave125:               ;           -1 +loop_125(xm)
exit125:                ;           xloop LOOP_STACK
    ld   BC, string128  ; 3:10      print_i   Address of string128 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_126(xm)
do126save:              ;           0 10 do_126(xm)
    ld  (idx126),BC     ; 4:20      0 10 do_126(xm)
do126:                  ;           0 10 do_126(xm)
    push DE             ; 1:11      i_126(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_126(m)
    ld   HL, (idx126)   ; 3:16      i_126(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[8:38]      < +1   _TMP_STACK_INFO variant: 1
    ld    A, H          ; 1:4        < +1   HL< 0         --> no sign if false
    dec  HL             ; 1:6        < +1   HL<=0         --> no sign if false
    or    H             ; 1:4        < +1   HL<=0 && HL<0 --> no sign if false
    ex   DE, HL         ; 1:4        < +1
    pop  DE             ; 1:10       < +1
    jp    p, else126    ; 3:10       < +1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif126       ; 3:10      else
else126:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif126:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_126(xm)   variant -1.A: step -1 and stop 0, run 11x
idx126 EQU $+1          ;           -1 +loop_126(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_126(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_126(xm)
    or    B             ; 1:4       -1 +loop_126(xm)
    dec  BC             ; 1:6       -1 +loop_126(xm)   index--
    jp   nz, do126save  ; 3:10      -1 +loop_126(xm)
leave126:               ;           -1 +loop_126(xm)
exit126:                ;           xloop LOOP_STACK
    ld   BC, string128  ; 3:10      print_i   Address of string129 ending with inverted most significant bit == string128
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_127(xm)
do127save:              ;           0 10 do_127(xm)
    ld  (idx127),BC     ; 4:20      0 10 do_127(xm)
do127:                  ;           0 10 do_127(xm)
    push DE             ; 1:11      i_127(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_127(m)
    ld   HL, (idx127)   ; 3:16      i_127(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < p1   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "p1" cannot be evaluated
    ld    A, L          ; 1:4        < p1   HL<p1 --> HL-p1<0 --> false if not carry
    sub   low p1        ; 2:7        < p1   HL<p1 --> HL-p1<0 --> false if not carry
    ld    A, H          ; 1:4        < p1   HL<p1 --> HL-p1<0 --> false if not carry
    sbc   A, high p1    ; 2:7        < p1   HL<p1 --> HL-p1<0 --> false if not carry
    rra                 ; 1:4        < p1
    xor   H             ; 1:4        < p1   invert sign if HL is negative
  if ((p1)>=0x8000 || (p1)<0)
    jp    m, else127    ; 3:10       < p1   negative constant --> false if sign
  else
    jp    p, else127    ; 3:10       < p1   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif127       ; 3:10      else
else127:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif127:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_127(xm)   variant -1.A: step -1 and stop 0, run 11x
idx127 EQU $+1          ;           -1 +loop_127(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_127(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_127(xm)
    or    B             ; 1:4       -1 +loop_127(xm)
    dec  BC             ; 1:6       -1 +loop_127(xm)   index--
    jp   nz, do127save  ; 3:10      -1 +loop_127(xm)
leave127:               ;           -1 +loop_127(xm)
exit127:                ;           xloop LOOP_STACK
    ld   BC, string130  ; 3:10      print_i   Address of string130 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_128(xm)
do128save:              ;           0 10 do_128(xm)
    ld  (idx128),BC     ; 4:20      0 10 do_128(xm)
do128:                  ;           0 10 do_128(xm)
    push DE             ; 1:11      i_128(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_128(m)
    ld   HL, (idx128)   ; 3:16      i_128(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < p1   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        < p1   HL<p1 --> L-p1<0
    sub  low p1         ; 2:7        < p1   HL<p1 --> L-p1<0
    ld    A, H          ; 1:4        < p1   HL<p1 --> H-p1<0
    sbc   A, high p1    ; 2:7        < p1   HL<p1 --> H-p1<0 --> false if not carry
    rra                 ; 1:4        < p1
    xor   H             ; 1:4        < p1   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < p1
    pop  DE             ; 1:10       < p1
  .warning The condition "p1" cannot be evaluated
  if ((p1)>=0x8000 || (p1)<0)
    jp    m, else128    ; 3:10       < p1
  else
    jp    p, else128    ; 3:10       < p1
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif128       ; 3:10      else
else128:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif128:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_128(xm)   variant -1.A: step -1 and stop 0, run 11x
idx128 EQU $+1          ;           -1 +loop_128(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_128(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_128(xm)
    or    B             ; 1:4       -1 +loop_128(xm)
    dec  BC             ; 1:6       -1 +loop_128(xm)   index--
    jp   nz, do128save  ; 3:10      -1 +loop_128(xm)
leave128:               ;           -1 +loop_128(xm)
exit128:                ;           xloop LOOP_STACK
    ld   BC, string131  ; 3:10      print_i   Address of string131 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3332 = 13106 ------
    ld   BC, 10         ; 3:10      0 10 do_129(xm)
do129save:              ;           0 10 do_129(xm)
    ld  (idx129),BC     ; 4:20      0 10 do_129(xm)
do129:                  ;           0 10 do_129(xm)
    push DE             ; 1:11      i_129(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_129(m)
    ld   HL, (idx129)   ; 3:16      i_129(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < +13106   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4        < +13106   HL<13106 --> L-0x32<0 --> false if not carry
    sub  0x32           ; 2:7        < +13106   HL<13106 --> L-0x32<0 --> false if not carry
    ld    A, H          ; 1:4        < +13106   HL<13106 --> H-0x33<0 --> false if not carry
    sbc   A, 0x33       ; 2:7        < +13106   HL<13106 --> H-0x33<0 --> false if not carry
    rra                 ; 1:4        < +13106
    xor   H             ; 1:4        < +13106   invert sign if HL is negative
    jp    p, else129    ; 3:10       < +13106   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif129       ; 3:10      else
else129:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif129:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_129(xm)   variant -1.A: step -1 and stop 0, run 11x
idx129 EQU $+1          ;           -1 +loop_129(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_129(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_129(xm)
    or    B             ; 1:4       -1 +loop_129(xm)
    dec  BC             ; 1:6       -1 +loop_129(xm)   index--
    jp   nz, do129save  ; 3:10      -1 +loop_129(xm)
leave129:               ;           -1 +loop_129(xm)
exit129:                ;           xloop LOOP_STACK
    ld   BC, string132  ; 3:10      print_i   Address of string132 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_130(xm)
do130save:              ;           0 10 do_130(xm)
    ld  (idx130),BC     ; 4:20      0 10 do_130(xm)
do130:                  ;           0 10 do_130(xm)
    push DE             ; 1:11      i_130(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_130(m)
    ld   HL, (idx130)   ; 3:16      i_130(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < +13106   _TMP_STACK_INFO variant: default
    ld    A, L          ; 1:4        < +13106   HL<13106 --> L-0x32<0
    sub   0x32          ; 2:7        < +13106   HL<13106 --> L-0x32<0
    ld    A, H          ; 1:4        < +13106   HL<13106 --> H-0x33<0
    sbc   A, 0x33       ; 2:7        < +13106   HL<13106 --> H-0x33<0 --> false if not carry
    rra                 ; 1:4        < +13106
    xor   H             ; 1:4        < +13106   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < +13106
    pop  DE             ; 1:10       < +13106
    jp    p, else130    ; 3:10       < +13106   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif130       ; 3:10      else
else130:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif130:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_130(xm)   variant -1.A: step -1 and stop 0, run 11x
idx130 EQU $+1          ;           -1 +loop_130(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_130(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_130(xm)
    or    B             ; 1:4       -1 +loop_130(xm)
    dec  BC             ; 1:6       -1 +loop_130(xm)   index--
    jp   nz, do130save  ; 3:10      -1 +loop_130(xm)
leave130:               ;           -1 +loop_130(xm)
exit130:                ;           xloop LOOP_STACK
    ld   BC, string132  ; 3:10      print_i   Address of string133 ending with inverted most significant bit == string132
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_131(xm)
do131save:              ;           0 10 do_131(xm)
    ld  (idx131),BC     ; 4:20      0 10 do_131(xm)
do131:                  ;           0 10 do_131(xm)
    push DE             ; 1:11      i_131(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_131(m)
    ld   HL, (idx131)   ; 3:16      i_131(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < x3332   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "x3332" cannot be evaluated
    ld    A, L          ; 1:4        < x3332   HL<x3332 --> HL-x3332<0 --> false if not carry
    sub   low x3332     ; 2:7        < x3332   HL<x3332 --> HL-x3332<0 --> false if not carry
    ld    A, H          ; 1:4        < x3332   HL<x3332 --> HL-x3332<0 --> false if not carry
    sbc   A, high x3332 ; 2:7        < x3332   HL<x3332 --> HL-x3332<0 --> false if not carry
    rra                 ; 1:4        < x3332
    xor   H             ; 1:4        < x3332   invert sign if HL is negative
  if ((x3332)>=0x8000 || (x3332)<0)
    jp    m, else131    ; 3:10       < x3332   negative constant --> false if sign
  else
    jp    p, else131    ; 3:10       < x3332   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif131       ; 3:10      else
else131:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif131:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_131(xm)   variant -1.A: step -1 and stop 0, run 11x
idx131 EQU $+1          ;           -1 +loop_131(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_131(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_131(xm)
    or    B             ; 1:4       -1 +loop_131(xm)
    dec  BC             ; 1:6       -1 +loop_131(xm)   index--
    jp   nz, do131save  ; 3:10      -1 +loop_131(xm)
leave131:               ;           -1 +loop_131(xm)
exit131:                ;           xloop LOOP_STACK
    ld   BC, string134  ; 3:10      print_i   Address of string134 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_132(xm)
do132save:              ;           0 10 do_132(xm)
    ld  (idx132),BC     ; 4:20      0 10 do_132(xm)
do132:                  ;           0 10 do_132(xm)
    push DE             ; 1:11      i_132(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_132(m)
    ld   HL, (idx132)   ; 3:16      i_132(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < x3332   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        < x3332   HL<x3332 --> L-x3332<0
    sub  low x3332      ; 2:7        < x3332   HL<x3332 --> L-x3332<0
    ld    A, H          ; 1:4        < x3332   HL<x3332 --> H-x3332<0
    sbc   A, high x3332 ; 2:7        < x3332   HL<x3332 --> H-x3332<0 --> false if not carry
    rra                 ; 1:4        < x3332
    xor   H             ; 1:4        < x3332   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < x3332
    pop  DE             ; 1:10       < x3332
  .warning The condition "x3332" cannot be evaluated
  if ((x3332)>=0x8000 || (x3332)<0)
    jp    m, else132    ; 3:10       < x3332
  else
    jp    p, else132    ; 3:10       < x3332
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif132       ; 3:10      else
else132:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif132:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_132(xm)   variant -1.A: step -1 and stop 0, run 11x
idx132 EQU $+1          ;           -1 +loop_132(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_132(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_132(xm)
    or    B             ; 1:4       -1 +loop_132(xm)
    dec  BC             ; 1:6       -1 +loop_132(xm)   index--
    jp   nz, do132save  ; 3:10      -1 +loop_132(xm)
leave132:               ;           -1 +loop_132(xm)
exit132:                ;           xloop LOOP_STACK
    ld   BC, string135  ; 3:10      print_i   Address of string135 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3333 = 13107 ------
    ld   BC, 10         ; 3:10      0 10 do_133(xm)
do133save:              ;           0 10 do_133(xm)
    ld  (idx133),BC     ; 4:20      0 10 do_133(xm)
do133:                  ;           0 10 do_133(xm)
    push DE             ; 1:11      i_133(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_133(m)
    ld   HL, (idx133)   ; 3:16      i_133(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < +13107   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4        < +13107   HL<13107 --> L-0x33<0 --> false if not carry
    sub  0x33           ; 2:7        < +13107   HL<13107 --> L-0x33<0 --> false if not carry
    ld    A, H          ; 1:4        < +13107   HL<13107 --> H-0x33<0 --> false if not carry
    sbc   A, 0x33       ; 2:7        < +13107   HL<13107 --> H-0x33<0 --> false if not carry
    rra                 ; 1:4        < +13107
    xor   H             ; 1:4        < +13107   invert sign if HL is negative
    jp    p, else133    ; 3:10       < +13107   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif133       ; 3:10      else
else133:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif133:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_133(xm)   variant -1.A: step -1 and stop 0, run 11x
idx133 EQU $+1          ;           -1 +loop_133(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_133(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_133(xm)
    or    B             ; 1:4       -1 +loop_133(xm)
    dec  BC             ; 1:6       -1 +loop_133(xm)   index--
    jp   nz, do133save  ; 3:10      -1 +loop_133(xm)
leave133:               ;           -1 +loop_133(xm)
exit133:                ;           xloop LOOP_STACK
    ld   BC, string136  ; 3:10      print_i   Address of string136 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_134(xm)
do134save:              ;           0 10 do_134(xm)
    ld  (idx134),BC     ; 4:20      0 10 do_134(xm)
do134:                  ;           0 10 do_134(xm)
    push DE             ; 1:11      i_134(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_134(m)
    ld   HL, (idx134)   ; 3:16      i_134(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < +13107   _TMP_STACK_INFO variant: default
    ld    A, L          ; 1:4        < +13107   HL<13107 --> L-0x33<0
    sub   0x33          ; 2:7        < +13107   HL<13107 --> L-0x33<0
    ld    A, H          ; 1:4        < +13107   HL<13107 --> H-0x33<0
    sbc   A, 0x33       ; 2:7        < +13107   HL<13107 --> H-0x33<0 --> false if not carry
    rra                 ; 1:4        < +13107
    xor   H             ; 1:4        < +13107   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < +13107
    pop  DE             ; 1:10       < +13107
    jp    p, else134    ; 3:10       < +13107   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif134       ; 3:10      else
else134:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif134:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_134(xm)   variant -1.A: step -1 and stop 0, run 11x
idx134 EQU $+1          ;           -1 +loop_134(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_134(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_134(xm)
    or    B             ; 1:4       -1 +loop_134(xm)
    dec  BC             ; 1:6       -1 +loop_134(xm)   index--
    jp   nz, do134save  ; 3:10      -1 +loop_134(xm)
leave134:               ;           -1 +loop_134(xm)
exit134:                ;           xloop LOOP_STACK
    ld   BC, string136  ; 3:10      print_i   Address of string137 ending with inverted most significant bit == string136
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_135(xm)
do135save:              ;           0 10 do_135(xm)
    ld  (idx135),BC     ; 4:20      0 10 do_135(xm)
do135:                  ;           0 10 do_135(xm)
    push DE             ; 1:11      i_135(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_135(m)
    ld   HL, (idx135)   ; 3:16      i_135(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < x3333   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "x3333" cannot be evaluated
    ld    A, L          ; 1:4        < x3333   HL<x3333 --> HL-x3333<0 --> false if not carry
    sub   low x3333     ; 2:7        < x3333   HL<x3333 --> HL-x3333<0 --> false if not carry
    ld    A, H          ; 1:4        < x3333   HL<x3333 --> HL-x3333<0 --> false if not carry
    sbc   A, high x3333 ; 2:7        < x3333   HL<x3333 --> HL-x3333<0 --> false if not carry
    rra                 ; 1:4        < x3333
    xor   H             ; 1:4        < x3333   invert sign if HL is negative
  if ((x3333)>=0x8000 || (x3333)<0)
    jp    m, else135    ; 3:10       < x3333   negative constant --> false if sign
  else
    jp    p, else135    ; 3:10       < x3333   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif135       ; 3:10      else
else135:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif135:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_135(xm)   variant -1.A: step -1 and stop 0, run 11x
idx135 EQU $+1          ;           -1 +loop_135(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_135(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_135(xm)
    or    B             ; 1:4       -1 +loop_135(xm)
    dec  BC             ; 1:6       -1 +loop_135(xm)   index--
    jp   nz, do135save  ; 3:10      -1 +loop_135(xm)
leave135:               ;           -1 +loop_135(xm)
exit135:                ;           xloop LOOP_STACK
    ld   BC, string138  ; 3:10      print_i   Address of string138 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_136(xm)
do136save:              ;           0 10 do_136(xm)
    ld  (idx136),BC     ; 4:20      0 10 do_136(xm)
do136:                  ;           0 10 do_136(xm)
    push DE             ; 1:11      i_136(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_136(m)
    ld   HL, (idx136)   ; 3:16      i_136(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < x3333   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        < x3333   HL<x3333 --> L-x3333<0
    sub  low x3333      ; 2:7        < x3333   HL<x3333 --> L-x3333<0
    ld    A, H          ; 1:4        < x3333   HL<x3333 --> H-x3333<0
    sbc   A, high x3333 ; 2:7        < x3333   HL<x3333 --> H-x3333<0 --> false if not carry
    rra                 ; 1:4        < x3333
    xor   H             ; 1:4        < x3333   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < x3333
    pop  DE             ; 1:10       < x3333
  .warning The condition "x3333" cannot be evaluated
  if ((x3333)>=0x8000 || (x3333)<0)
    jp    m, else136    ; 3:10       < x3333
  else
    jp    p, else136    ; 3:10       < x3333
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif136       ; 3:10      else
else136:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif136:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_136(xm)   variant -1.A: step -1 and stop 0, run 11x
idx136 EQU $+1          ;           -1 +loop_136(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_136(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_136(xm)
    or    B             ; 1:4       -1 +loop_136(xm)
    dec  BC             ; 1:6       -1 +loop_136(xm)   index--
    jp   nz, do136save  ; 3:10      -1 +loop_136(xm)
leave136:               ;           -1 +loop_136(xm)
exit136:                ;           xloop LOOP_STACK
    ld   BC, string139  ; 3:10      print_i   Address of string139 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3334 = 13108 ------
    ld   BC, 10         ; 3:10      0 10 do_137(xm)
do137save:              ;           0 10 do_137(xm)
    ld  (idx137),BC     ; 4:20      0 10 do_137(xm)
do137:                  ;           0 10 do_137(xm)
    push DE             ; 1:11      i_137(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_137(m)
    ld   HL, (idx137)   ; 3:16      i_137(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:33]      < +13108   _TMP_STACK_INFO #variant: hi == lo-1, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0x33       ; 2:7        < +13108   HL< 0x3334 --> HL<=0x3333
    cp    L             ; 1:4        < +13108   HL<=0x3333 -->  0<=0x33-L --> false if carry
    sbc   A, H          ; 1:4        < +13108   HL<=0x3333 -->  0<=0x33-H --> false if carry
    rra                 ; 1:4        < +13108
    xor   H             ; 1:4        < +13108   invert sign if HL is negative
    jp    m, else137    ; 3:10       < +13108   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif137       ; 3:10      else
else137:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif137:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_137(xm)   variant -1.A: step -1 and stop 0, run 11x
idx137 EQU $+1          ;           -1 +loop_137(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_137(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_137(xm)
    or    B             ; 1:4       -1 +loop_137(xm)
    dec  BC             ; 1:6       -1 +loop_137(xm)   index--
    jp   nz, do137save  ; 3:10      -1 +loop_137(xm)
leave137:               ;           -1 +loop_137(xm)
exit137:                ;           xloop LOOP_STACK
    ld   BC, string140  ; 3:10      print_i   Address of string140 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_138(xm)
do138save:              ;           0 10 do_138(xm)
    ld  (idx138),BC     ; 4:20      0 10 do_138(xm)
do138:                  ;           0 10 do_138(xm)
    push DE             ; 1:11      i_138(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_138(m)
    ld   HL, (idx138)   ; 3:16      i_138(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:47]      < +13108   _TMP_STACK_INFO variant: hi == lo-1
    ld    A, 0x33       ; 2:7        < +13108   HL< 0x3334 --> HL<=0x3333
    cp    L             ; 1:4        < +13108   HL<=0x3333 -->  0<=0x33-L
    sbc   A, H          ; 1:4        < +13108   HL<=0x3333 -->  0<=0x33-H --> false if carry
    rra                 ; 1:4        < +13108
    xor   H             ; 1:4        < +13108   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < +13108
    pop  DE             ; 1:10       < +13108
    jp    m, else138    ; 3:10       < +13108   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif138       ; 3:10      else
else138:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif138:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_138(xm)   variant -1.A: step -1 and stop 0, run 11x
idx138 EQU $+1          ;           -1 +loop_138(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_138(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_138(xm)
    or    B             ; 1:4       -1 +loop_138(xm)
    dec  BC             ; 1:6       -1 +loop_138(xm)   index--
    jp   nz, do138save  ; 3:10      -1 +loop_138(xm)
leave138:               ;           -1 +loop_138(xm)
exit138:                ;           xloop LOOP_STACK
    ld   BC, string140  ; 3:10      print_i   Address of string141 ending with inverted most significant bit == string140
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_139(xm)
do139save:              ;           0 10 do_139(xm)
    ld  (idx139),BC     ; 4:20      0 10 do_139(xm)
do139:                  ;           0 10 do_139(xm)
    push DE             ; 1:11      i_139(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_139(m)
    ld   HL, (idx139)   ; 3:16      i_139(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < x3334   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "x3334" cannot be evaluated
    ld    A, L          ; 1:4        < x3334   HL<x3334 --> HL-x3334<0 --> false if not carry
    sub   low x3334     ; 2:7        < x3334   HL<x3334 --> HL-x3334<0 --> false if not carry
    ld    A, H          ; 1:4        < x3334   HL<x3334 --> HL-x3334<0 --> false if not carry
    sbc   A, high x3334 ; 2:7        < x3334   HL<x3334 --> HL-x3334<0 --> false if not carry
    rra                 ; 1:4        < x3334
    xor   H             ; 1:4        < x3334   invert sign if HL is negative
  if ((x3334)>=0x8000 || (x3334)<0)
    jp    m, else139    ; 3:10       < x3334   negative constant --> false if sign
  else
    jp    p, else139    ; 3:10       < x3334   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif139       ; 3:10      else
else139:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif139:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_139(xm)   variant -1.A: step -1 and stop 0, run 11x
idx139 EQU $+1          ;           -1 +loop_139(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_139(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_139(xm)
    or    B             ; 1:4       -1 +loop_139(xm)
    dec  BC             ; 1:6       -1 +loop_139(xm)   index--
    jp   nz, do139save  ; 3:10      -1 +loop_139(xm)
leave139:               ;           -1 +loop_139(xm)
exit139:                ;           xloop LOOP_STACK
    ld   BC, string142  ; 3:10      print_i   Address of string142 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_140(xm)
do140save:              ;           0 10 do_140(xm)
    ld  (idx140),BC     ; 4:20      0 10 do_140(xm)
do140:                  ;           0 10 do_140(xm)
    push DE             ; 1:11      i_140(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_140(m)
    ld   HL, (idx140)   ; 3:16      i_140(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < x3334   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        < x3334   HL<x3334 --> L-x3334<0
    sub  low x3334      ; 2:7        < x3334   HL<x3334 --> L-x3334<0
    ld    A, H          ; 1:4        < x3334   HL<x3334 --> H-x3334<0
    sbc   A, high x3334 ; 2:7        < x3334   HL<x3334 --> H-x3334<0 --> false if not carry
    rra                 ; 1:4        < x3334
    xor   H             ; 1:4        < x3334   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < x3334
    pop  DE             ; 1:10       < x3334
  .warning The condition "x3334" cannot be evaluated
  if ((x3334)>=0x8000 || (x3334)<0)
    jp    m, else140    ; 3:10       < x3334
  else
    jp    p, else140    ; 3:10       < x3334
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif140       ; 3:10      else
else140:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif140:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_140(xm)   variant -1.A: step -1 and stop 0, run 11x
idx140 EQU $+1          ;           -1 +loop_140(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_140(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_140(xm)
    or    B             ; 1:4       -1 +loop_140(xm)
    dec  BC             ; 1:6       -1 +loop_140(xm)   index--
    jp   nz, do140save  ; 3:10      -1 +loop_140(xm)
leave140:               ;           -1 +loop_140(xm)
exit140:                ;           xloop LOOP_STACK
    ld   BC, string143  ; 3:10      print_i   Address of string143 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- max ------
    ld   BC, 10         ; 3:10      0 10 do_141(xm)
do141save:              ;           0 10 do_141(xm)
    ld  (idx141),BC     ; 4:20      0 10 do_141(xm)
do141:                  ;           0 10 do_141(xm)
    push DE             ; 1:11      i_141(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_141(m)
    ld   HL, (idx141)   ; 3:16      i_141(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[8:29]      < 0x7FFF   _TMP_STACK_INFO variant: <max
    ld    A, 0x80       ; 2:7        < 0x7FFF
    xor   H             ; 1:4        < 0x7FFF
    and   L             ; 1:4        < 0x7FFF
    inc   A             ; 1:4        < 0x7FFF
    jp    z, else141    ; 3:10       < 0x7FFF
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif141       ; 3:10      else
else141:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif141:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_141(xm)   variant -1.A: step -1 and stop 0, run 11x
idx141 EQU $+1          ;           -1 +loop_141(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_141(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_141(xm)
    or    B             ; 1:4       -1 +loop_141(xm)
    dec  BC             ; 1:6       -1 +loop_141(xm)   index--
    jp   nz, do141save  ; 3:10      -1 +loop_141(xm)
leave141:               ;           -1 +loop_141(xm)
exit141:                ;           xloop LOOP_STACK
    ld   BC, string144  ; 3:10      print_i   Address of string144 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_142(xm)
do142save:              ;           0 10 do_142(xm)
    ld  (idx142),BC     ; 4:20      0 10 do_142(xm)
do142:                  ;           0 10 do_142(xm)
    push DE             ; 1:11      i_142(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_142(m)
    ld   HL, (idx142)   ; 3:16      i_142(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[10:43]      < 0x7FFF   _TMP_STACK_INFO variant: max
    ld    A, 0x7F       ; 2:7        < 0x7FFF
    xor   H             ; 1:4        < 0x7FFF
    inc   L             ; 1:4        < 0x7FFF
    or    L             ; 1:4        < 0x7FFF
    ex   DE, HL         ; 1:4        < 0x7FFF
    pop  DE             ; 1:10       < 0x7FFF
    jp    z, else142    ; 3:10       < 0x7FFF
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif142       ; 3:10      else
else142:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif142:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_142(xm)   variant -1.A: step -1 and stop 0, run 11x
idx142 EQU $+1          ;           -1 +loop_142(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_142(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_142(xm)
    or    B             ; 1:4       -1 +loop_142(xm)
    dec  BC             ; 1:6       -1 +loop_142(xm)   index--
    jp   nz, do142save  ; 3:10      -1 +loop_142(xm)
leave142:               ;           -1 +loop_142(xm)
exit142:                ;           xloop LOOP_STACK
    ld   BC, string144  ; 3:10      print_i   Address of string145 ending with inverted most significant bit == string144
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_143(xm)
do143save:              ;           0 10 do_143(xm)
    ld  (idx143),BC     ; 4:20      0 10 do_143(xm)
do143:                  ;           0 10 do_143(xm)
    push DE             ; 1:11      i_143(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_143(m)
    ld   HL, (idx143)   ; 3:16      i_143(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      < max   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "max" cannot be evaluated
    ld    A, L          ; 1:4        < max   HL<max --> HL-max<0 --> false if not carry
    sub   low max       ; 2:7        < max   HL<max --> HL-max<0 --> false if not carry
    ld    A, H          ; 1:4        < max   HL<max --> HL-max<0 --> false if not carry
    sbc   A, high max   ; 2:7        < max   HL<max --> HL-max<0 --> false if not carry
    rra                 ; 1:4        < max
    xor   H             ; 1:4        < max   invert sign if HL is negative
  if ((max)>=0x8000 || (max)<0)
    jp    m, else143    ; 3:10       < max   negative constant --> false if sign
  else
    jp    p, else143    ; 3:10       < max   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif143       ; 3:10      else
else143:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif143:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_143(xm)   variant -1.A: step -1 and stop 0, run 11x
idx143 EQU $+1          ;           -1 +loop_143(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_143(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_143(xm)
    or    B             ; 1:4       -1 +loop_143(xm)
    dec  BC             ; 1:6       -1 +loop_143(xm)   index--
    jp   nz, do143save  ; 3:10      -1 +loop_143(xm)
leave143:               ;           -1 +loop_143(xm)
exit143:                ;           xloop LOOP_STACK
    ld   BC, string146  ; 3:10      print_i   Address of string146 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_144(xm)
do144save:              ;           0 10 do_144(xm)
    ld  (idx144),BC     ; 4:20      0 10 do_144(xm)
do144:                  ;           0 10 do_144(xm)
    push DE             ; 1:11      i_144(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_144(m)
    ld   HL, (idx144)   ; 3:16      i_144(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      < max   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        < max   HL<max --> L-max<0
    sub  low max        ; 2:7        < max   HL<max --> L-max<0
    ld    A, H          ; 1:4        < max   HL<max --> H-max<0
    sbc   A, high max   ; 2:7        < max   HL<max --> H-max<0 --> false if not carry
    rra                 ; 1:4        < max
    xor   H             ; 1:4        < max   invert sign if HL is negative
    ex   DE, HL         ; 1:4        < max
    pop  DE             ; 1:10       < max
  .warning The condition "max" cannot be evaluated
  if ((max)>=0x8000 || (max)<0)
    jp    m, else144    ; 3:10       < max
  else
    jp    p, else144    ; 3:10       < max
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif144       ; 3:10      else
else144:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif144:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_144(xm)   variant -1.A: step -1 and stop 0, run 11x
idx144 EQU $+1          ;           -1 +loop_144(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_144(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_144(xm)
    or    B             ; 1:4       -1 +loop_144(xm)
    dec  BC             ; 1:6       -1 +loop_144(xm)   index--
    jp   nz, do144save  ; 3:10      -1 +loop_144(xm)
leave144:               ;           -1 +loop_144(xm)
exit144:                ;           xloop LOOP_STACK
    ld   BC, string147  ; 3:10      print_i   Address of string147 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- min ------
    ld   BC, 10         ; 3:10      0 10 do_145(xm)
do145save:              ;           0 10 do_145(xm)
    ld  (idx145),BC     ; 4:20      0 10 do_145(xm)
do145:                  ;           0 10 do_145(xm)
    push DE             ; 1:11      i_145(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_145(m)
    ld   HL, (idx145)   ; 3:16      i_145(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:25]      <=0x8000   _TMP_STACK_INFO variant: <=min
    ld    A, 0x80       ; 2:7        <=0x8000
    xor   H             ; 1:4        <=0x8000
    or    L             ; 1:4        <=0x8000
    jp   nz, else145    ; 3:10       <=0x8000
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif145       ; 3:10      else
else145:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif145:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_145(xm)   variant -1.A: step -1 and stop 0, run 11x
idx145 EQU $+1          ;           -1 +loop_145(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_145(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_145(xm)
    or    B             ; 1:4       -1 +loop_145(xm)
    dec  BC             ; 1:6       -1 +loop_145(xm)   index--
    jp   nz, do145save  ; 3:10      -1 +loop_145(xm)
leave145:               ;           -1 +loop_145(xm)
exit145:                ;           xloop LOOP_STACK
    ld   BC, string148  ; 3:10      print_i   Address of string148 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_146(xm)
do146save:              ;           0 10 do_146(xm)
    ld  (idx146),BC     ; 4:20      0 10 do_146(xm)
do146:                  ;           0 10 do_146(xm)
    push DE             ; 1:11      i_146(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_146(m)
    ld   HL, (idx146)   ; 3:16      i_146(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:39]      <=0x8000   _TMP_STACK_INFO variant: min
    ld    A, 0x80       ; 2:7        <=0x8000
    xor   H             ; 1:4        <=0x8000
    or    L             ; 1:4        <=0x8000
    ex   DE, HL         ; 1:4        <=0x8000
    pop  DE             ; 1:10       <=0x8000
    jp   nz, else146    ; 3:10       <=0x8000
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif146       ; 3:10      else
else146:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif146:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_146(xm)   variant -1.A: step -1 and stop 0, run 11x
idx146 EQU $+1          ;           -1 +loop_146(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_146(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_146(xm)
    or    B             ; 1:4       -1 +loop_146(xm)
    dec  BC             ; 1:6       -1 +loop_146(xm)   index--
    jp   nz, do146save  ; 3:10      -1 +loop_146(xm)
leave146:               ;           -1 +loop_146(xm)
exit146:                ;           xloop LOOP_STACK
    ld   BC, string148  ; 3:10      print_i   Address of string149 ending with inverted most significant bit == string148
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_147(xm)
do147save:              ;           0 10 do_147(xm)
    ld  (idx147),BC     ; 4:20      0 10 do_147(xm)
do147:                  ;           0 10 do_147(xm)
    push DE             ; 1:11      i_147(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_147(m)
    ld   HL, (idx147)   ; 3:16      i_147(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=min   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "min" cannot be evaluated
    ld    A, low min    ; 2:7        <=min   HL<=min --> 0<=min-HL --> false if carry
    sub   L             ; 1:4        <=min   HL<=min --> 0<=min-HL --> false if carry
    ld    A, high min   ; 2:7        <=min   HL<=min --> 0<=min-HL --> false if carry
    sbc   A, H          ; 1:4        <=min   HL<=min --> 0<=min-HL --> false if carry
    rra                 ; 1:4        <=min
    xor   H             ; 1:4        <=min   invert sign if HL is negative
  if ((min)>=0x8000 || (min)<0)
    jp    p, else147    ; 3:10       <=min   negative constant --> false if not sign
  else
    jp    m, else147    ; 3:10       <=min   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif147       ; 3:10      else
else147:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif147:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_147(xm)   variant -1.A: step -1 and stop 0, run 11x
idx147 EQU $+1          ;           -1 +loop_147(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_147(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_147(xm)
    or    B             ; 1:4       -1 +loop_147(xm)
    dec  BC             ; 1:6       -1 +loop_147(xm)   index--
    jp   nz, do147save  ; 3:10      -1 +loop_147(xm)
leave147:               ;           -1 +loop_147(xm)
exit147:                ;           xloop LOOP_STACK
    ld   BC, string150  ; 3:10      print_i   Address of string150 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_148(xm)
do148save:              ;           0 10 do_148(xm)
    ld  (idx148),BC     ; 4:20      0 10 do_148(xm)
do148:                  ;           0 10 do_148(xm)
    push DE             ; 1:11      i_148(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_148(m)
    ld   HL, (idx148)   ; 3:16      i_148(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=min   _TMP_STACK_INFO variant: variable
    ld    A, low min    ; 2:7        <=min   HL<=min --> 0<=min-HL
    sub   L             ; 1:4        <=min   HL<=min --> 0<=min-HL
    ld    A, high min   ; 2:7        <=min   HL<=min --> 0<=min-HL
    sbc   A, H          ; 1:4        <=min   HL<=min --> 0<=min-HL --> false if carry
    rra                 ; 1:4        <=min
    xor   H             ; 1:4        <=min   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=min
    pop  DE             ; 1:10       <=min
  .warning The condition "min" cannot be evaluated
  if ((min)>=0x8000 || (min)<0)
    jp    p, else148    ; 3:10       <=min
  else
    jp    m, else148    ; 3:10       <=min
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif148       ; 3:10      else
else148:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif148:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_148(xm)   variant -1.A: step -1 and stop 0, run 11x
idx148 EQU $+1          ;           -1 +loop_148(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_148(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_148(xm)
    or    B             ; 1:4       -1 +loop_148(xm)
    dec  BC             ; 1:6       -1 +loop_148(xm)   index--
    jp   nz, do148save  ; 3:10      -1 +loop_148(xm)
leave148:               ;           -1 +loop_148(xm)
exit148:                ;           xloop LOOP_STACK
    ld   BC, string151  ; 3:10      print_i   Address of string151 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0xFEFD = 65277 ------
    ld   BC, 10         ; 3:10      0 10 do_149(xm)
do149save:              ;           0 10 do_149(xm)
    ld  (idx149),BC     ; 4:20      0 10 do_149(xm)
do149:                  ;           0 10 do_149(xm)
    push DE             ; 1:11      i_149(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_149(m)
    ld   HL, (idx149)   ; 3:16      i_149(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=+65277   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0xFD       ; 2:7        <=+65277   HL<=65277 --> 0<=0xFD-L --> false if carry
    sub   L             ; 1:4        <=+65277   HL<=65277 --> 0<=0xFD-L --> false if carry
    ld    A, 0xFE       ; 2:7        <=+65277   HL<=65277 --> 0<=0xFE-H --> false if carry
    sbc   A, H          ; 1:4        <=+65277   HL<=65277 --> 0<=0xFE-H --> false if carry
    rra                 ; 1:4        <=+65277
    xor   H             ; 1:4        <=+65277   invert sign if HL is negative
    jp    p, else149    ; 3:10       <=+65277   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif149       ; 3:10      else
else149:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif149:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_149(xm)   variant -1.A: step -1 and stop 0, run 11x
idx149 EQU $+1          ;           -1 +loop_149(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_149(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_149(xm)
    or    B             ; 1:4       -1 +loop_149(xm)
    dec  BC             ; 1:6       -1 +loop_149(xm)   index--
    jp   nz, do149save  ; 3:10      -1 +loop_149(xm)
leave149:               ;           -1 +loop_149(xm)
exit149:                ;           xloop LOOP_STACK
    ld   BC, string152  ; 3:10      print_i   Address of string152 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_150(xm)
do150save:              ;           0 10 do_150(xm)
    ld  (idx150),BC     ; 4:20      0 10 do_150(xm)
do150:                  ;           0 10 do_150(xm)
    push DE             ; 1:11      i_150(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_150(m)
    ld   HL, (idx150)   ; 3:16      i_150(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=+65277   _TMP_STACK_INFO variant: default
    ld    A, 0xFD       ; 2:7        <=+65277   HL<=65277 --> 0<=0xFD-L
    sub   L             ; 1:4        <=+65277   HL<=65277 --> 0<=0xFD-L
    ld    A, 0xFE       ; 2:7        <=+65277   HL<=65277 --> 0<=0xFE-H
    sbc   A, H          ; 1:4        <=+65277   HL<=65277 --> 0<=0xFE-H --> false if carry
    rra                 ; 1:4        <=+65277
    xor   H             ; 1:4        <=+65277   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=+65277
    pop  DE             ; 1:10       <=+65277
    jp    p, else150    ; 3:10       <=+65277   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif150       ; 3:10      else
else150:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif150:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_150(xm)   variant -1.A: step -1 and stop 0, run 11x
idx150 EQU $+1          ;           -1 +loop_150(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_150(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_150(xm)
    or    B             ; 1:4       -1 +loop_150(xm)
    dec  BC             ; 1:6       -1 +loop_150(xm)   index--
    jp   nz, do150save  ; 3:10      -1 +loop_150(xm)
leave150:               ;           -1 +loop_150(xm)
exit150:                ;           xloop LOOP_STACK
    ld   BC, string152  ; 3:10      print_i   Address of string153 ending with inverted most significant bit == string152
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_151(xm)
do151save:              ;           0 10 do_151(xm)
    ld  (idx151),BC     ; 4:20      0 10 do_151(xm)
do151:                  ;           0 10 do_151(xm)
    push DE             ; 1:11      i_151(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_151(m)
    ld   HL, (idx151)   ; 3:16      i_151(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=xFEFD   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "xFEFD" cannot be evaluated
    ld    A, low xFEFD  ; 2:7        <=xFEFD   HL<=xFEFD --> 0<=xFEFD-HL --> false if carry
    sub   L             ; 1:4        <=xFEFD   HL<=xFEFD --> 0<=xFEFD-HL --> false if carry
    ld    A, high xFEFD ; 2:7        <=xFEFD   HL<=xFEFD --> 0<=xFEFD-HL --> false if carry
    sbc   A, H          ; 1:4        <=xFEFD   HL<=xFEFD --> 0<=xFEFD-HL --> false if carry
    rra                 ; 1:4        <=xFEFD
    xor   H             ; 1:4        <=xFEFD   invert sign if HL is negative
  if ((xFEFD)>=0x8000 || (xFEFD)<0)
    jp    p, else151    ; 3:10       <=xFEFD   negative constant --> false if not sign
  else
    jp    m, else151    ; 3:10       <=xFEFD   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif151       ; 3:10      else
else151:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif151:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_151(xm)   variant -1.A: step -1 and stop 0, run 11x
idx151 EQU $+1          ;           -1 +loop_151(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_151(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_151(xm)
    or    B             ; 1:4       -1 +loop_151(xm)
    dec  BC             ; 1:6       -1 +loop_151(xm)   index--
    jp   nz, do151save  ; 3:10      -1 +loop_151(xm)
leave151:               ;           -1 +loop_151(xm)
exit151:                ;           xloop LOOP_STACK
    ld   BC, string154  ; 3:10      print_i   Address of string154 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_152(xm)
do152save:              ;           0 10 do_152(xm)
    ld  (idx152),BC     ; 4:20      0 10 do_152(xm)
do152:                  ;           0 10 do_152(xm)
    push DE             ; 1:11      i_152(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_152(m)
    ld   HL, (idx152)   ; 3:16      i_152(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=xFEFD   _TMP_STACK_INFO variant: variable
    ld    A, low xFEFD  ; 2:7        <=xFEFD   HL<=xFEFD --> 0<=xFEFD-HL
    sub   L             ; 1:4        <=xFEFD   HL<=xFEFD --> 0<=xFEFD-HL
    ld    A, high xFEFD ; 2:7        <=xFEFD   HL<=xFEFD --> 0<=xFEFD-HL
    sbc   A, H          ; 1:4        <=xFEFD   HL<=xFEFD --> 0<=xFEFD-HL --> false if carry
    rra                 ; 1:4        <=xFEFD
    xor   H             ; 1:4        <=xFEFD   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=xFEFD
    pop  DE             ; 1:10       <=xFEFD
  .warning The condition "xFEFD" cannot be evaluated
  if ((xFEFD)>=0x8000 || (xFEFD)<0)
    jp    p, else152    ; 3:10       <=xFEFD
  else
    jp    m, else152    ; 3:10       <=xFEFD
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif152       ; 3:10      else
else152:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif152:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_152(xm)   variant -1.A: step -1 and stop 0, run 11x
idx152 EQU $+1          ;           -1 +loop_152(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_152(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_152(xm)
    or    B             ; 1:4       -1 +loop_152(xm)
    dec  BC             ; 1:6       -1 +loop_152(xm)   index--
    jp   nz, do152save  ; 3:10      -1 +loop_152(xm)
leave152:               ;           -1 +loop_152(xm)
exit152:                ;           xloop LOOP_STACK
    ld   BC, string155  ; 3:10      print_i   Address of string155 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0xFEFE = 65278 ------
    ld   BC, 10         ; 3:10      0 10 do_153(xm)
do153save:              ;           0 10 do_153(xm)
    ld  (idx153),BC     ; 4:20      0 10 do_153(xm)
do153:                  ;           0 10 do_153(xm)
    push DE             ; 1:11      i_153(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_153(m)
    ld   HL, (idx153)   ; 3:16      i_153(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:33]      <=+65278   _TMP_STACK_INFO #variant: hi == lo, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0xFE       ; 2:7        <=+65278   HL<=65278 --> 0<=0xFE-L --> false if carry
    cp    L             ; 1:4        <=+65278   HL<=65278 --> 0<=0xFE-L --> false if carry
    sbc   A, H          ; 1:4        <=+65278   HL<=65278 --> 0<=0xFE-H --> false if carry
    rra                 ; 1:4        <=+65278
    xor   H             ; 1:4        <=+65278   invert sign if HL is negative
    jp    p, else153    ; 3:10       <=+65278   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif153       ; 3:10      else
else153:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif153:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_153(xm)   variant -1.A: step -1 and stop 0, run 11x
idx153 EQU $+1          ;           -1 +loop_153(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_153(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_153(xm)
    or    B             ; 1:4       -1 +loop_153(xm)
    dec  BC             ; 1:6       -1 +loop_153(xm)   index--
    jp   nz, do153save  ; 3:10      -1 +loop_153(xm)
leave153:               ;           -1 +loop_153(xm)
exit153:                ;           xloop LOOP_STACK
    ld   BC, string156  ; 3:10      print_i   Address of string156 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_154(xm)
do154save:              ;           0 10 do_154(xm)
    ld  (idx154),BC     ; 4:20      0 10 do_154(xm)
do154:                  ;           0 10 do_154(xm)
    push DE             ; 1:11      i_154(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_154(m)
    ld   HL, (idx154)   ; 3:16      i_154(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:47]      <=+65278   _TMP_STACK_INFO variant: hi == lo
    ld    A, 0xFE       ; 2:7        <=+65278   HL<=65278 --> 0<=0xFE-L
    cp    L             ; 1:4        <=+65278   HL<=65278 --> 0<=0xFE-L
    sbc   A, H          ; 1:4        <=+65278   HL<=65278 --> 0<=0xFE-H --> false if carry
    rra                 ; 1:4        <=+65278
    xor   H             ; 1:4        <=+65278   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=+65278
    pop  DE             ; 1:10       <=+65278
    jp    p, else154    ; 3:10       <=+65278   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif154       ; 3:10      else
else154:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif154:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_154(xm)   variant -1.A: step -1 and stop 0, run 11x
idx154 EQU $+1          ;           -1 +loop_154(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_154(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_154(xm)
    or    B             ; 1:4       -1 +loop_154(xm)
    dec  BC             ; 1:6       -1 +loop_154(xm)   index--
    jp   nz, do154save  ; 3:10      -1 +loop_154(xm)
leave154:               ;           -1 +loop_154(xm)
exit154:                ;           xloop LOOP_STACK
    ld   BC, string156  ; 3:10      print_i   Address of string157 ending with inverted most significant bit == string156
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_155(xm)
do155save:              ;           0 10 do_155(xm)
    ld  (idx155),BC     ; 4:20      0 10 do_155(xm)
do155:                  ;           0 10 do_155(xm)
    push DE             ; 1:11      i_155(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_155(m)
    ld   HL, (idx155)   ; 3:16      i_155(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=xFEFE   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "xFEFE" cannot be evaluated
    ld    A, low xFEFE  ; 2:7        <=xFEFE   HL<=xFEFE --> 0<=xFEFE-HL --> false if carry
    sub   L             ; 1:4        <=xFEFE   HL<=xFEFE --> 0<=xFEFE-HL --> false if carry
    ld    A, high xFEFE ; 2:7        <=xFEFE   HL<=xFEFE --> 0<=xFEFE-HL --> false if carry
    sbc   A, H          ; 1:4        <=xFEFE   HL<=xFEFE --> 0<=xFEFE-HL --> false if carry
    rra                 ; 1:4        <=xFEFE
    xor   H             ; 1:4        <=xFEFE   invert sign if HL is negative
  if ((xFEFE)>=0x8000 || (xFEFE)<0)
    jp    p, else155    ; 3:10       <=xFEFE   negative constant --> false if not sign
  else
    jp    m, else155    ; 3:10       <=xFEFE   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif155       ; 3:10      else
else155:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif155:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_155(xm)   variant -1.A: step -1 and stop 0, run 11x
idx155 EQU $+1          ;           -1 +loop_155(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_155(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_155(xm)
    or    B             ; 1:4       -1 +loop_155(xm)
    dec  BC             ; 1:6       -1 +loop_155(xm)   index--
    jp   nz, do155save  ; 3:10      -1 +loop_155(xm)
leave155:               ;           -1 +loop_155(xm)
exit155:                ;           xloop LOOP_STACK
    ld   BC, string158  ; 3:10      print_i   Address of string158 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_156(xm)
do156save:              ;           0 10 do_156(xm)
    ld  (idx156),BC     ; 4:20      0 10 do_156(xm)
do156:                  ;           0 10 do_156(xm)
    push DE             ; 1:11      i_156(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_156(m)
    ld   HL, (idx156)   ; 3:16      i_156(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=xFEFE   _TMP_STACK_INFO variant: variable
    ld    A, low xFEFE  ; 2:7        <=xFEFE   HL<=xFEFE --> 0<=xFEFE-HL
    sub   L             ; 1:4        <=xFEFE   HL<=xFEFE --> 0<=xFEFE-HL
    ld    A, high xFEFE ; 2:7        <=xFEFE   HL<=xFEFE --> 0<=xFEFE-HL
    sbc   A, H          ; 1:4        <=xFEFE   HL<=xFEFE --> 0<=xFEFE-HL --> false if carry
    rra                 ; 1:4        <=xFEFE
    xor   H             ; 1:4        <=xFEFE   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=xFEFE
    pop  DE             ; 1:10       <=xFEFE
  .warning The condition "xFEFE" cannot be evaluated
  if ((xFEFE)>=0x8000 || (xFEFE)<0)
    jp    p, else156    ; 3:10       <=xFEFE
  else
    jp    m, else156    ; 3:10       <=xFEFE
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif156       ; 3:10      else
else156:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif156:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_156(xm)   variant -1.A: step -1 and stop 0, run 11x
idx156 EQU $+1          ;           -1 +loop_156(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_156(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_156(xm)
    or    B             ; 1:4       -1 +loop_156(xm)
    dec  BC             ; 1:6       -1 +loop_156(xm)   index--
    jp   nz, do156save  ; 3:10      -1 +loop_156(xm)
leave156:               ;           -1 +loop_156(xm)
exit156:                ;           xloop LOOP_STACK
    ld   BC, string159  ; 3:10      print_i   Address of string159 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0xFEFF = 65279 ------
    ld   BC, 10         ; 3:10      0 10 do_157(xm)
do157save:              ;           0 10 do_157(xm)
    ld  (idx157),BC     ; 4:20      0 10 do_157(xm)
do157:                  ;           0 10 do_157(xm)
    push DE             ; 1:11      i_157(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_157(m)
    ld   HL, (idx157)   ; 3:16      i_157(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=+65279   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0xFF       ; 2:7        <=+65279   HL<=65279 --> 0<=0xFF-L --> false if carry
    sub   L             ; 1:4        <=+65279   HL<=65279 --> 0<=0xFF-L --> false if carry
    ld    A, 0xFE       ; 2:7        <=+65279   HL<=65279 --> 0<=0xFE-H --> false if carry
    sbc   A, H          ; 1:4        <=+65279   HL<=65279 --> 0<=0xFE-H --> false if carry
    rra                 ; 1:4        <=+65279
    xor   H             ; 1:4        <=+65279   invert sign if HL is negative
    jp    p, else157    ; 3:10       <=+65279   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif157       ; 3:10      else
else157:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif157:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_157(xm)   variant -1.A: step -1 and stop 0, run 11x
idx157 EQU $+1          ;           -1 +loop_157(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_157(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_157(xm)
    or    B             ; 1:4       -1 +loop_157(xm)
    dec  BC             ; 1:6       -1 +loop_157(xm)   index--
    jp   nz, do157save  ; 3:10      -1 +loop_157(xm)
leave157:               ;           -1 +loop_157(xm)
exit157:                ;           xloop LOOP_STACK
    ld   BC, string160  ; 3:10      print_i   Address of string160 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_158(xm)
do158save:              ;           0 10 do_158(xm)
    ld  (idx158),BC     ; 4:20      0 10 do_158(xm)
do158:                  ;           0 10 do_158(xm)
    push DE             ; 1:11      i_158(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_158(m)
    ld   HL, (idx158)   ; 3:16      i_158(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=+65279   _TMP_STACK_INFO variant: default
    ld    A, 0xFF       ; 2:7        <=+65279   HL<=65279 --> 0<=0xFF-L
    sub   L             ; 1:4        <=+65279   HL<=65279 --> 0<=0xFF-L
    ld    A, 0xFE       ; 2:7        <=+65279   HL<=65279 --> 0<=0xFE-H
    sbc   A, H          ; 1:4        <=+65279   HL<=65279 --> 0<=0xFE-H --> false if carry
    rra                 ; 1:4        <=+65279
    xor   H             ; 1:4        <=+65279   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=+65279
    pop  DE             ; 1:10       <=+65279
    jp    p, else158    ; 3:10       <=+65279   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif158       ; 3:10      else
else158:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif158:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_158(xm)   variant -1.A: step -1 and stop 0, run 11x
idx158 EQU $+1          ;           -1 +loop_158(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_158(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_158(xm)
    or    B             ; 1:4       -1 +loop_158(xm)
    dec  BC             ; 1:6       -1 +loop_158(xm)   index--
    jp   nz, do158save  ; 3:10      -1 +loop_158(xm)
leave158:               ;           -1 +loop_158(xm)
exit158:                ;           xloop LOOP_STACK
    ld   BC, string160  ; 3:10      print_i   Address of string161 ending with inverted most significant bit == string160
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_159(xm)
do159save:              ;           0 10 do_159(xm)
    ld  (idx159),BC     ; 4:20      0 10 do_159(xm)
do159:                  ;           0 10 do_159(xm)
    push DE             ; 1:11      i_159(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_159(m)
    ld   HL, (idx159)   ; 3:16      i_159(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=xFEFF   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "xFEFF" cannot be evaluated
    ld    A, low xFEFF  ; 2:7        <=xFEFF   HL<=xFEFF --> 0<=xFEFF-HL --> false if carry
    sub   L             ; 1:4        <=xFEFF   HL<=xFEFF --> 0<=xFEFF-HL --> false if carry
    ld    A, high xFEFF ; 2:7        <=xFEFF   HL<=xFEFF --> 0<=xFEFF-HL --> false if carry
    sbc   A, H          ; 1:4        <=xFEFF   HL<=xFEFF --> 0<=xFEFF-HL --> false if carry
    rra                 ; 1:4        <=xFEFF
    xor   H             ; 1:4        <=xFEFF   invert sign if HL is negative
  if ((xFEFF)>=0x8000 || (xFEFF)<0)
    jp    p, else159    ; 3:10       <=xFEFF   negative constant --> false if not sign
  else
    jp    m, else159    ; 3:10       <=xFEFF   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif159       ; 3:10      else
else159:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif159:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_159(xm)   variant -1.A: step -1 and stop 0, run 11x
idx159 EQU $+1          ;           -1 +loop_159(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_159(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_159(xm)
    or    B             ; 1:4       -1 +loop_159(xm)
    dec  BC             ; 1:6       -1 +loop_159(xm)   index--
    jp   nz, do159save  ; 3:10      -1 +loop_159(xm)
leave159:               ;           -1 +loop_159(xm)
exit159:                ;           xloop LOOP_STACK
    ld   BC, string162  ; 3:10      print_i   Address of string162 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_160(xm)
do160save:              ;           0 10 do_160(xm)
    ld  (idx160),BC     ; 4:20      0 10 do_160(xm)
do160:                  ;           0 10 do_160(xm)
    push DE             ; 1:11      i_160(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_160(m)
    ld   HL, (idx160)   ; 3:16      i_160(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=xFEFF   _TMP_STACK_INFO variant: variable
    ld    A, low xFEFF  ; 2:7        <=xFEFF   HL<=xFEFF --> 0<=xFEFF-HL
    sub   L             ; 1:4        <=xFEFF   HL<=xFEFF --> 0<=xFEFF-HL
    ld    A, high xFEFF ; 2:7        <=xFEFF   HL<=xFEFF --> 0<=xFEFF-HL
    sbc   A, H          ; 1:4        <=xFEFF   HL<=xFEFF --> 0<=xFEFF-HL --> false if carry
    rra                 ; 1:4        <=xFEFF
    xor   H             ; 1:4        <=xFEFF   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=xFEFF
    pop  DE             ; 1:10       <=xFEFF
  .warning The condition "xFEFF" cannot be evaluated
  if ((xFEFF)>=0x8000 || (xFEFF)<0)
    jp    p, else160    ; 3:10       <=xFEFF
  else
    jp    m, else160    ; 3:10       <=xFEFF
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif160       ; 3:10      else
else160:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif160:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_160(xm)   variant -1.A: step -1 and stop 0, run 11x
idx160 EQU $+1          ;           -1 +loop_160(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_160(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_160(xm)
    or    B             ; 1:4       -1 +loop_160(xm)
    dec  BC             ; 1:6       -1 +loop_160(xm)   index--
    jp   nz, do160save  ; 3:10      -1 +loop_160(xm)
leave160:               ;           -1 +loop_160(xm)
exit160:                ;           xloop LOOP_STACK
    ld   BC, string163  ; 3:10      print_i   Address of string163 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- -1 ------
    ld   BC, 10         ; 3:10      0 10 do_161(xm)
do161save:              ;           0 10 do_161(xm)
    ld  (idx161),BC     ; 4:20      0 10 do_161(xm)
do161:                  ;           0 10 do_161(xm)
    push DE             ; 1:11      i_161(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_161(m)
    ld   HL, (idx161)   ; 3:16      i_161(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[5:18]      <=-1   _TMP_STACK_INFO variant: <=-1
    bit   7, H          ; 2:8        <=-1
    jp    z, else161    ; 3:10       <=-1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif161       ; 3:10      else
else161:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif161:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_161(xm)   variant -1.A: step -1 and stop 0, run 11x
idx161 EQU $+1          ;           -1 +loop_161(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_161(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_161(xm)
    or    B             ; 1:4       -1 +loop_161(xm)
    dec  BC             ; 1:6       -1 +loop_161(xm)   index--
    jp   nz, do161save  ; 3:10      -1 +loop_161(xm)
leave161:               ;           -1 +loop_161(xm)
exit161:                ;           xloop LOOP_STACK
    ld   BC, string164  ; 3:10      print_i   Address of string164 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_162(xm)
do162save:              ;           0 10 do_162(xm)
    ld  (idx162),BC     ; 4:20      0 10 do_162(xm)
do162:                  ;           0 10 do_162(xm)
    push DE             ; 1:11      i_162(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_162(m)
    ld   HL, (idx162)   ; 3:16      i_162(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:32]      <=-1   _TMP_STACK_INFO variant: -1
    rl    H             ; 2:8        <=-1   HL<=-1 --> no sign if false
    ex   DE, HL         ; 1:4        <=-1
    pop  DE             ; 1:10       <=-1
    jp   nc, else162    ; 3:10       <=-1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif162       ; 3:10      else
else162:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif162:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_162(xm)   variant -1.A: step -1 and stop 0, run 11x
idx162 EQU $+1          ;           -1 +loop_162(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_162(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_162(xm)
    or    B             ; 1:4       -1 +loop_162(xm)
    dec  BC             ; 1:6       -1 +loop_162(xm)   index--
    jp   nz, do162save  ; 3:10      -1 +loop_162(xm)
leave162:               ;           -1 +loop_162(xm)
exit162:                ;           xloop LOOP_STACK
    ld   BC, string164  ; 3:10      print_i   Address of string165 ending with inverted most significant bit == string164
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_163(xm)
do163save:              ;           0 10 do_163(xm)
    ld  (idx163),BC     ; 4:20      0 10 do_163(xm)
do163:                  ;           0 10 do_163(xm)
    push DE             ; 1:11      i_163(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_163(m)
    ld   HL, (idx163)   ; 3:16      i_163(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=m1   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "m1" cannot be evaluated
    ld    A, low m1     ; 2:7        <=m1   HL<=m1 --> 0<=m1-HL --> false if carry
    sub   L             ; 1:4        <=m1   HL<=m1 --> 0<=m1-HL --> false if carry
    ld    A, high m1    ; 2:7        <=m1   HL<=m1 --> 0<=m1-HL --> false if carry
    sbc   A, H          ; 1:4        <=m1   HL<=m1 --> 0<=m1-HL --> false if carry
    rra                 ; 1:4        <=m1
    xor   H             ; 1:4        <=m1   invert sign if HL is negative
  if ((m1)>=0x8000 || (m1)<0)
    jp    p, else163    ; 3:10       <=m1   negative constant --> false if not sign
  else
    jp    m, else163    ; 3:10       <=m1   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif163       ; 3:10      else
else163:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif163:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_163(xm)   variant -1.A: step -1 and stop 0, run 11x
idx163 EQU $+1          ;           -1 +loop_163(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_163(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_163(xm)
    or    B             ; 1:4       -1 +loop_163(xm)
    dec  BC             ; 1:6       -1 +loop_163(xm)   index--
    jp   nz, do163save  ; 3:10      -1 +loop_163(xm)
leave163:               ;           -1 +loop_163(xm)
exit163:                ;           xloop LOOP_STACK
    ld   BC, string166  ; 3:10      print_i   Address of string166 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_164(xm)
do164save:              ;           0 10 do_164(xm)
    ld  (idx164),BC     ; 4:20      0 10 do_164(xm)
do164:                  ;           0 10 do_164(xm)
    push DE             ; 1:11      i_164(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_164(m)
    ld   HL, (idx164)   ; 3:16      i_164(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=m1   _TMP_STACK_INFO variant: variable
    ld    A, low m1     ; 2:7        <=m1   HL<=m1 --> 0<=m1-HL
    sub   L             ; 1:4        <=m1   HL<=m1 --> 0<=m1-HL
    ld    A, high m1    ; 2:7        <=m1   HL<=m1 --> 0<=m1-HL
    sbc   A, H          ; 1:4        <=m1   HL<=m1 --> 0<=m1-HL --> false if carry
    rra                 ; 1:4        <=m1
    xor   H             ; 1:4        <=m1   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=m1
    pop  DE             ; 1:10       <=m1
  .warning The condition "m1" cannot be evaluated
  if ((m1)>=0x8000 || (m1)<0)
    jp    p, else164    ; 3:10       <=m1
  else
    jp    m, else164    ; 3:10       <=m1
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif164       ; 3:10      else
else164:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif164:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_164(xm)   variant -1.A: step -1 and stop 0, run 11x
idx164 EQU $+1          ;           -1 +loop_164(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_164(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_164(xm)
    or    B             ; 1:4       -1 +loop_164(xm)
    dec  BC             ; 1:6       -1 +loop_164(xm)   index--
    jp   nz, do164save  ; 3:10      -1 +loop_164(xm)
leave164:               ;           -1 +loop_164(xm)
exit164:                ;           xloop LOOP_STACK
    ld   BC, string167  ; 3:10      print_i   Address of string167 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0 ------
    ld   BC, 10         ; 3:10      0 10 do_165(xm)
do165save:              ;           0 10 do_165(xm)
    ld  (idx165),BC     ; 4:20      0 10 do_165(xm)
do165:                  ;           0 10 do_165(xm)
    push DE             ; 1:11      i_165(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_165(m)
    ld   HL, (idx165)   ; 3:16      i_165(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:30]      <=0   _TMP_STACK_INFO variant: <=0
    ld    A, H          ; 1:4        <=0   save sign
    dec  HL             ; 1:6        <=0   zero to negative
    or    H             ; 1:4        <=0
    inc  HL             ; 1:6        <=0
    jp    p, else165    ; 3:10       <=0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif165       ; 3:10      else
else165:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif165:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_165(xm)   variant -1.A: step -1 and stop 0, run 11x
idx165 EQU $+1          ;           -1 +loop_165(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_165(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_165(xm)
    or    B             ; 1:4       -1 +loop_165(xm)
    dec  BC             ; 1:6       -1 +loop_165(xm)   index--
    jp   nz, do165save  ; 3:10      -1 +loop_165(xm)
leave165:               ;           -1 +loop_165(xm)
exit165:                ;           xloop LOOP_STACK
    ld   BC, string168  ; 3:10      print_i   Address of string168 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_166(xm)
do166save:              ;           0 10 do_166(xm)
    ld  (idx166),BC     ; 4:20      0 10 do_166(xm)
do166:                  ;           0 10 do_166(xm)
    push DE             ; 1:11      i_166(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_166(m)
    ld   HL, (idx166)   ; 3:16      i_166(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[8:38]      <=0   _TMP_STACK_INFO variant: 0
    ld    A, H          ; 1:4        <=0   HL< 0         --> no sign if false
    dec  HL             ; 1:6        <=0   HL<=0         --> no sign if false
    or    H             ; 1:4        <=0   HL<=0 && HL<0 --> no sign if false
    ex   DE, HL         ; 1:4        <=0
    pop  DE             ; 1:10       <=0
    jp    p, else166    ; 3:10       <=0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif166       ; 3:10      else
else166:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif166:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_166(xm)   variant -1.A: step -1 and stop 0, run 11x
idx166 EQU $+1          ;           -1 +loop_166(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_166(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_166(xm)
    or    B             ; 1:4       -1 +loop_166(xm)
    dec  BC             ; 1:6       -1 +loop_166(xm)   index--
    jp   nz, do166save  ; 3:10      -1 +loop_166(xm)
leave166:               ;           -1 +loop_166(xm)
exit166:                ;           xloop LOOP_STACK
    ld   BC, string168  ; 3:10      print_i   Address of string169 ending with inverted most significant bit == string168
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_167(xm)
do167save:              ;           0 10 do_167(xm)
    ld  (idx167),BC     ; 4:20      0 10 do_167(xm)
do167:                  ;           0 10 do_167(xm)
    push DE             ; 1:11      i_167(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_167(m)
    ld   HL, (idx167)   ; 3:16      i_167(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=zero   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "zero" cannot be evaluated
    ld    A, low zero   ; 2:7        <=zero   HL<=zero --> 0<=zero-HL --> false if carry
    sub   L             ; 1:4        <=zero   HL<=zero --> 0<=zero-HL --> false if carry
    ld    A, high zero  ; 2:7        <=zero   HL<=zero --> 0<=zero-HL --> false if carry
    sbc   A, H          ; 1:4        <=zero   HL<=zero --> 0<=zero-HL --> false if carry
    rra                 ; 1:4        <=zero
    xor   H             ; 1:4        <=zero   invert sign if HL is negative
  if ((zero)>=0x8000 || (zero)<0)
    jp    p, else167    ; 3:10       <=zero   negative constant --> false if not sign
  else
    jp    m, else167    ; 3:10       <=zero   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif167       ; 3:10      else
else167:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif167:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_167(xm)   variant -1.A: step -1 and stop 0, run 11x
idx167 EQU $+1          ;           -1 +loop_167(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_167(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_167(xm)
    or    B             ; 1:4       -1 +loop_167(xm)
    dec  BC             ; 1:6       -1 +loop_167(xm)   index--
    jp   nz, do167save  ; 3:10      -1 +loop_167(xm)
leave167:               ;           -1 +loop_167(xm)
exit167:                ;           xloop LOOP_STACK
    ld   BC, string170  ; 3:10      print_i   Address of string170 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_168(xm)
do168save:              ;           0 10 do_168(xm)
    ld  (idx168),BC     ; 4:20      0 10 do_168(xm)
do168:                  ;           0 10 do_168(xm)
    push DE             ; 1:11      i_168(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_168(m)
    ld   HL, (idx168)   ; 3:16      i_168(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=zero   _TMP_STACK_INFO variant: variable
    ld    A, low zero   ; 2:7        <=zero   HL<=zero --> 0<=zero-HL
    sub   L             ; 1:4        <=zero   HL<=zero --> 0<=zero-HL
    ld    A, high zero  ; 2:7        <=zero   HL<=zero --> 0<=zero-HL
    sbc   A, H          ; 1:4        <=zero   HL<=zero --> 0<=zero-HL --> false if carry
    rra                 ; 1:4        <=zero
    xor   H             ; 1:4        <=zero   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=zero
    pop  DE             ; 1:10       <=zero
  .warning The condition "zero" cannot be evaluated
  if ((zero)>=0x8000 || (zero)<0)
    jp    p, else168    ; 3:10       <=zero
  else
    jp    m, else168    ; 3:10       <=zero
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif168       ; 3:10      else
else168:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif168:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_168(xm)   variant -1.A: step -1 and stop 0, run 11x
idx168 EQU $+1          ;           -1 +loop_168(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_168(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_168(xm)
    or    B             ; 1:4       -1 +loop_168(xm)
    dec  BC             ; 1:6       -1 +loop_168(xm)   index--
    jp   nz, do168save  ; 3:10      -1 +loop_168(xm)
leave168:               ;           -1 +loop_168(xm)
exit168:                ;           xloop LOOP_STACK
    ld   BC, string171  ; 3:10      print_i   Address of string171 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 1 ------
    ld   BC, 10         ; 3:10      0 10 do_169(xm)
do169save:              ;           0 10 do_169(xm)
    ld  (idx169),BC     ; 4:20      0 10 do_169(xm)
do169:                  ;           0 10 do_169(xm)
    push DE             ; 1:11      i_169(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_169(m)
    ld   HL, (idx169)   ; 3:16      i_169(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=+1   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0x01       ; 2:7        <=+1   HL<=1 --> 0<=0x01-L --> false if carry
    sub   L             ; 1:4        <=+1   HL<=1 --> 0<=0x01-L --> false if carry
    ld    A, 0x00       ; 2:7        <=+1   HL<=1 --> 0<=0x00-H --> false if carry
    sbc   A, H          ; 1:4        <=+1   HL<=1 --> 0<=0x00-H --> false if carry
    rra                 ; 1:4        <=+1
    xor   H             ; 1:4        <=+1   invert sign if HL is negative
    jp    m, else169    ; 3:10       <=+1   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif169       ; 3:10      else
else169:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif169:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_169(xm)   variant -1.A: step -1 and stop 0, run 11x
idx169 EQU $+1          ;           -1 +loop_169(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_169(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_169(xm)
    or    B             ; 1:4       -1 +loop_169(xm)
    dec  BC             ; 1:6       -1 +loop_169(xm)   index--
    jp   nz, do169save  ; 3:10      -1 +loop_169(xm)
leave169:               ;           -1 +loop_169(xm)
exit169:                ;           xloop LOOP_STACK
    ld   BC, string172  ; 3:10      print_i   Address of string172 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_170(xm)
do170save:              ;           0 10 do_170(xm)
    ld  (idx170),BC     ; 4:20      0 10 do_170(xm)
do170:                  ;           0 10 do_170(xm)
    push DE             ; 1:11      i_170(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_170(m)
    ld   HL, (idx170)   ; 3:16      i_170(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=+1   _TMP_STACK_INFO variant: default
    ld    A, 0x01       ; 2:7        <=+1   HL<=1 --> 0<=0x01-L
    sub   L             ; 1:4        <=+1   HL<=1 --> 0<=0x01-L
    ld    A, 0x00       ; 2:7        <=+1   HL<=1 --> 0<=0x00-H
    sbc   A, H          ; 1:4        <=+1   HL<=1 --> 0<=0x00-H --> false if carry
    rra                 ; 1:4        <=+1
    xor   H             ; 1:4        <=+1   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=+1
    pop  DE             ; 1:10       <=+1
    jp    m, else170    ; 3:10       <=+1   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif170       ; 3:10      else
else170:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif170:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_170(xm)   variant -1.A: step -1 and stop 0, run 11x
idx170 EQU $+1          ;           -1 +loop_170(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_170(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_170(xm)
    or    B             ; 1:4       -1 +loop_170(xm)
    dec  BC             ; 1:6       -1 +loop_170(xm)   index--
    jp   nz, do170save  ; 3:10      -1 +loop_170(xm)
leave170:               ;           -1 +loop_170(xm)
exit170:                ;           xloop LOOP_STACK
    ld   BC, string172  ; 3:10      print_i   Address of string173 ending with inverted most significant bit == string172
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_171(xm)
do171save:              ;           0 10 do_171(xm)
    ld  (idx171),BC     ; 4:20      0 10 do_171(xm)
do171:                  ;           0 10 do_171(xm)
    push DE             ; 1:11      i_171(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_171(m)
    ld   HL, (idx171)   ; 3:16      i_171(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=p1   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "p1" cannot be evaluated
    ld    A, low p1     ; 2:7        <=p1   HL<=p1 --> 0<=p1-HL --> false if carry
    sub   L             ; 1:4        <=p1   HL<=p1 --> 0<=p1-HL --> false if carry
    ld    A, high p1    ; 2:7        <=p1   HL<=p1 --> 0<=p1-HL --> false if carry
    sbc   A, H          ; 1:4        <=p1   HL<=p1 --> 0<=p1-HL --> false if carry
    rra                 ; 1:4        <=p1
    xor   H             ; 1:4        <=p1   invert sign if HL is negative
  if ((p1)>=0x8000 || (p1)<0)
    jp    p, else171    ; 3:10       <=p1   negative constant --> false if not sign
  else
    jp    m, else171    ; 3:10       <=p1   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif171       ; 3:10      else
else171:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif171:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_171(xm)   variant -1.A: step -1 and stop 0, run 11x
idx171 EQU $+1          ;           -1 +loop_171(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_171(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_171(xm)
    or    B             ; 1:4       -1 +loop_171(xm)
    dec  BC             ; 1:6       -1 +loop_171(xm)   index--
    jp   nz, do171save  ; 3:10      -1 +loop_171(xm)
leave171:               ;           -1 +loop_171(xm)
exit171:                ;           xloop LOOP_STACK
    ld   BC, string174  ; 3:10      print_i   Address of string174 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_172(xm)
do172save:              ;           0 10 do_172(xm)
    ld  (idx172),BC     ; 4:20      0 10 do_172(xm)
do172:                  ;           0 10 do_172(xm)
    push DE             ; 1:11      i_172(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_172(m)
    ld   HL, (idx172)   ; 3:16      i_172(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=p1   _TMP_STACK_INFO variant: variable
    ld    A, low p1     ; 2:7        <=p1   HL<=p1 --> 0<=p1-HL
    sub   L             ; 1:4        <=p1   HL<=p1 --> 0<=p1-HL
    ld    A, high p1    ; 2:7        <=p1   HL<=p1 --> 0<=p1-HL
    sbc   A, H          ; 1:4        <=p1   HL<=p1 --> 0<=p1-HL --> false if carry
    rra                 ; 1:4        <=p1
    xor   H             ; 1:4        <=p1   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=p1
    pop  DE             ; 1:10       <=p1
  .warning The condition "p1" cannot be evaluated
  if ((p1)>=0x8000 || (p1)<0)
    jp    p, else172    ; 3:10       <=p1
  else
    jp    m, else172    ; 3:10       <=p1
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif172       ; 3:10      else
else172:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif172:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_172(xm)   variant -1.A: step -1 and stop 0, run 11x
idx172 EQU $+1          ;           -1 +loop_172(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_172(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_172(xm)
    or    B             ; 1:4       -1 +loop_172(xm)
    dec  BC             ; 1:6       -1 +loop_172(xm)   index--
    jp   nz, do172save  ; 3:10      -1 +loop_172(xm)
leave172:               ;           -1 +loop_172(xm)
exit172:                ;           xloop LOOP_STACK
    ld   BC, string175  ; 3:10      print_i   Address of string175 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3332 = 13106 ------
    ld   BC, 10         ; 3:10      0 10 do_173(xm)
do173save:              ;           0 10 do_173(xm)
    ld  (idx173),BC     ; 4:20      0 10 do_173(xm)
do173:                  ;           0 10 do_173(xm)
    push DE             ; 1:11      i_173(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_173(m)
    ld   HL, (idx173)   ; 3:16      i_173(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=+13106   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0x32       ; 2:7        <=+13106   HL<=13106 --> 0<=0x32-L --> false if carry
    sub   L             ; 1:4        <=+13106   HL<=13106 --> 0<=0x32-L --> false if carry
    ld    A, 0x33       ; 2:7        <=+13106   HL<=13106 --> 0<=0x33-H --> false if carry
    sbc   A, H          ; 1:4        <=+13106   HL<=13106 --> 0<=0x33-H --> false if carry
    rra                 ; 1:4        <=+13106
    xor   H             ; 1:4        <=+13106   invert sign if HL is negative
    jp    m, else173    ; 3:10       <=+13106   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif173       ; 3:10      else
else173:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif173:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_173(xm)   variant -1.A: step -1 and stop 0, run 11x
idx173 EQU $+1          ;           -1 +loop_173(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_173(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_173(xm)
    or    B             ; 1:4       -1 +loop_173(xm)
    dec  BC             ; 1:6       -1 +loop_173(xm)   index--
    jp   nz, do173save  ; 3:10      -1 +loop_173(xm)
leave173:               ;           -1 +loop_173(xm)
exit173:                ;           xloop LOOP_STACK
    ld   BC, string176  ; 3:10      print_i   Address of string176 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_174(xm)
do174save:              ;           0 10 do_174(xm)
    ld  (idx174),BC     ; 4:20      0 10 do_174(xm)
do174:                  ;           0 10 do_174(xm)
    push DE             ; 1:11      i_174(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_174(m)
    ld   HL, (idx174)   ; 3:16      i_174(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=+13106   _TMP_STACK_INFO variant: default
    ld    A, 0x32       ; 2:7        <=+13106   HL<=13106 --> 0<=0x32-L
    sub   L             ; 1:4        <=+13106   HL<=13106 --> 0<=0x32-L
    ld    A, 0x33       ; 2:7        <=+13106   HL<=13106 --> 0<=0x33-H
    sbc   A, H          ; 1:4        <=+13106   HL<=13106 --> 0<=0x33-H --> false if carry
    rra                 ; 1:4        <=+13106
    xor   H             ; 1:4        <=+13106   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=+13106
    pop  DE             ; 1:10       <=+13106
    jp    m, else174    ; 3:10       <=+13106   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif174       ; 3:10      else
else174:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif174:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_174(xm)   variant -1.A: step -1 and stop 0, run 11x
idx174 EQU $+1          ;           -1 +loop_174(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_174(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_174(xm)
    or    B             ; 1:4       -1 +loop_174(xm)
    dec  BC             ; 1:6       -1 +loop_174(xm)   index--
    jp   nz, do174save  ; 3:10      -1 +loop_174(xm)
leave174:               ;           -1 +loop_174(xm)
exit174:                ;           xloop LOOP_STACK
    ld   BC, string176  ; 3:10      print_i   Address of string177 ending with inverted most significant bit == string176
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_175(xm)
do175save:              ;           0 10 do_175(xm)
    ld  (idx175),BC     ; 4:20      0 10 do_175(xm)
do175:                  ;           0 10 do_175(xm)
    push DE             ; 1:11      i_175(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_175(m)
    ld   HL, (idx175)   ; 3:16      i_175(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=x3332   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "x3332" cannot be evaluated
    ld    A, low x3332  ; 2:7        <=x3332   HL<=x3332 --> 0<=x3332-HL --> false if carry
    sub   L             ; 1:4        <=x3332   HL<=x3332 --> 0<=x3332-HL --> false if carry
    ld    A, high x3332 ; 2:7        <=x3332   HL<=x3332 --> 0<=x3332-HL --> false if carry
    sbc   A, H          ; 1:4        <=x3332   HL<=x3332 --> 0<=x3332-HL --> false if carry
    rra                 ; 1:4        <=x3332
    xor   H             ; 1:4        <=x3332   invert sign if HL is negative
  if ((x3332)>=0x8000 || (x3332)<0)
    jp    p, else175    ; 3:10       <=x3332   negative constant --> false if not sign
  else
    jp    m, else175    ; 3:10       <=x3332   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif175       ; 3:10      else
else175:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif175:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_175(xm)   variant -1.A: step -1 and stop 0, run 11x
idx175 EQU $+1          ;           -1 +loop_175(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_175(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_175(xm)
    or    B             ; 1:4       -1 +loop_175(xm)
    dec  BC             ; 1:6       -1 +loop_175(xm)   index--
    jp   nz, do175save  ; 3:10      -1 +loop_175(xm)
leave175:               ;           -1 +loop_175(xm)
exit175:                ;           xloop LOOP_STACK
    ld   BC, string178  ; 3:10      print_i   Address of string178 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_176(xm)
do176save:              ;           0 10 do_176(xm)
    ld  (idx176),BC     ; 4:20      0 10 do_176(xm)
do176:                  ;           0 10 do_176(xm)
    push DE             ; 1:11      i_176(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_176(m)
    ld   HL, (idx176)   ; 3:16      i_176(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=x3332   _TMP_STACK_INFO variant: variable
    ld    A, low x3332  ; 2:7        <=x3332   HL<=x3332 --> 0<=x3332-HL
    sub   L             ; 1:4        <=x3332   HL<=x3332 --> 0<=x3332-HL
    ld    A, high x3332 ; 2:7        <=x3332   HL<=x3332 --> 0<=x3332-HL
    sbc   A, H          ; 1:4        <=x3332   HL<=x3332 --> 0<=x3332-HL --> false if carry
    rra                 ; 1:4        <=x3332
    xor   H             ; 1:4        <=x3332   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=x3332
    pop  DE             ; 1:10       <=x3332
  .warning The condition "x3332" cannot be evaluated
  if ((x3332)>=0x8000 || (x3332)<0)
    jp    p, else176    ; 3:10       <=x3332
  else
    jp    m, else176    ; 3:10       <=x3332
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif176       ; 3:10      else
else176:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif176:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_176(xm)   variant -1.A: step -1 and stop 0, run 11x
idx176 EQU $+1          ;           -1 +loop_176(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_176(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_176(xm)
    or    B             ; 1:4       -1 +loop_176(xm)
    dec  BC             ; 1:6       -1 +loop_176(xm)   index--
    jp   nz, do176save  ; 3:10      -1 +loop_176(xm)
leave176:               ;           -1 +loop_176(xm)
exit176:                ;           xloop LOOP_STACK
    ld   BC, string179  ; 3:10      print_i   Address of string179 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3333 = 13107 ------
    ld   BC, 10         ; 3:10      0 10 do_177(xm)
do177save:              ;           0 10 do_177(xm)
    ld  (idx177),BC     ; 4:20      0 10 do_177(xm)
do177:                  ;           0 10 do_177(xm)
    push DE             ; 1:11      i_177(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_177(m)
    ld   HL, (idx177)   ; 3:16      i_177(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:33]      <=+13107   _TMP_STACK_INFO #variant: hi == lo, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0x33       ; 2:7        <=+13107   HL<=13107 --> 0<=0x33-L --> false if carry
    cp    L             ; 1:4        <=+13107   HL<=13107 --> 0<=0x33-L --> false if carry
    sbc   A, H          ; 1:4        <=+13107   HL<=13107 --> 0<=0x33-H --> false if carry
    rra                 ; 1:4        <=+13107
    xor   H             ; 1:4        <=+13107   invert sign if HL is negative
    jp    m, else177    ; 3:10       <=+13107   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif177       ; 3:10      else
else177:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif177:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_177(xm)   variant -1.A: step -1 and stop 0, run 11x
idx177 EQU $+1          ;           -1 +loop_177(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_177(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_177(xm)
    or    B             ; 1:4       -1 +loop_177(xm)
    dec  BC             ; 1:6       -1 +loop_177(xm)   index--
    jp   nz, do177save  ; 3:10      -1 +loop_177(xm)
leave177:               ;           -1 +loop_177(xm)
exit177:                ;           xloop LOOP_STACK
    ld   BC, string180  ; 3:10      print_i   Address of string180 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_178(xm)
do178save:              ;           0 10 do_178(xm)
    ld  (idx178),BC     ; 4:20      0 10 do_178(xm)
do178:                  ;           0 10 do_178(xm)
    push DE             ; 1:11      i_178(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_178(m)
    ld   HL, (idx178)   ; 3:16      i_178(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:47]      <=+13107   _TMP_STACK_INFO variant: hi == lo
    ld    A, 0x33       ; 2:7        <=+13107   HL<=13107 --> 0<=0x33-L
    cp    L             ; 1:4        <=+13107   HL<=13107 --> 0<=0x33-L
    sbc   A, H          ; 1:4        <=+13107   HL<=13107 --> 0<=0x33-H --> false if carry
    rra                 ; 1:4        <=+13107
    xor   H             ; 1:4        <=+13107   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=+13107
    pop  DE             ; 1:10       <=+13107
    jp    m, else178    ; 3:10       <=+13107   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif178       ; 3:10      else
else178:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif178:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_178(xm)   variant -1.A: step -1 and stop 0, run 11x
idx178 EQU $+1          ;           -1 +loop_178(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_178(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_178(xm)
    or    B             ; 1:4       -1 +loop_178(xm)
    dec  BC             ; 1:6       -1 +loop_178(xm)   index--
    jp   nz, do178save  ; 3:10      -1 +loop_178(xm)
leave178:               ;           -1 +loop_178(xm)
exit178:                ;           xloop LOOP_STACK
    ld   BC, string180  ; 3:10      print_i   Address of string181 ending with inverted most significant bit == string180
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_179(xm)
do179save:              ;           0 10 do_179(xm)
    ld  (idx179),BC     ; 4:20      0 10 do_179(xm)
do179:                  ;           0 10 do_179(xm)
    push DE             ; 1:11      i_179(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_179(m)
    ld   HL, (idx179)   ; 3:16      i_179(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=x3333   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "x3333" cannot be evaluated
    ld    A, low x3333  ; 2:7        <=x3333   HL<=x3333 --> 0<=x3333-HL --> false if carry
    sub   L             ; 1:4        <=x3333   HL<=x3333 --> 0<=x3333-HL --> false if carry
    ld    A, high x3333 ; 2:7        <=x3333   HL<=x3333 --> 0<=x3333-HL --> false if carry
    sbc   A, H          ; 1:4        <=x3333   HL<=x3333 --> 0<=x3333-HL --> false if carry
    rra                 ; 1:4        <=x3333
    xor   H             ; 1:4        <=x3333   invert sign if HL is negative
  if ((x3333)>=0x8000 || (x3333)<0)
    jp    p, else179    ; 3:10       <=x3333   negative constant --> false if not sign
  else
    jp    m, else179    ; 3:10       <=x3333   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif179       ; 3:10      else
else179:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif179:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_179(xm)   variant -1.A: step -1 and stop 0, run 11x
idx179 EQU $+1          ;           -1 +loop_179(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_179(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_179(xm)
    or    B             ; 1:4       -1 +loop_179(xm)
    dec  BC             ; 1:6       -1 +loop_179(xm)   index--
    jp   nz, do179save  ; 3:10      -1 +loop_179(xm)
leave179:               ;           -1 +loop_179(xm)
exit179:                ;           xloop LOOP_STACK
    ld   BC, string182  ; 3:10      print_i   Address of string182 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_180(xm)
do180save:              ;           0 10 do_180(xm)
    ld  (idx180),BC     ; 4:20      0 10 do_180(xm)
do180:                  ;           0 10 do_180(xm)
    push DE             ; 1:11      i_180(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_180(m)
    ld   HL, (idx180)   ; 3:16      i_180(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=x3333   _TMP_STACK_INFO variant: variable
    ld    A, low x3333  ; 2:7        <=x3333   HL<=x3333 --> 0<=x3333-HL
    sub   L             ; 1:4        <=x3333   HL<=x3333 --> 0<=x3333-HL
    ld    A, high x3333 ; 2:7        <=x3333   HL<=x3333 --> 0<=x3333-HL
    sbc   A, H          ; 1:4        <=x3333   HL<=x3333 --> 0<=x3333-HL --> false if carry
    rra                 ; 1:4        <=x3333
    xor   H             ; 1:4        <=x3333   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=x3333
    pop  DE             ; 1:10       <=x3333
  .warning The condition "x3333" cannot be evaluated
  if ((x3333)>=0x8000 || (x3333)<0)
    jp    p, else180    ; 3:10       <=x3333
  else
    jp    m, else180    ; 3:10       <=x3333
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif180       ; 3:10      else
else180:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif180:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_180(xm)   variant -1.A: step -1 and stop 0, run 11x
idx180 EQU $+1          ;           -1 +loop_180(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_180(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_180(xm)
    or    B             ; 1:4       -1 +loop_180(xm)
    dec  BC             ; 1:6       -1 +loop_180(xm)   index--
    jp   nz, do180save  ; 3:10      -1 +loop_180(xm)
leave180:               ;           -1 +loop_180(xm)
exit180:                ;           xloop LOOP_STACK
    ld   BC, string183  ; 3:10      print_i   Address of string183 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3334 = 13108 ------
    ld   BC, 10         ; 3:10      0 10 do_181(xm)
do181save:              ;           0 10 do_181(xm)
    ld  (idx181),BC     ; 4:20      0 10 do_181(xm)
do181:                  ;           0 10 do_181(xm)
    push DE             ; 1:11      i_181(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_181(m)
    ld   HL, (idx181)   ; 3:16      i_181(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=+13108   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0x34       ; 2:7        <=+13108   HL<=13108 --> 0<=0x34-L --> false if carry
    sub   L             ; 1:4        <=+13108   HL<=13108 --> 0<=0x34-L --> false if carry
    ld    A, 0x33       ; 2:7        <=+13108   HL<=13108 --> 0<=0x33-H --> false if carry
    sbc   A, H          ; 1:4        <=+13108   HL<=13108 --> 0<=0x33-H --> false if carry
    rra                 ; 1:4        <=+13108
    xor   H             ; 1:4        <=+13108   invert sign if HL is negative
    jp    m, else181    ; 3:10       <=+13108   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif181       ; 3:10      else
else181:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif181:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_181(xm)   variant -1.A: step -1 and stop 0, run 11x
idx181 EQU $+1          ;           -1 +loop_181(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_181(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_181(xm)
    or    B             ; 1:4       -1 +loop_181(xm)
    dec  BC             ; 1:6       -1 +loop_181(xm)   index--
    jp   nz, do181save  ; 3:10      -1 +loop_181(xm)
leave181:               ;           -1 +loop_181(xm)
exit181:                ;           xloop LOOP_STACK
    ld   BC, string184  ; 3:10      print_i   Address of string184 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_182(xm)
do182save:              ;           0 10 do_182(xm)
    ld  (idx182),BC     ; 4:20      0 10 do_182(xm)
do182:                  ;           0 10 do_182(xm)
    push DE             ; 1:11      i_182(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_182(m)
    ld   HL, (idx182)   ; 3:16      i_182(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=+13108   _TMP_STACK_INFO variant: default
    ld    A, 0x34       ; 2:7        <=+13108   HL<=13108 --> 0<=0x34-L
    sub   L             ; 1:4        <=+13108   HL<=13108 --> 0<=0x34-L
    ld    A, 0x33       ; 2:7        <=+13108   HL<=13108 --> 0<=0x33-H
    sbc   A, H          ; 1:4        <=+13108   HL<=13108 --> 0<=0x33-H --> false if carry
    rra                 ; 1:4        <=+13108
    xor   H             ; 1:4        <=+13108   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=+13108
    pop  DE             ; 1:10       <=+13108
    jp    m, else182    ; 3:10       <=+13108   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif182       ; 3:10      else
else182:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif182:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_182(xm)   variant -1.A: step -1 and stop 0, run 11x
idx182 EQU $+1          ;           -1 +loop_182(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_182(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_182(xm)
    or    B             ; 1:4       -1 +loop_182(xm)
    dec  BC             ; 1:6       -1 +loop_182(xm)   index--
    jp   nz, do182save  ; 3:10      -1 +loop_182(xm)
leave182:               ;           -1 +loop_182(xm)
exit182:                ;           xloop LOOP_STACK
    ld   BC, string184  ; 3:10      print_i   Address of string185 ending with inverted most significant bit == string184
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_183(xm)
do183save:              ;           0 10 do_183(xm)
    ld  (idx183),BC     ; 4:20      0 10 do_183(xm)
do183:                  ;           0 10 do_183(xm)
    push DE             ; 1:11      i_183(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_183(m)
    ld   HL, (idx183)   ; 3:16      i_183(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=x3334   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "x3334" cannot be evaluated
    ld    A, low x3334  ; 2:7        <=x3334   HL<=x3334 --> 0<=x3334-HL --> false if carry
    sub   L             ; 1:4        <=x3334   HL<=x3334 --> 0<=x3334-HL --> false if carry
    ld    A, high x3334 ; 2:7        <=x3334   HL<=x3334 --> 0<=x3334-HL --> false if carry
    sbc   A, H          ; 1:4        <=x3334   HL<=x3334 --> 0<=x3334-HL --> false if carry
    rra                 ; 1:4        <=x3334
    xor   H             ; 1:4        <=x3334   invert sign if HL is negative
  if ((x3334)>=0x8000 || (x3334)<0)
    jp    p, else183    ; 3:10       <=x3334   negative constant --> false if not sign
  else
    jp    m, else183    ; 3:10       <=x3334   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif183       ; 3:10      else
else183:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif183:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_183(xm)   variant -1.A: step -1 and stop 0, run 11x
idx183 EQU $+1          ;           -1 +loop_183(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_183(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_183(xm)
    or    B             ; 1:4       -1 +loop_183(xm)
    dec  BC             ; 1:6       -1 +loop_183(xm)   index--
    jp   nz, do183save  ; 3:10      -1 +loop_183(xm)
leave183:               ;           -1 +loop_183(xm)
exit183:                ;           xloop LOOP_STACK
    ld   BC, string186  ; 3:10      print_i   Address of string186 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_184(xm)
do184save:              ;           0 10 do_184(xm)
    ld  (idx184),BC     ; 4:20      0 10 do_184(xm)
do184:                  ;           0 10 do_184(xm)
    push DE             ; 1:11      i_184(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_184(m)
    ld   HL, (idx184)   ; 3:16      i_184(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=x3334   _TMP_STACK_INFO variant: variable
    ld    A, low x3334  ; 2:7        <=x3334   HL<=x3334 --> 0<=x3334-HL
    sub   L             ; 1:4        <=x3334   HL<=x3334 --> 0<=x3334-HL
    ld    A, high x3334 ; 2:7        <=x3334   HL<=x3334 --> 0<=x3334-HL
    sbc   A, H          ; 1:4        <=x3334   HL<=x3334 --> 0<=x3334-HL --> false if carry
    rra                 ; 1:4        <=x3334
    xor   H             ; 1:4        <=x3334   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=x3334
    pop  DE             ; 1:10       <=x3334
  .warning The condition "x3334" cannot be evaluated
  if ((x3334)>=0x8000 || (x3334)<0)
    jp    p, else184    ; 3:10       <=x3334
  else
    jp    m, else184    ; 3:10       <=x3334
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif184       ; 3:10      else
else184:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif184:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_184(xm)   variant -1.A: step -1 and stop 0, run 11x
idx184 EQU $+1          ;           -1 +loop_184(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_184(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_184(xm)
    or    B             ; 1:4       -1 +loop_184(xm)
    dec  BC             ; 1:6       -1 +loop_184(xm)   index--
    jp   nz, do184save  ; 3:10      -1 +loop_184(xm)
leave184:               ;           -1 +loop_184(xm)
exit184:                ;           xloop LOOP_STACK
    ld   BC, string187  ; 3:10      print_i   Address of string187 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- max ------
    ld   BC, 10         ; 3:10      0 10 do_185(xm)
do185save:              ;           0 10 do_185(xm)
    ld  (idx185),BC     ; 4:20      0 10 do_185(xm)
do185:                  ;           0 10 do_185(xm)
    push DE             ; 1:11      i_185(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_185(m)
    ld   HL, (idx185)   ; 3:16      i_185(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[0:0]       <=0x7FFF   _TMP_STACK_INFO variant: <=max
  .warning The condition is always True!
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif185       ; 3:10      else
else185:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif185:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_185(xm)   variant -1.A: step -1 and stop 0, run 11x
idx185 EQU $+1          ;           -1 +loop_185(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_185(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_185(xm)
    or    B             ; 1:4       -1 +loop_185(xm)
    dec  BC             ; 1:6       -1 +loop_185(xm)   index--
    jp   nz, do185save  ; 3:10      -1 +loop_185(xm)
leave185:               ;           -1 +loop_185(xm)
exit185:                ;           xloop LOOP_STACK
    ld   BC, string188  ; 3:10      print_i   Address of string188 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_186(xm)
do186save:              ;           0 10 do_186(xm)
    ld  (idx186),BC     ; 4:20      0 10 do_186(xm)
do186:                  ;           0 10 do_186(xm)
    push DE             ; 1:11      i_186(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_186(m)
    ld   HL, (idx186)   ; 3:16      i_186(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[2:14]      <=0x7FFF   _TMP_STACK_INFO variant: max
  .warning The condition is always True!
    ex   DE, HL         ; 1:4        <=0x7FFF   HL<=max --> true
    pop  DE             ; 1:10       <=0x7FFF
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif186       ; 3:10      else
else186:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif186:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_186(xm)   variant -1.A: step -1 and stop 0, run 11x
idx186 EQU $+1          ;           -1 +loop_186(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_186(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_186(xm)
    or    B             ; 1:4       -1 +loop_186(xm)
    dec  BC             ; 1:6       -1 +loop_186(xm)   index--
    jp   nz, do186save  ; 3:10      -1 +loop_186(xm)
leave186:               ;           -1 +loop_186(xm)
exit186:                ;           xloop LOOP_STACK
    ld   BC, string188  ; 3:10      print_i   Address of string189 ending with inverted most significant bit == string188
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_187(xm)
do187save:              ;           0 10 do_187(xm)
    ld  (idx187),BC     ; 4:20      0 10 do_187(xm)
do187:                  ;           0 10 do_187(xm)
    push DE             ; 1:11      i_187(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_187(m)
    ld   HL, (idx187)   ; 3:16      i_187(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      <=max   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "max" cannot be evaluated
    ld    A, low max    ; 2:7        <=max   HL<=max --> 0<=max-HL --> false if carry
    sub   L             ; 1:4        <=max   HL<=max --> 0<=max-HL --> false if carry
    ld    A, high max   ; 2:7        <=max   HL<=max --> 0<=max-HL --> false if carry
    sbc   A, H          ; 1:4        <=max   HL<=max --> 0<=max-HL --> false if carry
    rra                 ; 1:4        <=max
    xor   H             ; 1:4        <=max   invert sign if HL is negative
  if ((max)>=0x8000 || (max)<0)
    jp    p, else187    ; 3:10       <=max   negative constant --> false if not sign
  else
    jp    m, else187    ; 3:10       <=max   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif187       ; 3:10      else
else187:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif187:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_187(xm)   variant -1.A: step -1 and stop 0, run 11x
idx187 EQU $+1          ;           -1 +loop_187(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_187(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_187(xm)
    or    B             ; 1:4       -1 +loop_187(xm)
    dec  BC             ; 1:6       -1 +loop_187(xm)   index--
    jp   nz, do187save  ; 3:10      -1 +loop_187(xm)
leave187:               ;           -1 +loop_187(xm)
exit187:                ;           xloop LOOP_STACK
    ld   BC, string190  ; 3:10      print_i   Address of string190 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_188(xm)
do188save:              ;           0 10 do_188(xm)
    ld  (idx188),BC     ; 4:20      0 10 do_188(xm)
do188:                  ;           0 10 do_188(xm)
    push DE             ; 1:11      i_188(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_188(m)
    ld   HL, (idx188)   ; 3:16      i_188(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      <=max   _TMP_STACK_INFO variant: variable
    ld    A, low max    ; 2:7        <=max   HL<=max --> 0<=max-HL
    sub   L             ; 1:4        <=max   HL<=max --> 0<=max-HL
    ld    A, high max   ; 2:7        <=max   HL<=max --> 0<=max-HL
    sbc   A, H          ; 1:4        <=max   HL<=max --> 0<=max-HL --> false if carry
    rra                 ; 1:4        <=max
    xor   H             ; 1:4        <=max   invert sign if HL is negative
    ex   DE, HL         ; 1:4        <=max
    pop  DE             ; 1:10       <=max
  .warning The condition "max" cannot be evaluated
  if ((max)>=0x8000 || (max)<0)
    jp    p, else188    ; 3:10       <=max
  else
    jp    m, else188    ; 3:10       <=max
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif188       ; 3:10      else
else188:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif188:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_188(xm)   variant -1.A: step -1 and stop 0, run 11x
idx188 EQU $+1          ;           -1 +loop_188(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_188(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_188(xm)
    or    B             ; 1:4       -1 +loop_188(xm)
    dec  BC             ; 1:6       -1 +loop_188(xm)   index--
    jp   nz, do188save  ; 3:10      -1 +loop_188(xm)
leave188:               ;           -1 +loop_188(xm)
exit188:                ;           xloop LOOP_STACK
    ld   BC, string191  ; 3:10      print_i   Address of string191 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- min ------
    ld   BC, 10         ; 3:10      0 10 do_189(xm)
do189save:              ;           0 10 do_189(xm)
    ld  (idx189),BC     ; 4:20      0 10 do_189(xm)
do189:                  ;           0 10 do_189(xm)
    push DE             ; 1:11      i_189(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_189(m)
    ld   HL, (idx189)   ; 3:16      i_189(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[0:0]       >=0x8000   _TMP_STACK_INFO variant: >=min
  .warning The condition is always True!
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif189       ; 3:10      else
else189:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif189:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_189(xm)   variant -1.A: step -1 and stop 0, run 11x
idx189 EQU $+1          ;           -1 +loop_189(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_189(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_189(xm)
    or    B             ; 1:4       -1 +loop_189(xm)
    dec  BC             ; 1:6       -1 +loop_189(xm)   index--
    jp   nz, do189save  ; 3:10      -1 +loop_189(xm)
leave189:               ;           -1 +loop_189(xm)
exit189:                ;           xloop LOOP_STACK
    ld   BC, string192  ; 3:10      print_i   Address of string192 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_190(xm)
do190save:              ;           0 10 do_190(xm)
    ld  (idx190),BC     ; 4:20      0 10 do_190(xm)
do190:                  ;           0 10 do_190(xm)
    push DE             ; 1:11      i_190(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_190(m)
    ld   HL, (idx190)   ; 3:16      i_190(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[2:14]      >=0x8000   _TMP_STACK_INFO variant: min
  .warning The condition is always True!
    ex   DE, HL         ; 1:4        >=0x8000   HL>=min --> true
    pop  DE             ; 1:10       >=0x8000
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif190       ; 3:10      else
else190:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif190:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_190(xm)   variant -1.A: step -1 and stop 0, run 11x
idx190 EQU $+1          ;           -1 +loop_190(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_190(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_190(xm)
    or    B             ; 1:4       -1 +loop_190(xm)
    dec  BC             ; 1:6       -1 +loop_190(xm)   index--
    jp   nz, do190save  ; 3:10      -1 +loop_190(xm)
leave190:               ;           -1 +loop_190(xm)
exit190:                ;           xloop LOOP_STACK
    ld   BC, string192  ; 3:10      print_i   Address of string193 ending with inverted most significant bit == string192
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_191(xm)
do191save:              ;           0 10 do_191(xm)
    ld  (idx191),BC     ; 4:20      0 10 do_191(xm)
do191:                  ;           0 10 do_191(xm)
    push DE             ; 1:11      i_191(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_191(m)
    ld   HL, (idx191)   ; 3:16      i_191(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=min   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "min" cannot be evaluated
    ld    A, L          ; 1:4        >=min   HL>=min --> HL-min>=0 --> false if carry
    sub   low min       ; 2:7        >=min   HL>=min --> HL-min>=0 --> false if carry
    ld    A, H          ; 1:4        >=min   HL>=min --> HL-min>=0 --> false if carry
    sbc   A, high min   ; 2:7        >=min   HL>=min --> HL-min>=0 --> false if carry
    rra                 ; 1:4        >=min
    xor   H             ; 1:4        >=min   invert sign if HL is negative
  if ((min)>=0x8000 || (min)<0)
    jp    p, else191    ; 3:10       >=min   negative constant --> false if not sign
  else
    jp    m, else191    ; 3:10       >=min   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif191       ; 3:10      else
else191:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif191:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_191(xm)   variant -1.A: step -1 and stop 0, run 11x
idx191 EQU $+1          ;           -1 +loop_191(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_191(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_191(xm)
    or    B             ; 1:4       -1 +loop_191(xm)
    dec  BC             ; 1:6       -1 +loop_191(xm)   index--
    jp   nz, do191save  ; 3:10      -1 +loop_191(xm)
leave191:               ;           -1 +loop_191(xm)
exit191:                ;           xloop LOOP_STACK
    ld   BC, string194  ; 3:10      print_i   Address of string194 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_192(xm)
do192save:              ;           0 10 do_192(xm)
    ld  (idx192),BC     ; 4:20      0 10 do_192(xm)
do192:                  ;           0 10 do_192(xm)
    push DE             ; 1:11      i_192(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_192(m)
    ld   HL, (idx192)   ; 3:16      i_192(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=min   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        >=min   HL>=min --> L-min>=0
    sub  low min        ; 2:7        >=min   HL>=min --> L-min>=0
    ld    A, H          ; 1:4        >=min   HL>=min --> H-min>=0
    sbc   A, high min   ; 2:7        >=min   HL>=min --> H-min>=0 --> false if carry
    rra                 ; 1:4        >=min
    xor   H             ; 1:4        >=min   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=min
    pop  DE             ; 1:10       >=min
  .warning The condition "min" cannot be evaluated
  if ((min)>=0x8000 || (min)<0)
    jp    p, else192    ; 3:10       >=min
  else
    jp    m, else192    ; 3:10       >=min
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif192       ; 3:10      else
else192:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif192:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_192(xm)   variant -1.A: step -1 and stop 0, run 11x
idx192 EQU $+1          ;           -1 +loop_192(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_192(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_192(xm)
    or    B             ; 1:4       -1 +loop_192(xm)
    dec  BC             ; 1:6       -1 +loop_192(xm)   index--
    jp   nz, do192save  ; 3:10      -1 +loop_192(xm)
leave192:               ;           -1 +loop_192(xm)
exit192:                ;           xloop LOOP_STACK
    ld   BC, string195  ; 3:10      print_i   Address of string195 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0xFEFD = 65277 ------
    ld   BC, 10         ; 3:10      0 10 do_193(xm)
do193save:              ;           0 10 do_193(xm)
    ld  (idx193),BC     ; 4:20      0 10 do_193(xm)
do193:                  ;           0 10 do_193(xm)
    push DE             ; 1:11      i_193(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_193(m)
    ld   HL, (idx193)   ; 3:16      i_193(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=+65277   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4        >=+65277   HL>=65277 --> L-0xFD>=0 --> false if carry
    sub  0xFD           ; 2:7        >=+65277   HL>=65277 --> L-0xFD>=0 --> false if carry
    ld    A, H          ; 1:4        >=+65277   HL>=65277 --> H-0xFE>=0 --> false if carry
    sbc   A, 0xFE       ; 2:7        >=+65277   HL>=65277 --> H-0xFE>=0 --> false if carry
    rra                 ; 1:4        >=+65277
    xor   H             ; 1:4        >=+65277   invert sign if HL is negative
    jp    p, else193    ; 3:10       >=+65277   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif193       ; 3:10      else
else193:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif193:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_193(xm)   variant -1.A: step -1 and stop 0, run 11x
idx193 EQU $+1          ;           -1 +loop_193(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_193(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_193(xm)
    or    B             ; 1:4       -1 +loop_193(xm)
    dec  BC             ; 1:6       -1 +loop_193(xm)   index--
    jp   nz, do193save  ; 3:10      -1 +loop_193(xm)
leave193:               ;           -1 +loop_193(xm)
exit193:                ;           xloop LOOP_STACK
    ld   BC, string196  ; 3:10      print_i   Address of string196 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_194(xm)
do194save:              ;           0 10 do_194(xm)
    ld  (idx194),BC     ; 4:20      0 10 do_194(xm)
do194:                  ;           0 10 do_194(xm)
    push DE             ; 1:11      i_194(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_194(m)
    ld   HL, (idx194)   ; 3:16      i_194(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=+65277   _TMP_STACK_INFO variant: default
    ld    A, L          ; 1:4        >=+65277   HL>=65277 --> L-0xFD>=0
    sub   0xFD          ; 2:7        >=+65277   HL>=65277 --> L-0xFD>=0
    ld    A, H          ; 1:4        >=+65277   HL>=65277 --> H-0xFE>=0
    sbc   A, 0xFE       ; 2:7        >=+65277   HL>=65277 --> H-0xFE>=0 --> false if carry
    rra                 ; 1:4        >=+65277
    xor   H             ; 1:4        >=+65277   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=+65277
    pop  DE             ; 1:10       >=+65277
    jp    p, else194    ; 3:10       >=+65277   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif194       ; 3:10      else
else194:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif194:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_194(xm)   variant -1.A: step -1 and stop 0, run 11x
idx194 EQU $+1          ;           -1 +loop_194(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_194(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_194(xm)
    or    B             ; 1:4       -1 +loop_194(xm)
    dec  BC             ; 1:6       -1 +loop_194(xm)   index--
    jp   nz, do194save  ; 3:10      -1 +loop_194(xm)
leave194:               ;           -1 +loop_194(xm)
exit194:                ;           xloop LOOP_STACK
    ld   BC, string196  ; 3:10      print_i   Address of string197 ending with inverted most significant bit == string196
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_195(xm)
do195save:              ;           0 10 do_195(xm)
    ld  (idx195),BC     ; 4:20      0 10 do_195(xm)
do195:                  ;           0 10 do_195(xm)
    push DE             ; 1:11      i_195(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_195(m)
    ld   HL, (idx195)   ; 3:16      i_195(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=xFEFD   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "xFEFD" cannot be evaluated
    ld    A, L          ; 1:4        >=xFEFD   HL>=xFEFD --> HL-xFEFD>=0 --> false if carry
    sub   low xFEFD     ; 2:7        >=xFEFD   HL>=xFEFD --> HL-xFEFD>=0 --> false if carry
    ld    A, H          ; 1:4        >=xFEFD   HL>=xFEFD --> HL-xFEFD>=0 --> false if carry
    sbc   A, high xFEFD ; 2:7        >=xFEFD   HL>=xFEFD --> HL-xFEFD>=0 --> false if carry
    rra                 ; 1:4        >=xFEFD
    xor   H             ; 1:4        >=xFEFD   invert sign if HL is negative
  if ((xFEFD)>=0x8000 || (xFEFD)<0)
    jp    p, else195    ; 3:10       >=xFEFD   negative constant --> false if not sign
  else
    jp    m, else195    ; 3:10       >=xFEFD   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif195       ; 3:10      else
else195:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif195:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_195(xm)   variant -1.A: step -1 and stop 0, run 11x
idx195 EQU $+1          ;           -1 +loop_195(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_195(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_195(xm)
    or    B             ; 1:4       -1 +loop_195(xm)
    dec  BC             ; 1:6       -1 +loop_195(xm)   index--
    jp   nz, do195save  ; 3:10      -1 +loop_195(xm)
leave195:               ;           -1 +loop_195(xm)
exit195:                ;           xloop LOOP_STACK
    ld   BC, string198  ; 3:10      print_i   Address of string198 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_196(xm)
do196save:              ;           0 10 do_196(xm)
    ld  (idx196),BC     ; 4:20      0 10 do_196(xm)
do196:                  ;           0 10 do_196(xm)
    push DE             ; 1:11      i_196(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_196(m)
    ld   HL, (idx196)   ; 3:16      i_196(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=xFEFD   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        >=xFEFD   HL>=xFEFD --> L-xFEFD>=0
    sub  low xFEFD      ; 2:7        >=xFEFD   HL>=xFEFD --> L-xFEFD>=0
    ld    A, H          ; 1:4        >=xFEFD   HL>=xFEFD --> H-xFEFD>=0
    sbc   A, high xFEFD ; 2:7        >=xFEFD   HL>=xFEFD --> H-xFEFD>=0 --> false if carry
    rra                 ; 1:4        >=xFEFD
    xor   H             ; 1:4        >=xFEFD   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=xFEFD
    pop  DE             ; 1:10       >=xFEFD
  .warning The condition "xFEFD" cannot be evaluated
  if ((xFEFD)>=0x8000 || (xFEFD)<0)
    jp    p, else196    ; 3:10       >=xFEFD
  else
    jp    m, else196    ; 3:10       >=xFEFD
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif196       ; 3:10      else
else196:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif196:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_196(xm)   variant -1.A: step -1 and stop 0, run 11x
idx196 EQU $+1          ;           -1 +loop_196(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_196(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_196(xm)
    or    B             ; 1:4       -1 +loop_196(xm)
    dec  BC             ; 1:6       -1 +loop_196(xm)   index--
    jp   nz, do196save  ; 3:10      -1 +loop_196(xm)
leave196:               ;           -1 +loop_196(xm)
exit196:                ;           xloop LOOP_STACK
    ld   BC, string199  ; 3:10      print_i   Address of string199 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0xFEFE = 65278 ------
    ld   BC, 10         ; 3:10      0 10 do_197(xm)
do197save:              ;           0 10 do_197(xm)
    ld  (idx197),BC     ; 4:20      0 10 do_197(xm)
do197:                  ;           0 10 do_197(xm)
    push DE             ; 1:11      i_197(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_197(m)
    ld   HL, (idx197)   ; 3:16      i_197(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=+65278   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4        >=+65278   HL>=65278 --> L-0xFE>=0 --> false if carry
    sub  0xFE           ; 2:7        >=+65278   HL>=65278 --> L-0xFE>=0 --> false if carry
    ld    A, H          ; 1:4        >=+65278   HL>=65278 --> H-0xFE>=0 --> false if carry
    sbc   A, 0xFE       ; 2:7        >=+65278   HL>=65278 --> H-0xFE>=0 --> false if carry
    rra                 ; 1:4        >=+65278
    xor   H             ; 1:4        >=+65278   invert sign if HL is negative
    jp    p, else197    ; 3:10       >=+65278   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif197       ; 3:10      else
else197:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif197:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_197(xm)   variant -1.A: step -1 and stop 0, run 11x
idx197 EQU $+1          ;           -1 +loop_197(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_197(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_197(xm)
    or    B             ; 1:4       -1 +loop_197(xm)
    dec  BC             ; 1:6       -1 +loop_197(xm)   index--
    jp   nz, do197save  ; 3:10      -1 +loop_197(xm)
leave197:               ;           -1 +loop_197(xm)
exit197:                ;           xloop LOOP_STACK
    ld   BC, string200  ; 3:10      print_i   Address of string200 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_198(xm)
do198save:              ;           0 10 do_198(xm)
    ld  (idx198),BC     ; 4:20      0 10 do_198(xm)
do198:                  ;           0 10 do_198(xm)
    push DE             ; 1:11      i_198(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_198(m)
    ld   HL, (idx198)   ; 3:16      i_198(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=+65278   _TMP_STACK_INFO variant: default
    ld    A, L          ; 1:4        >=+65278   HL>=65278 --> L-0xFE>=0
    sub   0xFE          ; 2:7        >=+65278   HL>=65278 --> L-0xFE>=0
    ld    A, H          ; 1:4        >=+65278   HL>=65278 --> H-0xFE>=0
    sbc   A, 0xFE       ; 2:7        >=+65278   HL>=65278 --> H-0xFE>=0 --> false if carry
    rra                 ; 1:4        >=+65278
    xor   H             ; 1:4        >=+65278   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=+65278
    pop  DE             ; 1:10       >=+65278
    jp    p, else198    ; 3:10       >=+65278   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif198       ; 3:10      else
else198:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif198:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_198(xm)   variant -1.A: step -1 and stop 0, run 11x
idx198 EQU $+1          ;           -1 +loop_198(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_198(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_198(xm)
    or    B             ; 1:4       -1 +loop_198(xm)
    dec  BC             ; 1:6       -1 +loop_198(xm)   index--
    jp   nz, do198save  ; 3:10      -1 +loop_198(xm)
leave198:               ;           -1 +loop_198(xm)
exit198:                ;           xloop LOOP_STACK
    ld   BC, string200  ; 3:10      print_i   Address of string201 ending with inverted most significant bit == string200
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_199(xm)
do199save:              ;           0 10 do_199(xm)
    ld  (idx199),BC     ; 4:20      0 10 do_199(xm)
do199:                  ;           0 10 do_199(xm)
    push DE             ; 1:11      i_199(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_199(m)
    ld   HL, (idx199)   ; 3:16      i_199(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=xFEFE   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "xFEFE" cannot be evaluated
    ld    A, L          ; 1:4        >=xFEFE   HL>=xFEFE --> HL-xFEFE>=0 --> false if carry
    sub   low xFEFE     ; 2:7        >=xFEFE   HL>=xFEFE --> HL-xFEFE>=0 --> false if carry
    ld    A, H          ; 1:4        >=xFEFE   HL>=xFEFE --> HL-xFEFE>=0 --> false if carry
    sbc   A, high xFEFE ; 2:7        >=xFEFE   HL>=xFEFE --> HL-xFEFE>=0 --> false if carry
    rra                 ; 1:4        >=xFEFE
    xor   H             ; 1:4        >=xFEFE   invert sign if HL is negative
  if ((xFEFE)>=0x8000 || (xFEFE)<0)
    jp    p, else199    ; 3:10       >=xFEFE   negative constant --> false if not sign
  else
    jp    m, else199    ; 3:10       >=xFEFE   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif199       ; 3:10      else
else199:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif199:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_199(xm)   variant -1.A: step -1 and stop 0, run 11x
idx199 EQU $+1          ;           -1 +loop_199(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_199(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_199(xm)
    or    B             ; 1:4       -1 +loop_199(xm)
    dec  BC             ; 1:6       -1 +loop_199(xm)   index--
    jp   nz, do199save  ; 3:10      -1 +loop_199(xm)
leave199:               ;           -1 +loop_199(xm)
exit199:                ;           xloop LOOP_STACK
    ld   BC, string202  ; 3:10      print_i   Address of string202 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_200(xm)
do200save:              ;           0 10 do_200(xm)
    ld  (idx200),BC     ; 4:20      0 10 do_200(xm)
do200:                  ;           0 10 do_200(xm)
    push DE             ; 1:11      i_200(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_200(m)
    ld   HL, (idx200)   ; 3:16      i_200(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=xFEFE   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        >=xFEFE   HL>=xFEFE --> L-xFEFE>=0
    sub  low xFEFE      ; 2:7        >=xFEFE   HL>=xFEFE --> L-xFEFE>=0
    ld    A, H          ; 1:4        >=xFEFE   HL>=xFEFE --> H-xFEFE>=0
    sbc   A, high xFEFE ; 2:7        >=xFEFE   HL>=xFEFE --> H-xFEFE>=0 --> false if carry
    rra                 ; 1:4        >=xFEFE
    xor   H             ; 1:4        >=xFEFE   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=xFEFE
    pop  DE             ; 1:10       >=xFEFE
  .warning The condition "xFEFE" cannot be evaluated
  if ((xFEFE)>=0x8000 || (xFEFE)<0)
    jp    p, else200    ; 3:10       >=xFEFE
  else
    jp    m, else200    ; 3:10       >=xFEFE
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif200       ; 3:10      else
else200:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif200:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_200(xm)   variant -1.A: step -1 and stop 0, run 11x
idx200 EQU $+1          ;           -1 +loop_200(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_200(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_200(xm)
    or    B             ; 1:4       -1 +loop_200(xm)
    dec  BC             ; 1:6       -1 +loop_200(xm)   index--
    jp   nz, do200save  ; 3:10      -1 +loop_200(xm)
leave200:               ;           -1 +loop_200(xm)
exit200:                ;           xloop LOOP_STACK
    ld   BC, string203  ; 3:10      print_i   Address of string203 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0xFEFF = 65279 ------
    ld   BC, 10         ; 3:10      0 10 do_201(xm)
do201save:              ;           0 10 do_201(xm)
    ld  (idx201),BC     ; 4:20      0 10 do_201(xm)
do201:                  ;           0 10 do_201(xm)
    push DE             ; 1:11      i_201(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_201(m)
    ld   HL, (idx201)   ; 3:16      i_201(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:33]      >=+65279   _TMP_STACK_INFO #variant: hi == lo-1, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0xFE       ; 2:7        >=+65279   HL>=0xFEFF --> HL>0xFEFE
    cp    L             ; 1:4        >=+65279   HL> 0xFEFE -->  0>0xFE-L --> false if not carry
    sbc   A, H          ; 1:4        >=+65279   HL> 0xFEFE -->  0>0xFE-H --> false if not carry
    rra                 ; 1:4        >=+65279
    xor   H             ; 1:4        >=+65279   invert sign if HL is negative
    jp    m, else201    ; 3:10       >=+65279   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif201       ; 3:10      else
else201:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif201:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_201(xm)   variant -1.A: step -1 and stop 0, run 11x
idx201 EQU $+1          ;           -1 +loop_201(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_201(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_201(xm)
    or    B             ; 1:4       -1 +loop_201(xm)
    dec  BC             ; 1:6       -1 +loop_201(xm)   index--
    jp   nz, do201save  ; 3:10      -1 +loop_201(xm)
leave201:               ;           -1 +loop_201(xm)
exit201:                ;           xloop LOOP_STACK
    ld   BC, string204  ; 3:10      print_i   Address of string204 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_202(xm)
do202save:              ;           0 10 do_202(xm)
    ld  (idx202),BC     ; 4:20      0 10 do_202(xm)
do202:                  ;           0 10 do_202(xm)
    push DE             ; 1:11      i_202(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_202(m)
    ld   HL, (idx202)   ; 3:16      i_202(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:47]      >=+65279   _TMP_STACK_INFO variant: hi == lo-1
    ld    A, 0xFE       ; 2:7        >=+65279   HL>=0xFEFF --> HL>0xFEFE
    cp    L             ; 1:4        >=+65279   HL> 0xFEFE -->  0>0xFE-L
    sbc   A, H          ; 1:4        >=+65279   HL> 0xFEFE -->  0>0xFE-H --> false if not carry
    rra                 ; 1:4        >=+65279
    xor   H             ; 1:4        >=+65279   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=+65279
    pop  DE             ; 1:10       >=+65279
    jp    m, else202    ; 3:10       >=+65279   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif202       ; 3:10      else
else202:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif202:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_202(xm)   variant -1.A: step -1 and stop 0, run 11x
idx202 EQU $+1          ;           -1 +loop_202(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_202(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_202(xm)
    or    B             ; 1:4       -1 +loop_202(xm)
    dec  BC             ; 1:6       -1 +loop_202(xm)   index--
    jp   nz, do202save  ; 3:10      -1 +loop_202(xm)
leave202:               ;           -1 +loop_202(xm)
exit202:                ;           xloop LOOP_STACK
    ld   BC, string204  ; 3:10      print_i   Address of string205 ending with inverted most significant bit == string204
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_203(xm)
do203save:              ;           0 10 do_203(xm)
    ld  (idx203),BC     ; 4:20      0 10 do_203(xm)
do203:                  ;           0 10 do_203(xm)
    push DE             ; 1:11      i_203(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_203(m)
    ld   HL, (idx203)   ; 3:16      i_203(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=xFEFF   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "xFEFF" cannot be evaluated
    ld    A, L          ; 1:4        >=xFEFF   HL>=xFEFF --> HL-xFEFF>=0 --> false if carry
    sub   low xFEFF     ; 2:7        >=xFEFF   HL>=xFEFF --> HL-xFEFF>=0 --> false if carry
    ld    A, H          ; 1:4        >=xFEFF   HL>=xFEFF --> HL-xFEFF>=0 --> false if carry
    sbc   A, high xFEFF ; 2:7        >=xFEFF   HL>=xFEFF --> HL-xFEFF>=0 --> false if carry
    rra                 ; 1:4        >=xFEFF
    xor   H             ; 1:4        >=xFEFF   invert sign if HL is negative
  if ((xFEFF)>=0x8000 || (xFEFF)<0)
    jp    p, else203    ; 3:10       >=xFEFF   negative constant --> false if not sign
  else
    jp    m, else203    ; 3:10       >=xFEFF   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif203       ; 3:10      else
else203:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif203:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_203(xm)   variant -1.A: step -1 and stop 0, run 11x
idx203 EQU $+1          ;           -1 +loop_203(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_203(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_203(xm)
    or    B             ; 1:4       -1 +loop_203(xm)
    dec  BC             ; 1:6       -1 +loop_203(xm)   index--
    jp   nz, do203save  ; 3:10      -1 +loop_203(xm)
leave203:               ;           -1 +loop_203(xm)
exit203:                ;           xloop LOOP_STACK
    ld   BC, string206  ; 3:10      print_i   Address of string206 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_204(xm)
do204save:              ;           0 10 do_204(xm)
    ld  (idx204),BC     ; 4:20      0 10 do_204(xm)
do204:                  ;           0 10 do_204(xm)
    push DE             ; 1:11      i_204(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_204(m)
    ld   HL, (idx204)   ; 3:16      i_204(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=xFEFF   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        >=xFEFF   HL>=xFEFF --> L-xFEFF>=0
    sub  low xFEFF      ; 2:7        >=xFEFF   HL>=xFEFF --> L-xFEFF>=0
    ld    A, H          ; 1:4        >=xFEFF   HL>=xFEFF --> H-xFEFF>=0
    sbc   A, high xFEFF ; 2:7        >=xFEFF   HL>=xFEFF --> H-xFEFF>=0 --> false if carry
    rra                 ; 1:4        >=xFEFF
    xor   H             ; 1:4        >=xFEFF   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=xFEFF
    pop  DE             ; 1:10       >=xFEFF
  .warning The condition "xFEFF" cannot be evaluated
  if ((xFEFF)>=0x8000 || (xFEFF)<0)
    jp    p, else204    ; 3:10       >=xFEFF
  else
    jp    m, else204    ; 3:10       >=xFEFF
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif204       ; 3:10      else
else204:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif204:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_204(xm)   variant -1.A: step -1 and stop 0, run 11x
idx204 EQU $+1          ;           -1 +loop_204(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_204(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_204(xm)
    or    B             ; 1:4       -1 +loop_204(xm)
    dec  BC             ; 1:6       -1 +loop_204(xm)   index--
    jp   nz, do204save  ; 3:10      -1 +loop_204(xm)
leave204:               ;           -1 +loop_204(xm)
exit204:                ;           xloop LOOP_STACK
    ld   BC, string207  ; 3:10      print_i   Address of string207 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- -1 ------
    ld   BC, 10         ; 3:10      0 10 do_205(xm)
do205save:              ;           0 10 do_205(xm)
    ld  (idx205),BC     ; 4:20      0 10 do_205(xm)
do205:                  ;           0 10 do_205(xm)
    push DE             ; 1:11      i_205(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_205(m)
    ld   HL, (idx205)   ; 3:16      i_205(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=-1   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4        >=-1   HL>=-1 --> L-0xFF>=0 --> false if carry
    sub  0xFF           ; 2:7        >=-1   HL>=-1 --> L-0xFF>=0 --> false if carry
    ld    A, H          ; 1:4        >=-1   HL>=-1 --> H-0xFF>=0 --> false if carry
    sbc   A, 0xFF       ; 2:7        >=-1   HL>=-1 --> H-0xFF>=0 --> false if carry
    rra                 ; 1:4        >=-1
    xor   H             ; 1:4        >=-1   invert sign if HL is negative
    jp    p, else205    ; 3:10       >=-1   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif205       ; 3:10      else
else205:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif205:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_205(xm)   variant -1.A: step -1 and stop 0, run 11x
idx205 EQU $+1          ;           -1 +loop_205(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_205(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_205(xm)
    or    B             ; 1:4       -1 +loop_205(xm)
    dec  BC             ; 1:6       -1 +loop_205(xm)   index--
    jp   nz, do205save  ; 3:10      -1 +loop_205(xm)
leave205:               ;           -1 +loop_205(xm)
exit205:                ;           xloop LOOP_STACK
    ld   BC, string208  ; 3:10      print_i   Address of string208 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_206(xm)
do206save:              ;           0 10 do_206(xm)
    ld  (idx206),BC     ; 4:20      0 10 do_206(xm)
do206:                  ;           0 10 do_206(xm)
    push DE             ; 1:11      i_206(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_206(m)
    ld   HL, (idx206)   ; 3:16      i_206(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=-1   _TMP_STACK_INFO variant: default
    ld    A, L          ; 1:4        >=-1   HL>=-1 --> L-0xFF>=0
    sub   0xFF          ; 2:7        >=-1   HL>=-1 --> L-0xFF>=0
    ld    A, H          ; 1:4        >=-1   HL>=-1 --> H-0xFF>=0
    sbc   A, 0xFF       ; 2:7        >=-1   HL>=-1 --> H-0xFF>=0 --> false if carry
    rra                 ; 1:4        >=-1
    xor   H             ; 1:4        >=-1   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=-1
    pop  DE             ; 1:10       >=-1
    jp    p, else206    ; 3:10       >=-1   negative constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif206       ; 3:10      else
else206:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif206:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_206(xm)   variant -1.A: step -1 and stop 0, run 11x
idx206 EQU $+1          ;           -1 +loop_206(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_206(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_206(xm)
    or    B             ; 1:4       -1 +loop_206(xm)
    dec  BC             ; 1:6       -1 +loop_206(xm)   index--
    jp   nz, do206save  ; 3:10      -1 +loop_206(xm)
leave206:               ;           -1 +loop_206(xm)
exit206:                ;           xloop LOOP_STACK
    ld   BC, string208  ; 3:10      print_i   Address of string209 ending with inverted most significant bit == string208
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_207(xm)
do207save:              ;           0 10 do_207(xm)
    ld  (idx207),BC     ; 4:20      0 10 do_207(xm)
do207:                  ;           0 10 do_207(xm)
    push DE             ; 1:11      i_207(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_207(m)
    ld   HL, (idx207)   ; 3:16      i_207(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=m1   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "m1" cannot be evaluated
    ld    A, L          ; 1:4        >=m1   HL>=m1 --> HL-m1>=0 --> false if carry
    sub   low m1        ; 2:7        >=m1   HL>=m1 --> HL-m1>=0 --> false if carry
    ld    A, H          ; 1:4        >=m1   HL>=m1 --> HL-m1>=0 --> false if carry
    sbc   A, high m1    ; 2:7        >=m1   HL>=m1 --> HL-m1>=0 --> false if carry
    rra                 ; 1:4        >=m1
    xor   H             ; 1:4        >=m1   invert sign if HL is negative
  if ((m1)>=0x8000 || (m1)<0)
    jp    p, else207    ; 3:10       >=m1   negative constant --> false if not sign
  else
    jp    m, else207    ; 3:10       >=m1   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif207       ; 3:10      else
else207:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif207:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_207(xm)   variant -1.A: step -1 and stop 0, run 11x
idx207 EQU $+1          ;           -1 +loop_207(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_207(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_207(xm)
    or    B             ; 1:4       -1 +loop_207(xm)
    dec  BC             ; 1:6       -1 +loop_207(xm)   index--
    jp   nz, do207save  ; 3:10      -1 +loop_207(xm)
leave207:               ;           -1 +loop_207(xm)
exit207:                ;           xloop LOOP_STACK
    ld   BC, string210  ; 3:10      print_i   Address of string210 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_208(xm)
do208save:              ;           0 10 do_208(xm)
    ld  (idx208),BC     ; 4:20      0 10 do_208(xm)
do208:                  ;           0 10 do_208(xm)
    push DE             ; 1:11      i_208(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_208(m)
    ld   HL, (idx208)   ; 3:16      i_208(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=m1   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        >=m1   HL>=m1 --> L-m1>=0
    sub  low m1         ; 2:7        >=m1   HL>=m1 --> L-m1>=0
    ld    A, H          ; 1:4        >=m1   HL>=m1 --> H-m1>=0
    sbc   A, high m1    ; 2:7        >=m1   HL>=m1 --> H-m1>=0 --> false if carry
    rra                 ; 1:4        >=m1
    xor   H             ; 1:4        >=m1   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=m1
    pop  DE             ; 1:10       >=m1
  .warning The condition "m1" cannot be evaluated
  if ((m1)>=0x8000 || (m1)<0)
    jp    p, else208    ; 3:10       >=m1
  else
    jp    m, else208    ; 3:10       >=m1
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif208       ; 3:10      else
else208:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif208:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_208(xm)   variant -1.A: step -1 and stop 0, run 11x
idx208 EQU $+1          ;           -1 +loop_208(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_208(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_208(xm)
    or    B             ; 1:4       -1 +loop_208(xm)
    dec  BC             ; 1:6       -1 +loop_208(xm)   index--
    jp   nz, do208save  ; 3:10      -1 +loop_208(xm)
leave208:               ;           -1 +loop_208(xm)
exit208:                ;           xloop LOOP_STACK
    ld   BC, string211  ; 3:10      print_i   Address of string211 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0 ------
    ld   BC, 10         ; 3:10      0 10 do_209(xm)
do209save:              ;           0 10 do_209(xm)
    ld  (idx209),BC     ; 4:20      0 10 do_209(xm)
do209:                  ;           0 10 do_209(xm)
    push DE             ; 1:11      i_209(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_209(m)
    ld   HL, (idx209)   ; 3:16      i_209(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[5:18]      >=0   _TMP_STACK_INFO variant: >=zero
    bit   7, H          ; 2:8        >=0
    jp   nz, else209    ; 3:10       >=0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif209       ; 3:10      else
else209:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif209:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_209(xm)   variant -1.A: step -1 and stop 0, run 11x
idx209 EQU $+1          ;           -1 +loop_209(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_209(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_209(xm)
    or    B             ; 1:4       -1 +loop_209(xm)
    dec  BC             ; 1:6       -1 +loop_209(xm)   index--
    jp   nz, do209save  ; 3:10      -1 +loop_209(xm)
leave209:               ;           -1 +loop_209(xm)
exit209:                ;           xloop LOOP_STACK
    ld   BC, string212  ; 3:10      print_i   Address of string212 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_210(xm)
do210save:              ;           0 10 do_210(xm)
    ld  (idx210),BC     ; 4:20      0 10 do_210(xm)
do210:                  ;           0 10 do_210(xm)
    push DE             ; 1:11      i_210(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_210(m)
    ld   HL, (idx210)   ; 3:16      i_210(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:32]      >=0   _TMP_STACK_INFO variant: 0
    rl    H             ; 2:8        >=0   HL>=0 --> sign if false
    ex   DE, HL         ; 1:4        >=0
    pop  DE             ; 1:10       >=0
    jp    c, else210    ; 3:10       >=0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif210       ; 3:10      else
else210:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif210:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_210(xm)   variant -1.A: step -1 and stop 0, run 11x
idx210 EQU $+1          ;           -1 +loop_210(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_210(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_210(xm)
    or    B             ; 1:4       -1 +loop_210(xm)
    dec  BC             ; 1:6       -1 +loop_210(xm)   index--
    jp   nz, do210save  ; 3:10      -1 +loop_210(xm)
leave210:               ;           -1 +loop_210(xm)
exit210:                ;           xloop LOOP_STACK
    ld   BC, string212  ; 3:10      print_i   Address of string213 ending with inverted most significant bit == string212
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_211(xm)
do211save:              ;           0 10 do_211(xm)
    ld  (idx211),BC     ; 4:20      0 10 do_211(xm)
do211:                  ;           0 10 do_211(xm)
    push DE             ; 1:11      i_211(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_211(m)
    ld   HL, (idx211)   ; 3:16      i_211(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=zero   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "zero" cannot be evaluated
    ld    A, L          ; 1:4        >=zero   HL>=zero --> HL-zero>=0 --> false if carry
    sub   low zero      ; 2:7        >=zero   HL>=zero --> HL-zero>=0 --> false if carry
    ld    A, H          ; 1:4        >=zero   HL>=zero --> HL-zero>=0 --> false if carry
    sbc   A, high zero  ; 2:7        >=zero   HL>=zero --> HL-zero>=0 --> false if carry
    rra                 ; 1:4        >=zero
    xor   H             ; 1:4        >=zero   invert sign if HL is negative
  if ((zero)>=0x8000 || (zero)<0)
    jp    p, else211    ; 3:10       >=zero   negative constant --> false if not sign
  else
    jp    m, else211    ; 3:10       >=zero   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif211       ; 3:10      else
else211:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif211:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_211(xm)   variant -1.A: step -1 and stop 0, run 11x
idx211 EQU $+1          ;           -1 +loop_211(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_211(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_211(xm)
    or    B             ; 1:4       -1 +loop_211(xm)
    dec  BC             ; 1:6       -1 +loop_211(xm)   index--
    jp   nz, do211save  ; 3:10      -1 +loop_211(xm)
leave211:               ;           -1 +loop_211(xm)
exit211:                ;           xloop LOOP_STACK
    ld   BC, string214  ; 3:10      print_i   Address of string214 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_212(xm)
do212save:              ;           0 10 do_212(xm)
    ld  (idx212),BC     ; 4:20      0 10 do_212(xm)
do212:                  ;           0 10 do_212(xm)
    push DE             ; 1:11      i_212(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_212(m)
    ld   HL, (idx212)   ; 3:16      i_212(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=zero   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        >=zero   HL>=zero --> L-zero>=0
    sub  low zero       ; 2:7        >=zero   HL>=zero --> L-zero>=0
    ld    A, H          ; 1:4        >=zero   HL>=zero --> H-zero>=0
    sbc   A, high zero  ; 2:7        >=zero   HL>=zero --> H-zero>=0 --> false if carry
    rra                 ; 1:4        >=zero
    xor   H             ; 1:4        >=zero   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=zero
    pop  DE             ; 1:10       >=zero
  .warning The condition "zero" cannot be evaluated
  if ((zero)>=0x8000 || (zero)<0)
    jp    p, else212    ; 3:10       >=zero
  else
    jp    m, else212    ; 3:10       >=zero
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif212       ; 3:10      else
else212:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif212:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_212(xm)   variant -1.A: step -1 and stop 0, run 11x
idx212 EQU $+1          ;           -1 +loop_212(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_212(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_212(xm)
    or    B             ; 1:4       -1 +loop_212(xm)
    dec  BC             ; 1:6       -1 +loop_212(xm)   index--
    jp   nz, do212save  ; 3:10      -1 +loop_212(xm)
leave212:               ;           -1 +loop_212(xm)
exit212:                ;           xloop LOOP_STACK
    ld   BC, string215  ; 3:10      print_i   Address of string215 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 1 ------
    ld   BC, 10         ; 3:10      0 10 do_213(xm)
do213save:              ;           0 10 do_213(xm)
    ld  (idx213),BC     ; 4:20      0 10 do_213(xm)
do213:                  ;           0 10 do_213(xm)
    push DE             ; 1:11      i_213(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_213(m)
    ld   HL, (idx213)   ; 3:16      i_213(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:30]      >=+1   _TMP_STACK_INFO variant: >=1
    ld    A, H          ; 1:4        >=+1   save sign
    dec  HL             ; 1:6        >=+1   zero to negative
    or    H             ; 1:4        >=+1
    inc  HL             ; 1:6        >=+1
    jp    m, else213    ; 3:10       >=+1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif213       ; 3:10      else
else213:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif213:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_213(xm)   variant -1.A: step -1 and stop 0, run 11x
idx213 EQU $+1          ;           -1 +loop_213(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_213(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_213(xm)
    or    B             ; 1:4       -1 +loop_213(xm)
    dec  BC             ; 1:6       -1 +loop_213(xm)   index--
    jp   nz, do213save  ; 3:10      -1 +loop_213(xm)
leave213:               ;           -1 +loop_213(xm)
exit213:                ;           xloop LOOP_STACK
    ld   BC, string216  ; 3:10      print_i   Address of string216 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_214(xm)
do214save:              ;           0 10 do_214(xm)
    ld  (idx214),BC     ; 4:20      0 10 do_214(xm)
do214:                  ;           0 10 do_214(xm)
    push DE             ; 1:11      i_214(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_214(m)
    ld   HL, (idx214)   ; 3:16      i_214(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[8:38]      >=+1   _TMP_STACK_INFO variant: 1
    ld    A, H          ; 1:4        >=+1   HL>= 0         --> sign if false
    dec  HL             ; 1:6        >=+1   HL>  0         --> sign if false
    or    H             ; 1:4        >=+1   HL>= 0 && HL>0 --> sign if false
    ex   DE, HL         ; 1:4        >=+1
    pop  DE             ; 1:10       >=+1
    jp    m, else214    ; 3:10       >=+1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif214       ; 3:10      else
else214:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif214:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_214(xm)   variant -1.A: step -1 and stop 0, run 11x
idx214 EQU $+1          ;           -1 +loop_214(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_214(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_214(xm)
    or    B             ; 1:4       -1 +loop_214(xm)
    dec  BC             ; 1:6       -1 +loop_214(xm)   index--
    jp   nz, do214save  ; 3:10      -1 +loop_214(xm)
leave214:               ;           -1 +loop_214(xm)
exit214:                ;           xloop LOOP_STACK
    ld   BC, string216  ; 3:10      print_i   Address of string217 ending with inverted most significant bit == string216
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_215(xm)
do215save:              ;           0 10 do_215(xm)
    ld  (idx215),BC     ; 4:20      0 10 do_215(xm)
do215:                  ;           0 10 do_215(xm)
    push DE             ; 1:11      i_215(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_215(m)
    ld   HL, (idx215)   ; 3:16      i_215(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=p1   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "p1" cannot be evaluated
    ld    A, L          ; 1:4        >=p1   HL>=p1 --> HL-p1>=0 --> false if carry
    sub   low p1        ; 2:7        >=p1   HL>=p1 --> HL-p1>=0 --> false if carry
    ld    A, H          ; 1:4        >=p1   HL>=p1 --> HL-p1>=0 --> false if carry
    sbc   A, high p1    ; 2:7        >=p1   HL>=p1 --> HL-p1>=0 --> false if carry
    rra                 ; 1:4        >=p1
    xor   H             ; 1:4        >=p1   invert sign if HL is negative
  if ((p1)>=0x8000 || (p1)<0)
    jp    p, else215    ; 3:10       >=p1   negative constant --> false if not sign
  else
    jp    m, else215    ; 3:10       >=p1   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif215       ; 3:10      else
else215:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif215:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_215(xm)   variant -1.A: step -1 and stop 0, run 11x
idx215 EQU $+1          ;           -1 +loop_215(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_215(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_215(xm)
    or    B             ; 1:4       -1 +loop_215(xm)
    dec  BC             ; 1:6       -1 +loop_215(xm)   index--
    jp   nz, do215save  ; 3:10      -1 +loop_215(xm)
leave215:               ;           -1 +loop_215(xm)
exit215:                ;           xloop LOOP_STACK
    ld   BC, string218  ; 3:10      print_i   Address of string218 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_216(xm)
do216save:              ;           0 10 do_216(xm)
    ld  (idx216),BC     ; 4:20      0 10 do_216(xm)
do216:                  ;           0 10 do_216(xm)
    push DE             ; 1:11      i_216(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_216(m)
    ld   HL, (idx216)   ; 3:16      i_216(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=p1   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        >=p1   HL>=p1 --> L-p1>=0
    sub  low p1         ; 2:7        >=p1   HL>=p1 --> L-p1>=0
    ld    A, H          ; 1:4        >=p1   HL>=p1 --> H-p1>=0
    sbc   A, high p1    ; 2:7        >=p1   HL>=p1 --> H-p1>=0 --> false if carry
    rra                 ; 1:4        >=p1
    xor   H             ; 1:4        >=p1   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=p1
    pop  DE             ; 1:10       >=p1
  .warning The condition "p1" cannot be evaluated
  if ((p1)>=0x8000 || (p1)<0)
    jp    p, else216    ; 3:10       >=p1
  else
    jp    m, else216    ; 3:10       >=p1
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif216       ; 3:10      else
else216:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif216:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_216(xm)   variant -1.A: step -1 and stop 0, run 11x
idx216 EQU $+1          ;           -1 +loop_216(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_216(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_216(xm)
    or    B             ; 1:4       -1 +loop_216(xm)
    dec  BC             ; 1:6       -1 +loop_216(xm)   index--
    jp   nz, do216save  ; 3:10      -1 +loop_216(xm)
leave216:               ;           -1 +loop_216(xm)
exit216:                ;           xloop LOOP_STACK
    ld   BC, string219  ; 3:10      print_i   Address of string219 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3332 = 13106 ------
    ld   BC, 10         ; 3:10      0 10 do_217(xm)
do217save:              ;           0 10 do_217(xm)
    ld  (idx217),BC     ; 4:20      0 10 do_217(xm)
do217:                  ;           0 10 do_217(xm)
    push DE             ; 1:11      i_217(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_217(m)
    ld   HL, (idx217)   ; 3:16      i_217(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=+13106   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4        >=+13106   HL>=13106 --> L-0x32>=0 --> false if carry
    sub  0x32           ; 2:7        >=+13106   HL>=13106 --> L-0x32>=0 --> false if carry
    ld    A, H          ; 1:4        >=+13106   HL>=13106 --> H-0x33>=0 --> false if carry
    sbc   A, 0x33       ; 2:7        >=+13106   HL>=13106 --> H-0x33>=0 --> false if carry
    rra                 ; 1:4        >=+13106
    xor   H             ; 1:4        >=+13106   invert sign if HL is negative
    jp    m, else217    ; 3:10       >=+13106   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif217       ; 3:10      else
else217:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif217:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_217(xm)   variant -1.A: step -1 and stop 0, run 11x
idx217 EQU $+1          ;           -1 +loop_217(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_217(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_217(xm)
    or    B             ; 1:4       -1 +loop_217(xm)
    dec  BC             ; 1:6       -1 +loop_217(xm)   index--
    jp   nz, do217save  ; 3:10      -1 +loop_217(xm)
leave217:               ;           -1 +loop_217(xm)
exit217:                ;           xloop LOOP_STACK
    ld   BC, string220  ; 3:10      print_i   Address of string220 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_218(xm)
do218save:              ;           0 10 do_218(xm)
    ld  (idx218),BC     ; 4:20      0 10 do_218(xm)
do218:                  ;           0 10 do_218(xm)
    push DE             ; 1:11      i_218(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_218(m)
    ld   HL, (idx218)   ; 3:16      i_218(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=+13106   _TMP_STACK_INFO variant: default
    ld    A, L          ; 1:4        >=+13106   HL>=13106 --> L-0x32>=0
    sub   0x32          ; 2:7        >=+13106   HL>=13106 --> L-0x32>=0
    ld    A, H          ; 1:4        >=+13106   HL>=13106 --> H-0x33>=0
    sbc   A, 0x33       ; 2:7        >=+13106   HL>=13106 --> H-0x33>=0 --> false if carry
    rra                 ; 1:4        >=+13106
    xor   H             ; 1:4        >=+13106   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=+13106
    pop  DE             ; 1:10       >=+13106
    jp    m, else218    ; 3:10       >=+13106   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif218       ; 3:10      else
else218:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif218:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_218(xm)   variant -1.A: step -1 and stop 0, run 11x
idx218 EQU $+1          ;           -1 +loop_218(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_218(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_218(xm)
    or    B             ; 1:4       -1 +loop_218(xm)
    dec  BC             ; 1:6       -1 +loop_218(xm)   index--
    jp   nz, do218save  ; 3:10      -1 +loop_218(xm)
leave218:               ;           -1 +loop_218(xm)
exit218:                ;           xloop LOOP_STACK
    ld   BC, string220  ; 3:10      print_i   Address of string221 ending with inverted most significant bit == string220
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_219(xm)
do219save:              ;           0 10 do_219(xm)
    ld  (idx219),BC     ; 4:20      0 10 do_219(xm)
do219:                  ;           0 10 do_219(xm)
    push DE             ; 1:11      i_219(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_219(m)
    ld   HL, (idx219)   ; 3:16      i_219(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=x3332   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "x3332" cannot be evaluated
    ld    A, L          ; 1:4        >=x3332   HL>=x3332 --> HL-x3332>=0 --> false if carry
    sub   low x3332     ; 2:7        >=x3332   HL>=x3332 --> HL-x3332>=0 --> false if carry
    ld    A, H          ; 1:4        >=x3332   HL>=x3332 --> HL-x3332>=0 --> false if carry
    sbc   A, high x3332 ; 2:7        >=x3332   HL>=x3332 --> HL-x3332>=0 --> false if carry
    rra                 ; 1:4        >=x3332
    xor   H             ; 1:4        >=x3332   invert sign if HL is negative
  if ((x3332)>=0x8000 || (x3332)<0)
    jp    p, else219    ; 3:10       >=x3332   negative constant --> false if not sign
  else
    jp    m, else219    ; 3:10       >=x3332   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif219       ; 3:10      else
else219:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif219:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_219(xm)   variant -1.A: step -1 and stop 0, run 11x
idx219 EQU $+1          ;           -1 +loop_219(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_219(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_219(xm)
    or    B             ; 1:4       -1 +loop_219(xm)
    dec  BC             ; 1:6       -1 +loop_219(xm)   index--
    jp   nz, do219save  ; 3:10      -1 +loop_219(xm)
leave219:               ;           -1 +loop_219(xm)
exit219:                ;           xloop LOOP_STACK
    ld   BC, string222  ; 3:10      print_i   Address of string222 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_220(xm)
do220save:              ;           0 10 do_220(xm)
    ld  (idx220),BC     ; 4:20      0 10 do_220(xm)
do220:                  ;           0 10 do_220(xm)
    push DE             ; 1:11      i_220(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_220(m)
    ld   HL, (idx220)   ; 3:16      i_220(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=x3332   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        >=x3332   HL>=x3332 --> L-x3332>=0
    sub  low x3332      ; 2:7        >=x3332   HL>=x3332 --> L-x3332>=0
    ld    A, H          ; 1:4        >=x3332   HL>=x3332 --> H-x3332>=0
    sbc   A, high x3332 ; 2:7        >=x3332   HL>=x3332 --> H-x3332>=0 --> false if carry
    rra                 ; 1:4        >=x3332
    xor   H             ; 1:4        >=x3332   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=x3332
    pop  DE             ; 1:10       >=x3332
  .warning The condition "x3332" cannot be evaluated
  if ((x3332)>=0x8000 || (x3332)<0)
    jp    p, else220    ; 3:10       >=x3332
  else
    jp    m, else220    ; 3:10       >=x3332
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif220       ; 3:10      else
else220:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif220:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_220(xm)   variant -1.A: step -1 and stop 0, run 11x
idx220 EQU $+1          ;           -1 +loop_220(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_220(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_220(xm)
    or    B             ; 1:4       -1 +loop_220(xm)
    dec  BC             ; 1:6       -1 +loop_220(xm)   index--
    jp   nz, do220save  ; 3:10      -1 +loop_220(xm)
leave220:               ;           -1 +loop_220(xm)
exit220:                ;           xloop LOOP_STACK
    ld   BC, string223  ; 3:10      print_i   Address of string223 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3333 = 13107 ------
    ld   BC, 10         ; 3:10      0 10 do_221(xm)
do221save:              ;           0 10 do_221(xm)
    ld  (idx221),BC     ; 4:20      0 10 do_221(xm)
do221:                  ;           0 10 do_221(xm)
    push DE             ; 1:11      i_221(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_221(m)
    ld   HL, (idx221)   ; 3:16      i_221(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=+13107   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4        >=+13107   HL>=13107 --> L-0x33>=0 --> false if carry
    sub  0x33           ; 2:7        >=+13107   HL>=13107 --> L-0x33>=0 --> false if carry
    ld    A, H          ; 1:4        >=+13107   HL>=13107 --> H-0x33>=0 --> false if carry
    sbc   A, 0x33       ; 2:7        >=+13107   HL>=13107 --> H-0x33>=0 --> false if carry
    rra                 ; 1:4        >=+13107
    xor   H             ; 1:4        >=+13107   invert sign if HL is negative
    jp    m, else221    ; 3:10       >=+13107   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif221       ; 3:10      else
else221:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif221:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_221(xm)   variant -1.A: step -1 and stop 0, run 11x
idx221 EQU $+1          ;           -1 +loop_221(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_221(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_221(xm)
    or    B             ; 1:4       -1 +loop_221(xm)
    dec  BC             ; 1:6       -1 +loop_221(xm)   index--
    jp   nz, do221save  ; 3:10      -1 +loop_221(xm)
leave221:               ;           -1 +loop_221(xm)
exit221:                ;           xloop LOOP_STACK
    ld   BC, string224  ; 3:10      print_i   Address of string224 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_222(xm)
do222save:              ;           0 10 do_222(xm)
    ld  (idx222),BC     ; 4:20      0 10 do_222(xm)
do222:                  ;           0 10 do_222(xm)
    push DE             ; 1:11      i_222(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_222(m)
    ld   HL, (idx222)   ; 3:16      i_222(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=+13107   _TMP_STACK_INFO variant: default
    ld    A, L          ; 1:4        >=+13107   HL>=13107 --> L-0x33>=0
    sub   0x33          ; 2:7        >=+13107   HL>=13107 --> L-0x33>=0
    ld    A, H          ; 1:4        >=+13107   HL>=13107 --> H-0x33>=0
    sbc   A, 0x33       ; 2:7        >=+13107   HL>=13107 --> H-0x33>=0 --> false if carry
    rra                 ; 1:4        >=+13107
    xor   H             ; 1:4        >=+13107   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=+13107
    pop  DE             ; 1:10       >=+13107
    jp    m, else222    ; 3:10       >=+13107   positive constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif222       ; 3:10      else
else222:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif222:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_222(xm)   variant -1.A: step -1 and stop 0, run 11x
idx222 EQU $+1          ;           -1 +loop_222(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_222(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_222(xm)
    or    B             ; 1:4       -1 +loop_222(xm)
    dec  BC             ; 1:6       -1 +loop_222(xm)   index--
    jp   nz, do222save  ; 3:10      -1 +loop_222(xm)
leave222:               ;           -1 +loop_222(xm)
exit222:                ;           xloop LOOP_STACK
    ld   BC, string224  ; 3:10      print_i   Address of string225 ending with inverted most significant bit == string224
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_223(xm)
do223save:              ;           0 10 do_223(xm)
    ld  (idx223),BC     ; 4:20      0 10 do_223(xm)
do223:                  ;           0 10 do_223(xm)
    push DE             ; 1:11      i_223(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_223(m)
    ld   HL, (idx223)   ; 3:16      i_223(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=x3333   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "x3333" cannot be evaluated
    ld    A, L          ; 1:4        >=x3333   HL>=x3333 --> HL-x3333>=0 --> false if carry
    sub   low x3333     ; 2:7        >=x3333   HL>=x3333 --> HL-x3333>=0 --> false if carry
    ld    A, H          ; 1:4        >=x3333   HL>=x3333 --> HL-x3333>=0 --> false if carry
    sbc   A, high x3333 ; 2:7        >=x3333   HL>=x3333 --> HL-x3333>=0 --> false if carry
    rra                 ; 1:4        >=x3333
    xor   H             ; 1:4        >=x3333   invert sign if HL is negative
  if ((x3333)>=0x8000 || (x3333)<0)
    jp    p, else223    ; 3:10       >=x3333   negative constant --> false if not sign
  else
    jp    m, else223    ; 3:10       >=x3333   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif223       ; 3:10      else
else223:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif223:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_223(xm)   variant -1.A: step -1 and stop 0, run 11x
idx223 EQU $+1          ;           -1 +loop_223(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_223(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_223(xm)
    or    B             ; 1:4       -1 +loop_223(xm)
    dec  BC             ; 1:6       -1 +loop_223(xm)   index--
    jp   nz, do223save  ; 3:10      -1 +loop_223(xm)
leave223:               ;           -1 +loop_223(xm)
exit223:                ;           xloop LOOP_STACK
    ld   BC, string226  ; 3:10      print_i   Address of string226 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_224(xm)
do224save:              ;           0 10 do_224(xm)
    ld  (idx224),BC     ; 4:20      0 10 do_224(xm)
do224:                  ;           0 10 do_224(xm)
    push DE             ; 1:11      i_224(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_224(m)
    ld   HL, (idx224)   ; 3:16      i_224(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=x3333   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        >=x3333   HL>=x3333 --> L-x3333>=0
    sub  low x3333      ; 2:7        >=x3333   HL>=x3333 --> L-x3333>=0
    ld    A, H          ; 1:4        >=x3333   HL>=x3333 --> H-x3333>=0
    sbc   A, high x3333 ; 2:7        >=x3333   HL>=x3333 --> H-x3333>=0 --> false if carry
    rra                 ; 1:4        >=x3333
    xor   H             ; 1:4        >=x3333   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=x3333
    pop  DE             ; 1:10       >=x3333
  .warning The condition "x3333" cannot be evaluated
  if ((x3333)>=0x8000 || (x3333)<0)
    jp    p, else224    ; 3:10       >=x3333
  else
    jp    m, else224    ; 3:10       >=x3333
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif224       ; 3:10      else
else224:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif224:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_224(xm)   variant -1.A: step -1 and stop 0, run 11x
idx224 EQU $+1          ;           -1 +loop_224(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_224(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_224(xm)
    or    B             ; 1:4       -1 +loop_224(xm)
    dec  BC             ; 1:6       -1 +loop_224(xm)   index--
    jp   nz, do224save  ; 3:10      -1 +loop_224(xm)
leave224:               ;           -1 +loop_224(xm)
exit224:                ;           xloop LOOP_STACK
    ld   BC, string227  ; 3:10      print_i   Address of string227 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3334 = 13108 ------
    ld   BC, 10         ; 3:10      0 10 do_225(xm)
do225save:              ;           0 10 do_225(xm)
    ld  (idx225),BC     ; 4:20      0 10 do_225(xm)
do225:                  ;           0 10 do_225(xm)
    push DE             ; 1:11      i_225(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_225(m)
    ld   HL, (idx225)   ; 3:16      i_225(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:33]      >=+13108   _TMP_STACK_INFO #variant: hi == lo-1, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0x33       ; 2:7        >=+13108   HL>=0x3334 --> HL>0x3333
    cp    L             ; 1:4        >=+13108   HL> 0x3333 -->  0>0x33-L --> false if not carry
    sbc   A, H          ; 1:4        >=+13108   HL> 0x3333 -->  0>0x33-H --> false if not carry
    rra                 ; 1:4        >=+13108
    xor   H             ; 1:4        >=+13108   invert sign if HL is negative
    jp    p, else225    ; 3:10       >=+13108   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif225       ; 3:10      else
else225:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif225:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_225(xm)   variant -1.A: step -1 and stop 0, run 11x
idx225 EQU $+1          ;           -1 +loop_225(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_225(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_225(xm)
    or    B             ; 1:4       -1 +loop_225(xm)
    dec  BC             ; 1:6       -1 +loop_225(xm)   index--
    jp   nz, do225save  ; 3:10      -1 +loop_225(xm)
leave225:               ;           -1 +loop_225(xm)
exit225:                ;           xloop LOOP_STACK
    ld   BC, string228  ; 3:10      print_i   Address of string228 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_226(xm)
do226save:              ;           0 10 do_226(xm)
    ld  (idx226),BC     ; 4:20      0 10 do_226(xm)
do226:                  ;           0 10 do_226(xm)
    push DE             ; 1:11      i_226(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_226(m)
    ld   HL, (idx226)   ; 3:16      i_226(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:47]      >=+13108   _TMP_STACK_INFO variant: hi == lo-1
    ld    A, 0x33       ; 2:7        >=+13108   HL>=0x3334 --> HL>0x3333
    cp    L             ; 1:4        >=+13108   HL> 0x3333 -->  0>0x33-L
    sbc   A, H          ; 1:4        >=+13108   HL> 0x3333 -->  0>0x33-H --> false if not carry
    rra                 ; 1:4        >=+13108
    xor   H             ; 1:4        >=+13108   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=+13108
    pop  DE             ; 1:10       >=+13108
    jp    p, else226    ; 3:10       >=+13108   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif226       ; 3:10      else
else226:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif226:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_226(xm)   variant -1.A: step -1 and stop 0, run 11x
idx226 EQU $+1          ;           -1 +loop_226(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_226(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_226(xm)
    or    B             ; 1:4       -1 +loop_226(xm)
    dec  BC             ; 1:6       -1 +loop_226(xm)   index--
    jp   nz, do226save  ; 3:10      -1 +loop_226(xm)
leave226:               ;           -1 +loop_226(xm)
exit226:                ;           xloop LOOP_STACK
    ld   BC, string228  ; 3:10      print_i   Address of string229 ending with inverted most significant bit == string228
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_227(xm)
do227save:              ;           0 10 do_227(xm)
    ld  (idx227),BC     ; 4:20      0 10 do_227(xm)
do227:                  ;           0 10 do_227(xm)
    push DE             ; 1:11      i_227(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_227(m)
    ld   HL, (idx227)   ; 3:16      i_227(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=x3334   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "x3334" cannot be evaluated
    ld    A, L          ; 1:4        >=x3334   HL>=x3334 --> HL-x3334>=0 --> false if carry
    sub   low x3334     ; 2:7        >=x3334   HL>=x3334 --> HL-x3334>=0 --> false if carry
    ld    A, H          ; 1:4        >=x3334   HL>=x3334 --> HL-x3334>=0 --> false if carry
    sbc   A, high x3334 ; 2:7        >=x3334   HL>=x3334 --> HL-x3334>=0 --> false if carry
    rra                 ; 1:4        >=x3334
    xor   H             ; 1:4        >=x3334   invert sign if HL is negative
  if ((x3334)>=0x8000 || (x3334)<0)
    jp    p, else227    ; 3:10       >=x3334   negative constant --> false if not sign
  else
    jp    m, else227    ; 3:10       >=x3334   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif227       ; 3:10      else
else227:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif227:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_227(xm)   variant -1.A: step -1 and stop 0, run 11x
idx227 EQU $+1          ;           -1 +loop_227(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_227(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_227(xm)
    or    B             ; 1:4       -1 +loop_227(xm)
    dec  BC             ; 1:6       -1 +loop_227(xm)   index--
    jp   nz, do227save  ; 3:10      -1 +loop_227(xm)
leave227:               ;           -1 +loop_227(xm)
exit227:                ;           xloop LOOP_STACK
    ld   BC, string230  ; 3:10      print_i   Address of string230 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_228(xm)
do228save:              ;           0 10 do_228(xm)
    ld  (idx228),BC     ; 4:20      0 10 do_228(xm)
do228:                  ;           0 10 do_228(xm)
    push DE             ; 1:11      i_228(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_228(m)
    ld   HL, (idx228)   ; 3:16      i_228(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=x3334   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        >=x3334   HL>=x3334 --> L-x3334>=0
    sub  low x3334      ; 2:7        >=x3334   HL>=x3334 --> L-x3334>=0
    ld    A, H          ; 1:4        >=x3334   HL>=x3334 --> H-x3334>=0
    sbc   A, high x3334 ; 2:7        >=x3334   HL>=x3334 --> H-x3334>=0 --> false if carry
    rra                 ; 1:4        >=x3334
    xor   H             ; 1:4        >=x3334   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=x3334
    pop  DE             ; 1:10       >=x3334
  .warning The condition "x3334" cannot be evaluated
  if ((x3334)>=0x8000 || (x3334)<0)
    jp    p, else228    ; 3:10       >=x3334
  else
    jp    m, else228    ; 3:10       >=x3334
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif228       ; 3:10      else
else228:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif228:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_228(xm)   variant -1.A: step -1 and stop 0, run 11x
idx228 EQU $+1          ;           -1 +loop_228(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_228(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_228(xm)
    or    B             ; 1:4       -1 +loop_228(xm)
    dec  BC             ; 1:6       -1 +loop_228(xm)   index--
    jp   nz, do228save  ; 3:10      -1 +loop_228(xm)
leave228:               ;           -1 +loop_228(xm)
exit228:                ;           xloop LOOP_STACK
    ld   BC, string231  ; 3:10      print_i   Address of string231 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- max ------
    ld   BC, 10         ; 3:10      0 10 do_229(xm)
do229save:              ;           0 10 do_229(xm)
    ld  (idx229),BC     ; 4:20      0 10 do_229(xm)
do229:                  ;           0 10 do_229(xm)
    push DE             ; 1:11      i_229(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_229(m)
    ld   HL, (idx229)   ; 3:16      i_229(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[8:29]      >=0x7FFF   _TMP_STACK_INFO variant: >=max
    ld    A, 0x80       ; 2:7        >=0x7FFF
    xor   H             ; 1:4        >=0x7FFF
    and   L             ; 1:4        >=0x7FFF
    inc   A             ; 1:4        >=0x7FFF
    jp   nz, else229    ; 3:10       >=0x7FFF
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif229       ; 3:10      else
else229:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif229:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_229(xm)   variant -1.A: step -1 and stop 0, run 11x
idx229 EQU $+1          ;           -1 +loop_229(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_229(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_229(xm)
    or    B             ; 1:4       -1 +loop_229(xm)
    dec  BC             ; 1:6       -1 +loop_229(xm)   index--
    jp   nz, do229save  ; 3:10      -1 +loop_229(xm)
leave229:               ;           -1 +loop_229(xm)
exit229:                ;           xloop LOOP_STACK
    ld   BC, string232  ; 3:10      print_i   Address of string232 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_230(xm)
do230save:              ;           0 10 do_230(xm)
    ld  (idx230),BC     ; 4:20      0 10 do_230(xm)
do230:                  ;           0 10 do_230(xm)
    push DE             ; 1:11      i_230(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_230(m)
    ld   HL, (idx230)   ; 3:16      i_230(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[10:43]      >=0x7FFF   _TMP_STACK_INFO variant: max
    ld    A, 0x7F       ; 2:7        >=0x7FFF
    xor   H             ; 1:4        >=0x7FFF
    inc   L             ; 1:4        >=0x7FFF
    or    L             ; 1:4        >=0x7FFF
    ex   DE, HL         ; 1:4        >=0x7FFF
    pop  DE             ; 1:10       >=0x7FFF
    jp   nz, else230    ; 3:10       >=0x7FFF
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif230       ; 3:10      else
else230:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif230:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_230(xm)   variant -1.A: step -1 and stop 0, run 11x
idx230 EQU $+1          ;           -1 +loop_230(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_230(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_230(xm)
    or    B             ; 1:4       -1 +loop_230(xm)
    dec  BC             ; 1:6       -1 +loop_230(xm)   index--
    jp   nz, do230save  ; 3:10      -1 +loop_230(xm)
leave230:               ;           -1 +loop_230(xm)
exit230:                ;           xloop LOOP_STACK
    ld   BC, string232  ; 3:10      print_i   Address of string233 ending with inverted most significant bit == string232
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_231(xm)
do231save:              ;           0 10 do_231(xm)
    ld  (idx231),BC     ; 4:20      0 10 do_231(xm)
do231:                  ;           0 10 do_231(xm)
    push DE             ; 1:11      i_231(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_231(m)
    ld   HL, (idx231)   ; 3:16      i_231(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      >=max   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "max" cannot be evaluated
    ld    A, L          ; 1:4        >=max   HL>=max --> HL-max>=0 --> false if carry
    sub   low max       ; 2:7        >=max   HL>=max --> HL-max>=0 --> false if carry
    ld    A, H          ; 1:4        >=max   HL>=max --> HL-max>=0 --> false if carry
    sbc   A, high max   ; 2:7        >=max   HL>=max --> HL-max>=0 --> false if carry
    rra                 ; 1:4        >=max
    xor   H             ; 1:4        >=max   invert sign if HL is negative
  if ((max)>=0x8000 || (max)<0)
    jp    p, else231    ; 3:10       >=max   negative constant --> false if not sign
  else
    jp    m, else231    ; 3:10       >=max   positive constant --> false if sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif231       ; 3:10      else
else231:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif231:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_231(xm)   variant -1.A: step -1 and stop 0, run 11x
idx231 EQU $+1          ;           -1 +loop_231(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_231(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_231(xm)
    or    B             ; 1:4       -1 +loop_231(xm)
    dec  BC             ; 1:6       -1 +loop_231(xm)   index--
    jp   nz, do231save  ; 3:10      -1 +loop_231(xm)
leave231:               ;           -1 +loop_231(xm)
exit231:                ;           xloop LOOP_STACK
    ld   BC, string234  ; 3:10      print_i   Address of string234 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_232(xm)
do232save:              ;           0 10 do_232(xm)
    ld  (idx232),BC     ; 4:20      0 10 do_232(xm)
do232:                  ;           0 10 do_232(xm)
    push DE             ; 1:11      i_232(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_232(m)
    ld   HL, (idx232)   ; 3:16      i_232(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      >=max   _TMP_STACK_INFO variant: variable
    ld    A, L          ; 1:4        >=max   HL>=max --> L-max>=0
    sub  low max        ; 2:7        >=max   HL>=max --> L-max>=0
    ld    A, H          ; 1:4        >=max   HL>=max --> H-max>=0
    sbc   A, high max   ; 2:7        >=max   HL>=max --> H-max>=0 --> false if carry
    rra                 ; 1:4        >=max
    xor   H             ; 1:4        >=max   invert sign if HL is negative
    ex   DE, HL         ; 1:4        >=max
    pop  DE             ; 1:10       >=max
  .warning The condition "max" cannot be evaluated
  if ((max)>=0x8000 || (max)<0)
    jp    p, else232    ; 3:10       >=max
  else
    jp    m, else232    ; 3:10       >=max
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif232       ; 3:10      else
else232:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif232:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_232(xm)   variant -1.A: step -1 and stop 0, run 11x
idx232 EQU $+1          ;           -1 +loop_232(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_232(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_232(xm)
    or    B             ; 1:4       -1 +loop_232(xm)
    dec  BC             ; 1:6       -1 +loop_232(xm)   index--
    jp   nz, do232save  ; 3:10      -1 +loop_232(xm)
leave232:               ;           -1 +loop_232(xm)
exit232:                ;           xloop LOOP_STACK
    ld   BC, string235  ; 3:10      print_i   Address of string235 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- min ------
    ld   BC, 10         ; 3:10      0 10 do_233(xm)
do233save:              ;           0 10 do_233(xm)
    ld  (idx233),BC     ; 4:20      0 10 do_233(xm)
do233:                  ;           0 10 do_233(xm)
    push DE             ; 1:11      i_233(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_233(m)
    ld   HL, (idx233)   ; 3:16      i_233(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:25]      > 0x8000   _TMP_STACK_INFO variant: >min
    ld    A, 0x80       ; 2:7        > 0x8000
    xor   H             ; 1:4        > 0x8000
    or    L             ; 1:4        > 0x8000
    jp    z, else233    ; 3:10       > 0x8000
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif233       ; 3:10      else
else233:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif233:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_233(xm)   variant -1.A: step -1 and stop 0, run 11x
idx233 EQU $+1          ;           -1 +loop_233(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_233(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_233(xm)
    or    B             ; 1:4       -1 +loop_233(xm)
    dec  BC             ; 1:6       -1 +loop_233(xm)   index--
    jp   nz, do233save  ; 3:10      -1 +loop_233(xm)
leave233:               ;           -1 +loop_233(xm)
exit233:                ;           xloop LOOP_STACK
    ld   BC, string236  ; 3:10      print_i   Address of string236 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_234(xm)
do234save:              ;           0 10 do_234(xm)
    ld  (idx234),BC     ; 4:20      0 10 do_234(xm)
do234:                  ;           0 10 do_234(xm)
    push DE             ; 1:11      i_234(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_234(m)
    ld   HL, (idx234)   ; 3:16      i_234(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:39]      > 0x8000   _TMP_STACK_INFO variant: min
    ld    A, 0x80       ; 2:7        > 0x8000
    xor   H             ; 1:4        > 0x8000
    or    L             ; 1:4        > 0x8000
    ex   DE, HL         ; 1:4        > 0x8000
    pop  DE             ; 1:10       > 0x8000
    jp    z, else234    ; 3:10       > 0x8000
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif234       ; 3:10      else
else234:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif234:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_234(xm)   variant -1.A: step -1 and stop 0, run 11x
idx234 EQU $+1          ;           -1 +loop_234(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_234(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_234(xm)
    or    B             ; 1:4       -1 +loop_234(xm)
    dec  BC             ; 1:6       -1 +loop_234(xm)   index--
    jp   nz, do234save  ; 3:10      -1 +loop_234(xm)
leave234:               ;           -1 +loop_234(xm)
exit234:                ;           xloop LOOP_STACK
    ld   BC, string236  ; 3:10      print_i   Address of string237 ending with inverted most significant bit == string236
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_235(xm)
do235save:              ;           0 10 do_235(xm)
    ld  (idx235),BC     ; 4:20      0 10 do_235(xm)
do235:                  ;           0 10 do_235(xm)
    push DE             ; 1:11      i_235(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_235(m)
    ld   HL, (idx235)   ; 3:16      i_235(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > min   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "min" cannot be evaluated
    ld    A, low min    ; 2:7        > min   HL>min --> 0>min-HL --> false if not carry
    sub   L             ; 1:4        > min   HL>min --> 0>min-HL --> false if not carry
    ld    A, high min   ; 2:7        > min   HL>min --> 0>min-HL --> false if not carry
    sbc   A, H          ; 1:4        > min   HL>min --> 0>min-HL --> false if not carry
    rra                 ; 1:4        > min
    xor   H             ; 1:4        > min   invert sign if HL is negative
  if ((min)>=0x8000 || (min)<0)
    jp    m, else235    ; 3:10       > min   negative constant --> false if sign
  else
    jp    p, else235    ; 3:10       > min   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif235       ; 3:10      else
else235:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif235:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_235(xm)   variant -1.A: step -1 and stop 0, run 11x
idx235 EQU $+1          ;           -1 +loop_235(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_235(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_235(xm)
    or    B             ; 1:4       -1 +loop_235(xm)
    dec  BC             ; 1:6       -1 +loop_235(xm)   index--
    jp   nz, do235save  ; 3:10      -1 +loop_235(xm)
leave235:               ;           -1 +loop_235(xm)
exit235:                ;           xloop LOOP_STACK
    ld   BC, string238  ; 3:10      print_i   Address of string238 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_236(xm)
do236save:              ;           0 10 do_236(xm)
    ld  (idx236),BC     ; 4:20      0 10 do_236(xm)
do236:                  ;           0 10 do_236(xm)
    push DE             ; 1:11      i_236(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_236(m)
    ld   HL, (idx236)   ; 3:16      i_236(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > min   _TMP_STACK_INFO variant: variable
    ld    A, low min    ; 2:7        > min   HL>min --> 0>min-HL
    sub   L             ; 1:4        > min   HL>min --> 0>min-HL
    ld    A, high min   ; 2:7        > min   HL>min --> 0>min-HL
    sbc   A, H          ; 1:4        > min   HL>min --> 0>min-HL --> false if not carry
    rra                 ; 1:4        > min
    xor   H             ; 1:4        > min   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > min
    pop  DE             ; 1:10       > min
  .warning The condition "min" cannot be evaluated
  if ((min)>=0x8000 || (min)<0)
    jp    m, else236    ; 3:10       > min
  else
    jp    p, else236    ; 3:10       > min
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif236       ; 3:10      else
else236:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif236:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_236(xm)   variant -1.A: step -1 and stop 0, run 11x
idx236 EQU $+1          ;           -1 +loop_236(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_236(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_236(xm)
    or    B             ; 1:4       -1 +loop_236(xm)
    dec  BC             ; 1:6       -1 +loop_236(xm)   index--
    jp   nz, do236save  ; 3:10      -1 +loop_236(xm)
leave236:               ;           -1 +loop_236(xm)
exit236:                ;           xloop LOOP_STACK
    ld   BC, string239  ; 3:10      print_i   Address of string239 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0xFEFD = 65277 ------
    ld   BC, 10         ; 3:10      0 10 do_237(xm)
do237save:              ;           0 10 do_237(xm)
    ld  (idx237),BC     ; 4:20      0 10 do_237(xm)
do237:                  ;           0 10 do_237(xm)
    push DE             ; 1:11      i_237(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_237(m)
    ld   HL, (idx237)   ; 3:16      i_237(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > +65277   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0xFD       ; 2:7        > +65277   HL>65277 --> 0>0xFD-L --> false if not carry
    sub   L             ; 1:4        > +65277   HL>65277 --> 0>0xFD-L --> false if not carry
    ld    A, 0xFE       ; 2:7        > +65277   HL>65277 --> 0>0xFE-H --> false if not carry
    sbc   A, H          ; 1:4        > +65277   HL>65277 --> 0>0xFE-H --> false if not carry
    rra                 ; 1:4        > +65277
    xor   H             ; 1:4        > +65277   invert sign if HL is negative
    jp    m, else237    ; 3:10       > +65277   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif237       ; 3:10      else
else237:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif237:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_237(xm)   variant -1.A: step -1 and stop 0, run 11x
idx237 EQU $+1          ;           -1 +loop_237(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_237(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_237(xm)
    or    B             ; 1:4       -1 +loop_237(xm)
    dec  BC             ; 1:6       -1 +loop_237(xm)   index--
    jp   nz, do237save  ; 3:10      -1 +loop_237(xm)
leave237:               ;           -1 +loop_237(xm)
exit237:                ;           xloop LOOP_STACK
    ld   BC, string240  ; 3:10      print_i   Address of string240 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_238(xm)
do238save:              ;           0 10 do_238(xm)
    ld  (idx238),BC     ; 4:20      0 10 do_238(xm)
do238:                  ;           0 10 do_238(xm)
    push DE             ; 1:11      i_238(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_238(m)
    ld   HL, (idx238)   ; 3:16      i_238(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > +65277   _TMP_STACK_INFO variant: default
    ld    A, 0xFD       ; 2:7        > +65277   HL>65277 --> 0>0xFD-L
    sub   L             ; 1:4        > +65277   HL>65277 --> 0>0xFD-L
    ld    A, 0xFE       ; 2:7        > +65277   HL>65277 --> 0>0xFE-H
    sbc   A, H          ; 1:4        > +65277   HL>65277 --> 0>0xFE-H --> false if not carry
    rra                 ; 1:4        > +65277
    xor   H             ; 1:4        > +65277   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > +65277
    pop  DE             ; 1:10       > +65277
    jp    m, else238    ; 3:10       > +65277   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif238       ; 3:10      else
else238:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif238:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_238(xm)   variant -1.A: step -1 and stop 0, run 11x
idx238 EQU $+1          ;           -1 +loop_238(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_238(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_238(xm)
    or    B             ; 1:4       -1 +loop_238(xm)
    dec  BC             ; 1:6       -1 +loop_238(xm)   index--
    jp   nz, do238save  ; 3:10      -1 +loop_238(xm)
leave238:               ;           -1 +loop_238(xm)
exit238:                ;           xloop LOOP_STACK
    ld   BC, string240  ; 3:10      print_i   Address of string241 ending with inverted most significant bit == string240
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_239(xm)
do239save:              ;           0 10 do_239(xm)
    ld  (idx239),BC     ; 4:20      0 10 do_239(xm)
do239:                  ;           0 10 do_239(xm)
    push DE             ; 1:11      i_239(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_239(m)
    ld   HL, (idx239)   ; 3:16      i_239(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > xFEFD   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "xFEFD" cannot be evaluated
    ld    A, low xFEFD  ; 2:7        > xFEFD   HL>xFEFD --> 0>xFEFD-HL --> false if not carry
    sub   L             ; 1:4        > xFEFD   HL>xFEFD --> 0>xFEFD-HL --> false if not carry
    ld    A, high xFEFD ; 2:7        > xFEFD   HL>xFEFD --> 0>xFEFD-HL --> false if not carry
    sbc   A, H          ; 1:4        > xFEFD   HL>xFEFD --> 0>xFEFD-HL --> false if not carry
    rra                 ; 1:4        > xFEFD
    xor   H             ; 1:4        > xFEFD   invert sign if HL is negative
  if ((xFEFD)>=0x8000 || (xFEFD)<0)
    jp    m, else239    ; 3:10       > xFEFD   negative constant --> false if sign
  else
    jp    p, else239    ; 3:10       > xFEFD   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif239       ; 3:10      else
else239:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif239:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_239(xm)   variant -1.A: step -1 and stop 0, run 11x
idx239 EQU $+1          ;           -1 +loop_239(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_239(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_239(xm)
    or    B             ; 1:4       -1 +loop_239(xm)
    dec  BC             ; 1:6       -1 +loop_239(xm)   index--
    jp   nz, do239save  ; 3:10      -1 +loop_239(xm)
leave239:               ;           -1 +loop_239(xm)
exit239:                ;           xloop LOOP_STACK
    ld   BC, string242  ; 3:10      print_i   Address of string242 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_240(xm)
do240save:              ;           0 10 do_240(xm)
    ld  (idx240),BC     ; 4:20      0 10 do_240(xm)
do240:                  ;           0 10 do_240(xm)
    push DE             ; 1:11      i_240(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_240(m)
    ld   HL, (idx240)   ; 3:16      i_240(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > xFEFD   _TMP_STACK_INFO variant: variable
    ld    A, low xFEFD  ; 2:7        > xFEFD   HL>xFEFD --> 0>xFEFD-HL
    sub   L             ; 1:4        > xFEFD   HL>xFEFD --> 0>xFEFD-HL
    ld    A, high xFEFD ; 2:7        > xFEFD   HL>xFEFD --> 0>xFEFD-HL
    sbc   A, H          ; 1:4        > xFEFD   HL>xFEFD --> 0>xFEFD-HL --> false if not carry
    rra                 ; 1:4        > xFEFD
    xor   H             ; 1:4        > xFEFD   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > xFEFD
    pop  DE             ; 1:10       > xFEFD
  .warning The condition "xFEFD" cannot be evaluated
  if ((xFEFD)>=0x8000 || (xFEFD)<0)
    jp    m, else240    ; 3:10       > xFEFD
  else
    jp    p, else240    ; 3:10       > xFEFD
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif240       ; 3:10      else
else240:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif240:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_240(xm)   variant -1.A: step -1 and stop 0, run 11x
idx240 EQU $+1          ;           -1 +loop_240(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_240(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_240(xm)
    or    B             ; 1:4       -1 +loop_240(xm)
    dec  BC             ; 1:6       -1 +loop_240(xm)   index--
    jp   nz, do240save  ; 3:10      -1 +loop_240(xm)
leave240:               ;           -1 +loop_240(xm)
exit240:                ;           xloop LOOP_STACK
    ld   BC, string243  ; 3:10      print_i   Address of string243 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0xFEFE = 65278 ------
    ld   BC, 10         ; 3:10      0 10 do_241(xm)
do241save:              ;           0 10 do_241(xm)
    ld  (idx241),BC     ; 4:20      0 10 do_241(xm)
do241:                  ;           0 10 do_241(xm)
    push DE             ; 1:11      i_241(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_241(m)
    ld   HL, (idx241)   ; 3:16      i_241(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:33]      > +65278   _TMP_STACK_INFO #variant: hi == lo, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0xFE       ; 2:7        > +65278   HL>65278 --> 0>0xFE-L --> false if not carry
    cp    L             ; 1:4        > +65278   HL>65278 --> 0>0xFE-L --> false if not carry
    sbc   A, H          ; 1:4        > +65278   HL>65278 --> 0>0xFE-H --> false if not carry
    rra                 ; 1:4        > +65278
    xor   H             ; 1:4        > +65278   invert sign if HL is negative
    jp    m, else241    ; 3:10       > +65278   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif241       ; 3:10      else
else241:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif241:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_241(xm)   variant -1.A: step -1 and stop 0, run 11x
idx241 EQU $+1          ;           -1 +loop_241(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_241(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_241(xm)
    or    B             ; 1:4       -1 +loop_241(xm)
    dec  BC             ; 1:6       -1 +loop_241(xm)   index--
    jp   nz, do241save  ; 3:10      -1 +loop_241(xm)
leave241:               ;           -1 +loop_241(xm)
exit241:                ;           xloop LOOP_STACK
    ld   BC, string244  ; 3:10      print_i   Address of string244 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_242(xm)
do242save:              ;           0 10 do_242(xm)
    ld  (idx242),BC     ; 4:20      0 10 do_242(xm)
do242:                  ;           0 10 do_242(xm)
    push DE             ; 1:11      i_242(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_242(m)
    ld   HL, (idx242)   ; 3:16      i_242(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:47]      > +65278   _TMP_STACK_INFO variant: hi == lo
    ld    A, 0xFE       ; 2:7        > +65278   HL>65278 --> 0>0xFE-L
    cp    L             ; 1:4        > +65278   HL>65278 --> 0>0xFE-L
    sbc   A, H          ; 1:4        > +65278   HL>65278 --> 0>0xFE-H --> false if not carry
    rra                 ; 1:4        > +65278
    xor   H             ; 1:4        > +65278   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > +65278
    pop  DE             ; 1:10       > +65278
    jp    m, else242    ; 3:10       > +65278   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif242       ; 3:10      else
else242:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif242:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_242(xm)   variant -1.A: step -1 and stop 0, run 11x
idx242 EQU $+1          ;           -1 +loop_242(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_242(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_242(xm)
    or    B             ; 1:4       -1 +loop_242(xm)
    dec  BC             ; 1:6       -1 +loop_242(xm)   index--
    jp   nz, do242save  ; 3:10      -1 +loop_242(xm)
leave242:               ;           -1 +loop_242(xm)
exit242:                ;           xloop LOOP_STACK
    ld   BC, string244  ; 3:10      print_i   Address of string245 ending with inverted most significant bit == string244
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_243(xm)
do243save:              ;           0 10 do_243(xm)
    ld  (idx243),BC     ; 4:20      0 10 do_243(xm)
do243:                  ;           0 10 do_243(xm)
    push DE             ; 1:11      i_243(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_243(m)
    ld   HL, (idx243)   ; 3:16      i_243(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > xFEFE   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "xFEFE" cannot be evaluated
    ld    A, low xFEFE  ; 2:7        > xFEFE   HL>xFEFE --> 0>xFEFE-HL --> false if not carry
    sub   L             ; 1:4        > xFEFE   HL>xFEFE --> 0>xFEFE-HL --> false if not carry
    ld    A, high xFEFE ; 2:7        > xFEFE   HL>xFEFE --> 0>xFEFE-HL --> false if not carry
    sbc   A, H          ; 1:4        > xFEFE   HL>xFEFE --> 0>xFEFE-HL --> false if not carry
    rra                 ; 1:4        > xFEFE
    xor   H             ; 1:4        > xFEFE   invert sign if HL is negative
  if ((xFEFE)>=0x8000 || (xFEFE)<0)
    jp    m, else243    ; 3:10       > xFEFE   negative constant --> false if sign
  else
    jp    p, else243    ; 3:10       > xFEFE   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif243       ; 3:10      else
else243:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif243:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_243(xm)   variant -1.A: step -1 and stop 0, run 11x
idx243 EQU $+1          ;           -1 +loop_243(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_243(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_243(xm)
    or    B             ; 1:4       -1 +loop_243(xm)
    dec  BC             ; 1:6       -1 +loop_243(xm)   index--
    jp   nz, do243save  ; 3:10      -1 +loop_243(xm)
leave243:               ;           -1 +loop_243(xm)
exit243:                ;           xloop LOOP_STACK
    ld   BC, string246  ; 3:10      print_i   Address of string246 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_244(xm)
do244save:              ;           0 10 do_244(xm)
    ld  (idx244),BC     ; 4:20      0 10 do_244(xm)
do244:                  ;           0 10 do_244(xm)
    push DE             ; 1:11      i_244(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_244(m)
    ld   HL, (idx244)   ; 3:16      i_244(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > xFEFE   _TMP_STACK_INFO variant: variable
    ld    A, low xFEFE  ; 2:7        > xFEFE   HL>xFEFE --> 0>xFEFE-HL
    sub   L             ; 1:4        > xFEFE   HL>xFEFE --> 0>xFEFE-HL
    ld    A, high xFEFE ; 2:7        > xFEFE   HL>xFEFE --> 0>xFEFE-HL
    sbc   A, H          ; 1:4        > xFEFE   HL>xFEFE --> 0>xFEFE-HL --> false if not carry
    rra                 ; 1:4        > xFEFE
    xor   H             ; 1:4        > xFEFE   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > xFEFE
    pop  DE             ; 1:10       > xFEFE
  .warning The condition "xFEFE" cannot be evaluated
  if ((xFEFE)>=0x8000 || (xFEFE)<0)
    jp    m, else244    ; 3:10       > xFEFE
  else
    jp    p, else244    ; 3:10       > xFEFE
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif244       ; 3:10      else
else244:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif244:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_244(xm)   variant -1.A: step -1 and stop 0, run 11x
idx244 EQU $+1          ;           -1 +loop_244(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_244(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_244(xm)
    or    B             ; 1:4       -1 +loop_244(xm)
    dec  BC             ; 1:6       -1 +loop_244(xm)   index--
    jp   nz, do244save  ; 3:10      -1 +loop_244(xm)
leave244:               ;           -1 +loop_244(xm)
exit244:                ;           xloop LOOP_STACK
    ld   BC, string247  ; 3:10      print_i   Address of string247 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0xFEFF = 65279 ------
    ld   BC, 10         ; 3:10      0 10 do_245(xm)
do245save:              ;           0 10 do_245(xm)
    ld  (idx245),BC     ; 4:20      0 10 do_245(xm)
do245:                  ;           0 10 do_245(xm)
    push DE             ; 1:11      i_245(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_245(m)
    ld   HL, (idx245)   ; 3:16      i_245(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > +65279   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0xFF       ; 2:7        > +65279   HL>65279 --> 0>0xFF-L --> false if not carry
    sub   L             ; 1:4        > +65279   HL>65279 --> 0>0xFF-L --> false if not carry
    ld    A, 0xFE       ; 2:7        > +65279   HL>65279 --> 0>0xFE-H --> false if not carry
    sbc   A, H          ; 1:4        > +65279   HL>65279 --> 0>0xFE-H --> false if not carry
    rra                 ; 1:4        > +65279
    xor   H             ; 1:4        > +65279   invert sign if HL is negative
    jp    m, else245    ; 3:10       > +65279   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif245       ; 3:10      else
else245:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif245:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_245(xm)   variant -1.A: step -1 and stop 0, run 11x
idx245 EQU $+1          ;           -1 +loop_245(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_245(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_245(xm)
    or    B             ; 1:4       -1 +loop_245(xm)
    dec  BC             ; 1:6       -1 +loop_245(xm)   index--
    jp   nz, do245save  ; 3:10      -1 +loop_245(xm)
leave245:               ;           -1 +loop_245(xm)
exit245:                ;           xloop LOOP_STACK
    ld   BC, string248  ; 3:10      print_i   Address of string248 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_246(xm)
do246save:              ;           0 10 do_246(xm)
    ld  (idx246),BC     ; 4:20      0 10 do_246(xm)
do246:                  ;           0 10 do_246(xm)
    push DE             ; 1:11      i_246(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_246(m)
    ld   HL, (idx246)   ; 3:16      i_246(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > +65279   _TMP_STACK_INFO variant: default
    ld    A, 0xFF       ; 2:7        > +65279   HL>65279 --> 0>0xFF-L
    sub   L             ; 1:4        > +65279   HL>65279 --> 0>0xFF-L
    ld    A, 0xFE       ; 2:7        > +65279   HL>65279 --> 0>0xFE-H
    sbc   A, H          ; 1:4        > +65279   HL>65279 --> 0>0xFE-H --> false if not carry
    rra                 ; 1:4        > +65279
    xor   H             ; 1:4        > +65279   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > +65279
    pop  DE             ; 1:10       > +65279
    jp    m, else246    ; 3:10       > +65279   negative constant --> false if sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif246       ; 3:10      else
else246:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif246:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_246(xm)   variant -1.A: step -1 and stop 0, run 11x
idx246 EQU $+1          ;           -1 +loop_246(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_246(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_246(xm)
    or    B             ; 1:4       -1 +loop_246(xm)
    dec  BC             ; 1:6       -1 +loop_246(xm)   index--
    jp   nz, do246save  ; 3:10      -1 +loop_246(xm)
leave246:               ;           -1 +loop_246(xm)
exit246:                ;           xloop LOOP_STACK
    ld   BC, string248  ; 3:10      print_i   Address of string249 ending with inverted most significant bit == string248
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_247(xm)
do247save:              ;           0 10 do_247(xm)
    ld  (idx247),BC     ; 4:20      0 10 do_247(xm)
do247:                  ;           0 10 do_247(xm)
    push DE             ; 1:11      i_247(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_247(m)
    ld   HL, (idx247)   ; 3:16      i_247(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > xFEFF   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "xFEFF" cannot be evaluated
    ld    A, low xFEFF  ; 2:7        > xFEFF   HL>xFEFF --> 0>xFEFF-HL --> false if not carry
    sub   L             ; 1:4        > xFEFF   HL>xFEFF --> 0>xFEFF-HL --> false if not carry
    ld    A, high xFEFF ; 2:7        > xFEFF   HL>xFEFF --> 0>xFEFF-HL --> false if not carry
    sbc   A, H          ; 1:4        > xFEFF   HL>xFEFF --> 0>xFEFF-HL --> false if not carry
    rra                 ; 1:4        > xFEFF
    xor   H             ; 1:4        > xFEFF   invert sign if HL is negative
  if ((xFEFF)>=0x8000 || (xFEFF)<0)
    jp    m, else247    ; 3:10       > xFEFF   negative constant --> false if sign
  else
    jp    p, else247    ; 3:10       > xFEFF   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif247       ; 3:10      else
else247:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif247:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_247(xm)   variant -1.A: step -1 and stop 0, run 11x
idx247 EQU $+1          ;           -1 +loop_247(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_247(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_247(xm)
    or    B             ; 1:4       -1 +loop_247(xm)
    dec  BC             ; 1:6       -1 +loop_247(xm)   index--
    jp   nz, do247save  ; 3:10      -1 +loop_247(xm)
leave247:               ;           -1 +loop_247(xm)
exit247:                ;           xloop LOOP_STACK
    ld   BC, string250  ; 3:10      print_i   Address of string250 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_248(xm)
do248save:              ;           0 10 do_248(xm)
    ld  (idx248),BC     ; 4:20      0 10 do_248(xm)
do248:                  ;           0 10 do_248(xm)
    push DE             ; 1:11      i_248(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_248(m)
    ld   HL, (idx248)   ; 3:16      i_248(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > xFEFF   _TMP_STACK_INFO variant: variable
    ld    A, low xFEFF  ; 2:7        > xFEFF   HL>xFEFF --> 0>xFEFF-HL
    sub   L             ; 1:4        > xFEFF   HL>xFEFF --> 0>xFEFF-HL
    ld    A, high xFEFF ; 2:7        > xFEFF   HL>xFEFF --> 0>xFEFF-HL
    sbc   A, H          ; 1:4        > xFEFF   HL>xFEFF --> 0>xFEFF-HL --> false if not carry
    rra                 ; 1:4        > xFEFF
    xor   H             ; 1:4        > xFEFF   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > xFEFF
    pop  DE             ; 1:10       > xFEFF
  .warning The condition "xFEFF" cannot be evaluated
  if ((xFEFF)>=0x8000 || (xFEFF)<0)
    jp    m, else248    ; 3:10       > xFEFF
  else
    jp    p, else248    ; 3:10       > xFEFF
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif248       ; 3:10      else
else248:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif248:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_248(xm)   variant -1.A: step -1 and stop 0, run 11x
idx248 EQU $+1          ;           -1 +loop_248(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_248(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_248(xm)
    or    B             ; 1:4       -1 +loop_248(xm)
    dec  BC             ; 1:6       -1 +loop_248(xm)   index--
    jp   nz, do248save  ; 3:10      -1 +loop_248(xm)
leave248:               ;           -1 +loop_248(xm)
exit248:                ;           xloop LOOP_STACK
    ld   BC, string251  ; 3:10      print_i   Address of string251 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- -1 ------
    ld   BC, 10         ; 3:10      0 10 do_249(xm)
do249save:              ;           0 10 do_249(xm)
    ld  (idx249),BC     ; 4:20      0 10 do_249(xm)
do249:                  ;           0 10 do_249(xm)
    push DE             ; 1:11      i_249(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_249(m)
    ld   HL, (idx249)   ; 3:16      i_249(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[5:18]      > -1   _TMP_STACK_INFO variant: >-1
    bit   7, H          ; 2:8        > -1
    jp   nz, else249    ; 3:10       > -1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif249       ; 3:10      else
else249:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif249:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_249(xm)   variant -1.A: step -1 and stop 0, run 11x
idx249 EQU $+1          ;           -1 +loop_249(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_249(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_249(xm)
    or    B             ; 1:4       -1 +loop_249(xm)
    dec  BC             ; 1:6       -1 +loop_249(xm)   index--
    jp   nz, do249save  ; 3:10      -1 +loop_249(xm)
leave249:               ;           -1 +loop_249(xm)
exit249:                ;           xloop LOOP_STACK
    ld   BC, string252  ; 3:10      print_i   Address of string252 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_250(xm)
do250save:              ;           0 10 do_250(xm)
    ld  (idx250),BC     ; 4:20      0 10 do_250(xm)
do250:                  ;           0 10 do_250(xm)
    push DE             ; 1:11      i_250(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_250(m)
    ld   HL, (idx250)   ; 3:16      i_250(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:32]      > -1   _TMP_STACK_INFO variant: -1
    rl    H             ; 2:8        > -1   HL>-1 --> sign if false
    ex   DE, HL         ; 1:4        > -1
    pop  DE             ; 1:10       > -1
    jp    c, else250    ; 3:10       > -1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif250       ; 3:10      else
else250:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif250:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_250(xm)   variant -1.A: step -1 and stop 0, run 11x
idx250 EQU $+1          ;           -1 +loop_250(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_250(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_250(xm)
    or    B             ; 1:4       -1 +loop_250(xm)
    dec  BC             ; 1:6       -1 +loop_250(xm)   index--
    jp   nz, do250save  ; 3:10      -1 +loop_250(xm)
leave250:               ;           -1 +loop_250(xm)
exit250:                ;           xloop LOOP_STACK
    ld   BC, string252  ; 3:10      print_i   Address of string253 ending with inverted most significant bit == string252
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_251(xm)
do251save:              ;           0 10 do_251(xm)
    ld  (idx251),BC     ; 4:20      0 10 do_251(xm)
do251:                  ;           0 10 do_251(xm)
    push DE             ; 1:11      i_251(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_251(m)
    ld   HL, (idx251)   ; 3:16      i_251(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > m1   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "m1" cannot be evaluated
    ld    A, low m1     ; 2:7        > m1   HL>m1 --> 0>m1-HL --> false if not carry
    sub   L             ; 1:4        > m1   HL>m1 --> 0>m1-HL --> false if not carry
    ld    A, high m1    ; 2:7        > m1   HL>m1 --> 0>m1-HL --> false if not carry
    sbc   A, H          ; 1:4        > m1   HL>m1 --> 0>m1-HL --> false if not carry
    rra                 ; 1:4        > m1
    xor   H             ; 1:4        > m1   invert sign if HL is negative
  if ((m1)>=0x8000 || (m1)<0)
    jp    m, else251    ; 3:10       > m1   negative constant --> false if sign
  else
    jp    p, else251    ; 3:10       > m1   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif251       ; 3:10      else
else251:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif251:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_251(xm)   variant -1.A: step -1 and stop 0, run 11x
idx251 EQU $+1          ;           -1 +loop_251(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_251(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_251(xm)
    or    B             ; 1:4       -1 +loop_251(xm)
    dec  BC             ; 1:6       -1 +loop_251(xm)   index--
    jp   nz, do251save  ; 3:10      -1 +loop_251(xm)
leave251:               ;           -1 +loop_251(xm)
exit251:                ;           xloop LOOP_STACK
    ld   BC, string254  ; 3:10      print_i   Address of string254 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_252(xm)
do252save:              ;           0 10 do_252(xm)
    ld  (idx252),BC     ; 4:20      0 10 do_252(xm)
do252:                  ;           0 10 do_252(xm)
    push DE             ; 1:11      i_252(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_252(m)
    ld   HL, (idx252)   ; 3:16      i_252(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > m1   _TMP_STACK_INFO variant: variable
    ld    A, low m1     ; 2:7        > m1   HL>m1 --> 0>m1-HL
    sub   L             ; 1:4        > m1   HL>m1 --> 0>m1-HL
    ld    A, high m1    ; 2:7        > m1   HL>m1 --> 0>m1-HL
    sbc   A, H          ; 1:4        > m1   HL>m1 --> 0>m1-HL --> false if not carry
    rra                 ; 1:4        > m1
    xor   H             ; 1:4        > m1   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > m1
    pop  DE             ; 1:10       > m1
  .warning The condition "m1" cannot be evaluated
  if ((m1)>=0x8000 || (m1)<0)
    jp    m, else252    ; 3:10       > m1
  else
    jp    p, else252    ; 3:10       > m1
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif252       ; 3:10      else
else252:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif252:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_252(xm)   variant -1.A: step -1 and stop 0, run 11x
idx252 EQU $+1          ;           -1 +loop_252(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_252(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_252(xm)
    or    B             ; 1:4       -1 +loop_252(xm)
    dec  BC             ; 1:6       -1 +loop_252(xm)   index--
    jp   nz, do252save  ; 3:10      -1 +loop_252(xm)
leave252:               ;           -1 +loop_252(xm)
exit252:                ;           xloop LOOP_STACK
    ld   BC, string255  ; 3:10      print_i   Address of string255 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0 ------
    ld   BC, 10         ; 3:10      0 10 do_253(xm)
do253save:              ;           0 10 do_253(xm)
    ld  (idx253),BC     ; 4:20      0 10 do_253(xm)
do253:                  ;           0 10 do_253(xm)
    push DE             ; 1:11      i_253(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_253(m)
    ld   HL, (idx253)   ; 3:16      i_253(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:30]      > 0   _TMP_STACK_INFO variant: >0
    ld    A, H          ; 1:4        > 0   save sign
    dec  HL             ; 1:6        > 0   zero to negative
    or    H             ; 1:4        > 0
    inc  HL             ; 1:6        > 0
    jp    m, else253    ; 3:10       > 0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif253       ; 3:10      else
else253:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif253:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_253(xm)   variant -1.A: step -1 and stop 0, run 11x
idx253 EQU $+1          ;           -1 +loop_253(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_253(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_253(xm)
    or    B             ; 1:4       -1 +loop_253(xm)
    dec  BC             ; 1:6       -1 +loop_253(xm)   index--
    jp   nz, do253save  ; 3:10      -1 +loop_253(xm)
leave253:               ;           -1 +loop_253(xm)
exit253:                ;           xloop LOOP_STACK
    ld   BC, string256  ; 3:10      print_i   Address of string256 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_254(xm)
do254save:              ;           0 10 do_254(xm)
    ld  (idx254),BC     ; 4:20      0 10 do_254(xm)
do254:                  ;           0 10 do_254(xm)
    push DE             ; 1:11      i_254(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_254(m)
    ld   HL, (idx254)   ; 3:16      i_254(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[8:38]      > 0   _TMP_STACK_INFO variant: 0
    ld    A, H          ; 1:4        > 0   HL>=0          --> sign if false
    dec  HL             ; 1:6        > 0   HL>-1          --> sign if false
    or    H             ; 1:4        > 0   HL>=0 && HL>-1 --> sign if false
    ex   DE, HL         ; 1:4        > 0
    pop  DE             ; 1:10       > 0
    jp    m, else254    ; 3:10       > 0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif254       ; 3:10      else
else254:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif254:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_254(xm)   variant -1.A: step -1 and stop 0, run 11x
idx254 EQU $+1          ;           -1 +loop_254(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_254(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_254(xm)
    or    B             ; 1:4       -1 +loop_254(xm)
    dec  BC             ; 1:6       -1 +loop_254(xm)   index--
    jp   nz, do254save  ; 3:10      -1 +loop_254(xm)
leave254:               ;           -1 +loop_254(xm)
exit254:                ;           xloop LOOP_STACK
    ld   BC, string256  ; 3:10      print_i   Address of string257 ending with inverted most significant bit == string256
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_255(xm)
do255save:              ;           0 10 do_255(xm)
    ld  (idx255),BC     ; 4:20      0 10 do_255(xm)
do255:                  ;           0 10 do_255(xm)
    push DE             ; 1:11      i_255(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_255(m)
    ld   HL, (idx255)   ; 3:16      i_255(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > zero   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "zero" cannot be evaluated
    ld    A, low zero   ; 2:7        > zero   HL>zero --> 0>zero-HL --> false if not carry
    sub   L             ; 1:4        > zero   HL>zero --> 0>zero-HL --> false if not carry
    ld    A, high zero  ; 2:7        > zero   HL>zero --> 0>zero-HL --> false if not carry
    sbc   A, H          ; 1:4        > zero   HL>zero --> 0>zero-HL --> false if not carry
    rra                 ; 1:4        > zero
    xor   H             ; 1:4        > zero   invert sign if HL is negative
  if ((zero)>=0x8000 || (zero)<0)
    jp    m, else255    ; 3:10       > zero   negative constant --> false if sign
  else
    jp    p, else255    ; 3:10       > zero   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif255       ; 3:10      else
else255:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif255:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_255(xm)   variant -1.A: step -1 and stop 0, run 11x
idx255 EQU $+1          ;           -1 +loop_255(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_255(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_255(xm)
    or    B             ; 1:4       -1 +loop_255(xm)
    dec  BC             ; 1:6       -1 +loop_255(xm)   index--
    jp   nz, do255save  ; 3:10      -1 +loop_255(xm)
leave255:               ;           -1 +loop_255(xm)
exit255:                ;           xloop LOOP_STACK
    ld   BC, string258  ; 3:10      print_i   Address of string258 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_256(xm)
do256save:              ;           0 10 do_256(xm)
    ld  (idx256),BC     ; 4:20      0 10 do_256(xm)
do256:                  ;           0 10 do_256(xm)
    push DE             ; 1:11      i_256(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_256(m)
    ld   HL, (idx256)   ; 3:16      i_256(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > zero   _TMP_STACK_INFO variant: variable
    ld    A, low zero   ; 2:7        > zero   HL>zero --> 0>zero-HL
    sub   L             ; 1:4        > zero   HL>zero --> 0>zero-HL
    ld    A, high zero  ; 2:7        > zero   HL>zero --> 0>zero-HL
    sbc   A, H          ; 1:4        > zero   HL>zero --> 0>zero-HL --> false if not carry
    rra                 ; 1:4        > zero
    xor   H             ; 1:4        > zero   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > zero
    pop  DE             ; 1:10       > zero
  .warning The condition "zero" cannot be evaluated
  if ((zero)>=0x8000 || (zero)<0)
    jp    m, else256    ; 3:10       > zero
  else
    jp    p, else256    ; 3:10       > zero
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif256       ; 3:10      else
else256:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif256:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_256(xm)   variant -1.A: step -1 and stop 0, run 11x
idx256 EQU $+1          ;           -1 +loop_256(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_256(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_256(xm)
    or    B             ; 1:4       -1 +loop_256(xm)
    dec  BC             ; 1:6       -1 +loop_256(xm)   index--
    jp   nz, do256save  ; 3:10      -1 +loop_256(xm)
leave256:               ;           -1 +loop_256(xm)
exit256:                ;           xloop LOOP_STACK
    ld   BC, string259  ; 3:10      print_i   Address of string259 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 1 ------
    ld   BC, 10         ; 3:10      0 10 do_257(xm)
do257save:              ;           0 10 do_257(xm)
    ld  (idx257),BC     ; 4:20      0 10 do_257(xm)
do257:                  ;           0 10 do_257(xm)
    push DE             ; 1:11      i_257(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_257(m)
    ld   HL, (idx257)   ; 3:16      i_257(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > +1   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0x01       ; 2:7        > +1   HL>1 --> 0>0x01-L --> false if not carry
    sub   L             ; 1:4        > +1   HL>1 --> 0>0x01-L --> false if not carry
    ld    A, 0x00       ; 2:7        > +1   HL>1 --> 0>0x00-H --> false if not carry
    sbc   A, H          ; 1:4        > +1   HL>1 --> 0>0x00-H --> false if not carry
    rra                 ; 1:4        > +1
    xor   H             ; 1:4        > +1   invert sign if HL is negative
    jp    p, else257    ; 3:10       > +1   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif257       ; 3:10      else
else257:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif257:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_257(xm)   variant -1.A: step -1 and stop 0, run 11x
idx257 EQU $+1          ;           -1 +loop_257(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_257(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_257(xm)
    or    B             ; 1:4       -1 +loop_257(xm)
    dec  BC             ; 1:6       -1 +loop_257(xm)   index--
    jp   nz, do257save  ; 3:10      -1 +loop_257(xm)
leave257:               ;           -1 +loop_257(xm)
exit257:                ;           xloop LOOP_STACK
    ld   BC, string260  ; 3:10      print_i   Address of string260 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_258(xm)
do258save:              ;           0 10 do_258(xm)
    ld  (idx258),BC     ; 4:20      0 10 do_258(xm)
do258:                  ;           0 10 do_258(xm)
    push DE             ; 1:11      i_258(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_258(m)
    ld   HL, (idx258)   ; 3:16      i_258(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > +1   _TMP_STACK_INFO variant: default
    ld    A, 0x01       ; 2:7        > +1   HL>1 --> 0>0x01-L
    sub   L             ; 1:4        > +1   HL>1 --> 0>0x01-L
    ld    A, 0x00       ; 2:7        > +1   HL>1 --> 0>0x00-H
    sbc   A, H          ; 1:4        > +1   HL>1 --> 0>0x00-H --> false if not carry
    rra                 ; 1:4        > +1
    xor   H             ; 1:4        > +1   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > +1
    pop  DE             ; 1:10       > +1
    jp    p, else258    ; 3:10       > +1   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif258       ; 3:10      else
else258:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif258:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_258(xm)   variant -1.A: step -1 and stop 0, run 11x
idx258 EQU $+1          ;           -1 +loop_258(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_258(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_258(xm)
    or    B             ; 1:4       -1 +loop_258(xm)
    dec  BC             ; 1:6       -1 +loop_258(xm)   index--
    jp   nz, do258save  ; 3:10      -1 +loop_258(xm)
leave258:               ;           -1 +loop_258(xm)
exit258:                ;           xloop LOOP_STACK
    ld   BC, string260  ; 3:10      print_i   Address of string261 ending with inverted most significant bit == string260
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_259(xm)
do259save:              ;           0 10 do_259(xm)
    ld  (idx259),BC     ; 4:20      0 10 do_259(xm)
do259:                  ;           0 10 do_259(xm)
    push DE             ; 1:11      i_259(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_259(m)
    ld   HL, (idx259)   ; 3:16      i_259(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > p1   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "p1" cannot be evaluated
    ld    A, low p1     ; 2:7        > p1   HL>p1 --> 0>p1-HL --> false if not carry
    sub   L             ; 1:4        > p1   HL>p1 --> 0>p1-HL --> false if not carry
    ld    A, high p1    ; 2:7        > p1   HL>p1 --> 0>p1-HL --> false if not carry
    sbc   A, H          ; 1:4        > p1   HL>p1 --> 0>p1-HL --> false if not carry
    rra                 ; 1:4        > p1
    xor   H             ; 1:4        > p1   invert sign if HL is negative
  if ((p1)>=0x8000 || (p1)<0)
    jp    m, else259    ; 3:10       > p1   negative constant --> false if sign
  else
    jp    p, else259    ; 3:10       > p1   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif259       ; 3:10      else
else259:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif259:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_259(xm)   variant -1.A: step -1 and stop 0, run 11x
idx259 EQU $+1          ;           -1 +loop_259(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_259(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_259(xm)
    or    B             ; 1:4       -1 +loop_259(xm)
    dec  BC             ; 1:6       -1 +loop_259(xm)   index--
    jp   nz, do259save  ; 3:10      -1 +loop_259(xm)
leave259:               ;           -1 +loop_259(xm)
exit259:                ;           xloop LOOP_STACK
    ld   BC, string262  ; 3:10      print_i   Address of string262 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_260(xm)
do260save:              ;           0 10 do_260(xm)
    ld  (idx260),BC     ; 4:20      0 10 do_260(xm)
do260:                  ;           0 10 do_260(xm)
    push DE             ; 1:11      i_260(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_260(m)
    ld   HL, (idx260)   ; 3:16      i_260(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > p1   _TMP_STACK_INFO variant: variable
    ld    A, low p1     ; 2:7        > p1   HL>p1 --> 0>p1-HL
    sub   L             ; 1:4        > p1   HL>p1 --> 0>p1-HL
    ld    A, high p1    ; 2:7        > p1   HL>p1 --> 0>p1-HL
    sbc   A, H          ; 1:4        > p1   HL>p1 --> 0>p1-HL --> false if not carry
    rra                 ; 1:4        > p1
    xor   H             ; 1:4        > p1   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > p1
    pop  DE             ; 1:10       > p1
  .warning The condition "p1" cannot be evaluated
  if ((p1)>=0x8000 || (p1)<0)
    jp    m, else260    ; 3:10       > p1
  else
    jp    p, else260    ; 3:10       > p1
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif260       ; 3:10      else
else260:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif260:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_260(xm)   variant -1.A: step -1 and stop 0, run 11x
idx260 EQU $+1          ;           -1 +loop_260(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_260(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_260(xm)
    or    B             ; 1:4       -1 +loop_260(xm)
    dec  BC             ; 1:6       -1 +loop_260(xm)   index--
    jp   nz, do260save  ; 3:10      -1 +loop_260(xm)
leave260:               ;           -1 +loop_260(xm)
exit260:                ;           xloop LOOP_STACK
    ld   BC, string263  ; 3:10      print_i   Address of string263 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3332 = 13106 ------
    ld   BC, 10         ; 3:10      0 10 do_261(xm)
do261save:              ;           0 10 do_261(xm)
    ld  (idx261),BC     ; 4:20      0 10 do_261(xm)
do261:                  ;           0 10 do_261(xm)
    push DE             ; 1:11      i_261(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_261(m)
    ld   HL, (idx261)   ; 3:16      i_261(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > +13106   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0x32       ; 2:7        > +13106   HL>13106 --> 0>0x32-L --> false if not carry
    sub   L             ; 1:4        > +13106   HL>13106 --> 0>0x32-L --> false if not carry
    ld    A, 0x33       ; 2:7        > +13106   HL>13106 --> 0>0x33-H --> false if not carry
    sbc   A, H          ; 1:4        > +13106   HL>13106 --> 0>0x33-H --> false if not carry
    rra                 ; 1:4        > +13106
    xor   H             ; 1:4        > +13106   invert sign if HL is negative
    jp    p, else261    ; 3:10       > +13106   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif261       ; 3:10      else
else261:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif261:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_261(xm)   variant -1.A: step -1 and stop 0, run 11x
idx261 EQU $+1          ;           -1 +loop_261(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_261(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_261(xm)
    or    B             ; 1:4       -1 +loop_261(xm)
    dec  BC             ; 1:6       -1 +loop_261(xm)   index--
    jp   nz, do261save  ; 3:10      -1 +loop_261(xm)
leave261:               ;           -1 +loop_261(xm)
exit261:                ;           xloop LOOP_STACK
    ld   BC, string264  ; 3:10      print_i   Address of string264 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_262(xm)
do262save:              ;           0 10 do_262(xm)
    ld  (idx262),BC     ; 4:20      0 10 do_262(xm)
do262:                  ;           0 10 do_262(xm)
    push DE             ; 1:11      i_262(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_262(m)
    ld   HL, (idx262)   ; 3:16      i_262(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > +13106   _TMP_STACK_INFO variant: default
    ld    A, 0x32       ; 2:7        > +13106   HL>13106 --> 0>0x32-L
    sub   L             ; 1:4        > +13106   HL>13106 --> 0>0x32-L
    ld    A, 0x33       ; 2:7        > +13106   HL>13106 --> 0>0x33-H
    sbc   A, H          ; 1:4        > +13106   HL>13106 --> 0>0x33-H --> false if not carry
    rra                 ; 1:4        > +13106
    xor   H             ; 1:4        > +13106   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > +13106
    pop  DE             ; 1:10       > +13106
    jp    p, else262    ; 3:10       > +13106   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif262       ; 3:10      else
else262:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif262:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_262(xm)   variant -1.A: step -1 and stop 0, run 11x
idx262 EQU $+1          ;           -1 +loop_262(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_262(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_262(xm)
    or    B             ; 1:4       -1 +loop_262(xm)
    dec  BC             ; 1:6       -1 +loop_262(xm)   index--
    jp   nz, do262save  ; 3:10      -1 +loop_262(xm)
leave262:               ;           -1 +loop_262(xm)
exit262:                ;           xloop LOOP_STACK
    ld   BC, string264  ; 3:10      print_i   Address of string265 ending with inverted most significant bit == string264
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_263(xm)
do263save:              ;           0 10 do_263(xm)
    ld  (idx263),BC     ; 4:20      0 10 do_263(xm)
do263:                  ;           0 10 do_263(xm)
    push DE             ; 1:11      i_263(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_263(m)
    ld   HL, (idx263)   ; 3:16      i_263(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > x3332   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "x3332" cannot be evaluated
    ld    A, low x3332  ; 2:7        > x3332   HL>x3332 --> 0>x3332-HL --> false if not carry
    sub   L             ; 1:4        > x3332   HL>x3332 --> 0>x3332-HL --> false if not carry
    ld    A, high x3332 ; 2:7        > x3332   HL>x3332 --> 0>x3332-HL --> false if not carry
    sbc   A, H          ; 1:4        > x3332   HL>x3332 --> 0>x3332-HL --> false if not carry
    rra                 ; 1:4        > x3332
    xor   H             ; 1:4        > x3332   invert sign if HL is negative
  if ((x3332)>=0x8000 || (x3332)<0)
    jp    m, else263    ; 3:10       > x3332   negative constant --> false if sign
  else
    jp    p, else263    ; 3:10       > x3332   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif263       ; 3:10      else
else263:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif263:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_263(xm)   variant -1.A: step -1 and stop 0, run 11x
idx263 EQU $+1          ;           -1 +loop_263(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_263(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_263(xm)
    or    B             ; 1:4       -1 +loop_263(xm)
    dec  BC             ; 1:6       -1 +loop_263(xm)   index--
    jp   nz, do263save  ; 3:10      -1 +loop_263(xm)
leave263:               ;           -1 +loop_263(xm)
exit263:                ;           xloop LOOP_STACK
    ld   BC, string266  ; 3:10      print_i   Address of string266 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_264(xm)
do264save:              ;           0 10 do_264(xm)
    ld  (idx264),BC     ; 4:20      0 10 do_264(xm)
do264:                  ;           0 10 do_264(xm)
    push DE             ; 1:11      i_264(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_264(m)
    ld   HL, (idx264)   ; 3:16      i_264(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > x3332   _TMP_STACK_INFO variant: variable
    ld    A, low x3332  ; 2:7        > x3332   HL>x3332 --> 0>x3332-HL
    sub   L             ; 1:4        > x3332   HL>x3332 --> 0>x3332-HL
    ld    A, high x3332 ; 2:7        > x3332   HL>x3332 --> 0>x3332-HL
    sbc   A, H          ; 1:4        > x3332   HL>x3332 --> 0>x3332-HL --> false if not carry
    rra                 ; 1:4        > x3332
    xor   H             ; 1:4        > x3332   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > x3332
    pop  DE             ; 1:10       > x3332
  .warning The condition "x3332" cannot be evaluated
  if ((x3332)>=0x8000 || (x3332)<0)
    jp    m, else264    ; 3:10       > x3332
  else
    jp    p, else264    ; 3:10       > x3332
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif264       ; 3:10      else
else264:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif264:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_264(xm)   variant -1.A: step -1 and stop 0, run 11x
idx264 EQU $+1          ;           -1 +loop_264(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_264(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_264(xm)
    or    B             ; 1:4       -1 +loop_264(xm)
    dec  BC             ; 1:6       -1 +loop_264(xm)   index--
    jp   nz, do264save  ; 3:10      -1 +loop_264(xm)
leave264:               ;           -1 +loop_264(xm)
exit264:                ;           xloop LOOP_STACK
    ld   BC, string267  ; 3:10      print_i   Address of string267 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3333 = 13107 ------
    ld   BC, 10         ; 3:10      0 10 do_265(xm)
do265save:              ;           0 10 do_265(xm)
    ld  (idx265),BC     ; 4:20      0 10 do_265(xm)
do265:                  ;           0 10 do_265(xm)
    push DE             ; 1:11      i_265(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_265(m)
    ld   HL, (idx265)   ; 3:16      i_265(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:33]      > +13107   _TMP_STACK_INFO #variant: hi == lo, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0x33       ; 2:7        > +13107   HL>13107 --> 0>0x33-L --> false if not carry
    cp    L             ; 1:4        > +13107   HL>13107 --> 0>0x33-L --> false if not carry
    sbc   A, H          ; 1:4        > +13107   HL>13107 --> 0>0x33-H --> false if not carry
    rra                 ; 1:4        > +13107
    xor   H             ; 1:4        > +13107   invert sign if HL is negative
    jp    p, else265    ; 3:10       > +13107   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif265       ; 3:10      else
else265:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif265:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_265(xm)   variant -1.A: step -1 and stop 0, run 11x
idx265 EQU $+1          ;           -1 +loop_265(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_265(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_265(xm)
    or    B             ; 1:4       -1 +loop_265(xm)
    dec  BC             ; 1:6       -1 +loop_265(xm)   index--
    jp   nz, do265save  ; 3:10      -1 +loop_265(xm)
leave265:               ;           -1 +loop_265(xm)
exit265:                ;           xloop LOOP_STACK
    ld   BC, string268  ; 3:10      print_i   Address of string268 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_266(xm)
do266save:              ;           0 10 do_266(xm)
    ld  (idx266),BC     ; 4:20      0 10 do_266(xm)
do266:                  ;           0 10 do_266(xm)
    push DE             ; 1:11      i_266(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_266(m)
    ld   HL, (idx266)   ; 3:16      i_266(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:47]      > +13107   _TMP_STACK_INFO variant: hi == lo
    ld    A, 0x33       ; 2:7        > +13107   HL>13107 --> 0>0x33-L
    cp    L             ; 1:4        > +13107   HL>13107 --> 0>0x33-L
    sbc   A, H          ; 1:4        > +13107   HL>13107 --> 0>0x33-H --> false if not carry
    rra                 ; 1:4        > +13107
    xor   H             ; 1:4        > +13107   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > +13107
    pop  DE             ; 1:10       > +13107
    jp    p, else266    ; 3:10       > +13107   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif266       ; 3:10      else
else266:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif266:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_266(xm)   variant -1.A: step -1 and stop 0, run 11x
idx266 EQU $+1          ;           -1 +loop_266(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_266(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_266(xm)
    or    B             ; 1:4       -1 +loop_266(xm)
    dec  BC             ; 1:6       -1 +loop_266(xm)   index--
    jp   nz, do266save  ; 3:10      -1 +loop_266(xm)
leave266:               ;           -1 +loop_266(xm)
exit266:                ;           xloop LOOP_STACK
    ld   BC, string268  ; 3:10      print_i   Address of string269 ending with inverted most significant bit == string268
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_267(xm)
do267save:              ;           0 10 do_267(xm)
    ld  (idx267),BC     ; 4:20      0 10 do_267(xm)
do267:                  ;           0 10 do_267(xm)
    push DE             ; 1:11      i_267(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_267(m)
    ld   HL, (idx267)   ; 3:16      i_267(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > x3333   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "x3333" cannot be evaluated
    ld    A, low x3333  ; 2:7        > x3333   HL>x3333 --> 0>x3333-HL --> false if not carry
    sub   L             ; 1:4        > x3333   HL>x3333 --> 0>x3333-HL --> false if not carry
    ld    A, high x3333 ; 2:7        > x3333   HL>x3333 --> 0>x3333-HL --> false if not carry
    sbc   A, H          ; 1:4        > x3333   HL>x3333 --> 0>x3333-HL --> false if not carry
    rra                 ; 1:4        > x3333
    xor   H             ; 1:4        > x3333   invert sign if HL is negative
  if ((x3333)>=0x8000 || (x3333)<0)
    jp    m, else267    ; 3:10       > x3333   negative constant --> false if sign
  else
    jp    p, else267    ; 3:10       > x3333   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif267       ; 3:10      else
else267:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif267:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_267(xm)   variant -1.A: step -1 and stop 0, run 11x
idx267 EQU $+1          ;           -1 +loop_267(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_267(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_267(xm)
    or    B             ; 1:4       -1 +loop_267(xm)
    dec  BC             ; 1:6       -1 +loop_267(xm)   index--
    jp   nz, do267save  ; 3:10      -1 +loop_267(xm)
leave267:               ;           -1 +loop_267(xm)
exit267:                ;           xloop LOOP_STACK
    ld   BC, string270  ; 3:10      print_i   Address of string270 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_268(xm)
do268save:              ;           0 10 do_268(xm)
    ld  (idx268),BC     ; 4:20      0 10 do_268(xm)
do268:                  ;           0 10 do_268(xm)
    push DE             ; 1:11      i_268(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_268(m)
    ld   HL, (idx268)   ; 3:16      i_268(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > x3333   _TMP_STACK_INFO variant: variable
    ld    A, low x3333  ; 2:7        > x3333   HL>x3333 --> 0>x3333-HL
    sub   L             ; 1:4        > x3333   HL>x3333 --> 0>x3333-HL
    ld    A, high x3333 ; 2:7        > x3333   HL>x3333 --> 0>x3333-HL
    sbc   A, H          ; 1:4        > x3333   HL>x3333 --> 0>x3333-HL --> false if not carry
    rra                 ; 1:4        > x3333
    xor   H             ; 1:4        > x3333   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > x3333
    pop  DE             ; 1:10       > x3333
  .warning The condition "x3333" cannot be evaluated
  if ((x3333)>=0x8000 || (x3333)<0)
    jp    m, else268    ; 3:10       > x3333
  else
    jp    p, else268    ; 3:10       > x3333
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif268       ; 3:10      else
else268:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif268:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_268(xm)   variant -1.A: step -1 and stop 0, run 11x
idx268 EQU $+1          ;           -1 +loop_268(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_268(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_268(xm)
    or    B             ; 1:4       -1 +loop_268(xm)
    dec  BC             ; 1:6       -1 +loop_268(xm)   index--
    jp   nz, do268save  ; 3:10      -1 +loop_268(xm)
leave268:               ;           -1 +loop_268(xm)
exit268:                ;           xloop LOOP_STACK
    ld   BC, string271  ; 3:10      print_i   Address of string271 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3334 = 13108 ------
    ld   BC, 10         ; 3:10      0 10 do_269(xm)
do269save:              ;           0 10 do_269(xm)
    ld  (idx269),BC     ; 4:20      0 10 do_269(xm)
do269:                  ;           0 10 do_269(xm)
    push DE             ; 1:11      i_269(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_269(m)
    ld   HL, (idx269)   ; 3:16      i_269(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > +13108   _TMP_STACK_INFO #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0x34       ; 2:7        > +13108   HL>13108 --> 0>0x34-L --> false if not carry
    sub   L             ; 1:4        > +13108   HL>13108 --> 0>0x34-L --> false if not carry
    ld    A, 0x33       ; 2:7        > +13108   HL>13108 --> 0>0x33-H --> false if not carry
    sbc   A, H          ; 1:4        > +13108   HL>13108 --> 0>0x33-H --> false if not carry
    rra                 ; 1:4        > +13108
    xor   H             ; 1:4        > +13108   invert sign if HL is negative
    jp    p, else269    ; 3:10       > +13108   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif269       ; 3:10      else
else269:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif269:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_269(xm)   variant -1.A: step -1 and stop 0, run 11x
idx269 EQU $+1          ;           -1 +loop_269(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_269(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_269(xm)
    or    B             ; 1:4       -1 +loop_269(xm)
    dec  BC             ; 1:6       -1 +loop_269(xm)   index--
    jp   nz, do269save  ; 3:10      -1 +loop_269(xm)
leave269:               ;           -1 +loop_269(xm)
exit269:                ;           xloop LOOP_STACK
    ld   BC, string272  ; 3:10      print_i   Address of string272 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_270(xm)
do270save:              ;           0 10 do_270(xm)
    ld  (idx270),BC     ; 4:20      0 10 do_270(xm)
do270:                  ;           0 10 do_270(xm)
    push DE             ; 1:11      i_270(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_270(m)
    ld   HL, (idx270)   ; 3:16      i_270(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > +13108   _TMP_STACK_INFO variant: default
    ld    A, 0x34       ; 2:7        > +13108   HL>13108 --> 0>0x34-L
    sub   L             ; 1:4        > +13108   HL>13108 --> 0>0x34-L
    ld    A, 0x33       ; 2:7        > +13108   HL>13108 --> 0>0x33-H
    sbc   A, H          ; 1:4        > +13108   HL>13108 --> 0>0x33-H --> false if not carry
    rra                 ; 1:4        > +13108
    xor   H             ; 1:4        > +13108   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > +13108
    pop  DE             ; 1:10       > +13108
    jp    p, else270    ; 3:10       > +13108   positive constant --> false if not sign
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif270       ; 3:10      else
else270:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif270:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_270(xm)   variant -1.A: step -1 and stop 0, run 11x
idx270 EQU $+1          ;           -1 +loop_270(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_270(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_270(xm)
    or    B             ; 1:4       -1 +loop_270(xm)
    dec  BC             ; 1:6       -1 +loop_270(xm)   index--
    jp   nz, do270save  ; 3:10      -1 +loop_270(xm)
leave270:               ;           -1 +loop_270(xm)
exit270:                ;           xloop LOOP_STACK
    ld   BC, string272  ; 3:10      print_i   Address of string273 ending with inverted most significant bit == string272
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_271(xm)
do271save:              ;           0 10 do_271(xm)
    ld  (idx271),BC     ; 4:20      0 10 do_271(xm)
do271:                  ;           0 10 do_271(xm)
    push DE             ; 1:11      i_271(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_271(m)
    ld   HL, (idx271)   ; 3:16      i_271(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > x3334   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "x3334" cannot be evaluated
    ld    A, low x3334  ; 2:7        > x3334   HL>x3334 --> 0>x3334-HL --> false if not carry
    sub   L             ; 1:4        > x3334   HL>x3334 --> 0>x3334-HL --> false if not carry
    ld    A, high x3334 ; 2:7        > x3334   HL>x3334 --> 0>x3334-HL --> false if not carry
    sbc   A, H          ; 1:4        > x3334   HL>x3334 --> 0>x3334-HL --> false if not carry
    rra                 ; 1:4        > x3334
    xor   H             ; 1:4        > x3334   invert sign if HL is negative
  if ((x3334)>=0x8000 || (x3334)<0)
    jp    m, else271    ; 3:10       > x3334   negative constant --> false if sign
  else
    jp    p, else271    ; 3:10       > x3334   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif271       ; 3:10      else
else271:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif271:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_271(xm)   variant -1.A: step -1 and stop 0, run 11x
idx271 EQU $+1          ;           -1 +loop_271(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_271(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_271(xm)
    or    B             ; 1:4       -1 +loop_271(xm)
    dec  BC             ; 1:6       -1 +loop_271(xm)   index--
    jp   nz, do271save  ; 3:10      -1 +loop_271(xm)
leave271:               ;           -1 +loop_271(xm)
exit271:                ;           xloop LOOP_STACK
    ld   BC, string274  ; 3:10      print_i   Address of string274 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_272(xm)
do272save:              ;           0 10 do_272(xm)
    ld  (idx272),BC     ; 4:20      0 10 do_272(xm)
do272:                  ;           0 10 do_272(xm)
    push DE             ; 1:11      i_272(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_272(m)
    ld   HL, (idx272)   ; 3:16      i_272(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > x3334   _TMP_STACK_INFO variant: variable
    ld    A, low x3334  ; 2:7        > x3334   HL>x3334 --> 0>x3334-HL
    sub   L             ; 1:4        > x3334   HL>x3334 --> 0>x3334-HL
    ld    A, high x3334 ; 2:7        > x3334   HL>x3334 --> 0>x3334-HL
    sbc   A, H          ; 1:4        > x3334   HL>x3334 --> 0>x3334-HL --> false if not carry
    rra                 ; 1:4        > x3334
    xor   H             ; 1:4        > x3334   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > x3334
    pop  DE             ; 1:10       > x3334
  .warning The condition "x3334" cannot be evaluated
  if ((x3334)>=0x8000 || (x3334)<0)
    jp    m, else272    ; 3:10       > x3334
  else
    jp    p, else272    ; 3:10       > x3334
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif272       ; 3:10      else
else272:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif272:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_272(xm)   variant -1.A: step -1 and stop 0, run 11x
idx272 EQU $+1          ;           -1 +loop_272(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_272(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_272(xm)
    or    B             ; 1:4       -1 +loop_272(xm)
    dec  BC             ; 1:6       -1 +loop_272(xm)   index--
    jp   nz, do272save  ; 3:10      -1 +loop_272(xm)
leave272:               ;           -1 +loop_272(xm)
exit272:                ;           xloop LOOP_STACK
    ld   BC, string275  ; 3:10      print_i   Address of string275 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- max ------
    ld   BC, 10         ; 3:10      0 10 do_273(xm)
do273save:              ;           0 10 do_273(xm)
    ld  (idx273),BC     ; 4:20      0 10 do_273(xm)
do273:                  ;           0 10 do_273(xm)
    push DE             ; 1:11      i_273(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_273(m)
    ld   HL, (idx273)   ; 3:16      i_273(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[3:10]      > 0x7FFF   _TMP_STACK_INFO variant: >max
  .warning The condition is always False!
    jp   else273        ; 3:10       > 0x7FFF
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif273       ; 3:10      else
else273:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif273:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_273(xm)   variant -1.A: step -1 and stop 0, run 11x
idx273 EQU $+1          ;           -1 +loop_273(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_273(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_273(xm)
    or    B             ; 1:4       -1 +loop_273(xm)
    dec  BC             ; 1:6       -1 +loop_273(xm)   index--
    jp   nz, do273save  ; 3:10      -1 +loop_273(xm)
leave273:               ;           -1 +loop_273(xm)
exit273:                ;           xloop LOOP_STACK
    ld   BC, string276  ; 3:10      print_i   Address of string276 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_274(xm)
do274save:              ;           0 10 do_274(xm)
    ld  (idx274),BC     ; 4:20      0 10 do_274(xm)
do274:                  ;           0 10 do_274(xm)
    push DE             ; 1:11      i_274(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_274(m)
    ld   HL, (idx274)   ; 3:16      i_274(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[5:24]      > 0x7FFF   _TMP_STACK_INFO variant: max
  .warning The condition is always False!
    ex   DE, HL         ; 1:4        > 0x7FFF   HL>max --> false
    pop  DE             ; 1:10       > 0x7FFF
    jp   else274        ; 3:10       > 0x7FFF
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif274       ; 3:10      else
else274:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif274:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_274(xm)   variant -1.A: step -1 and stop 0, run 11x
idx274 EQU $+1          ;           -1 +loop_274(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_274(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_274(xm)
    or    B             ; 1:4       -1 +loop_274(xm)
    dec  BC             ; 1:6       -1 +loop_274(xm)   index--
    jp   nz, do274save  ; 3:10      -1 +loop_274(xm)
leave274:               ;           -1 +loop_274(xm)
exit274:                ;           xloop LOOP_STACK
    ld   BC, string276  ; 3:10      print_i   Address of string277 ending with inverted most significant bit == string276
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_275(xm)
do275save:              ;           0 10 do_275(xm)
    ld  (idx275),BC     ; 4:20      0 10 do_275(xm)
do275:                  ;           0 10 do_275(xm)
    push DE             ; 1:11      i_275(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_275(m)
    ld   HL, (idx275)   ; 3:16      i_275(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:40]      > max   _TMP_STACK_INFO #variant: variable, change: "define({_TYP_SINGLE},{sign_first})"
  .warning The condition "max" cannot be evaluated
    ld    A, low max    ; 2:7        > max   HL>max --> 0>max-HL --> false if not carry
    sub   L             ; 1:4        > max   HL>max --> 0>max-HL --> false if not carry
    ld    A, high max   ; 2:7        > max   HL>max --> 0>max-HL --> false if not carry
    sbc   A, H          ; 1:4        > max   HL>max --> 0>max-HL --> false if not carry
    rra                 ; 1:4        > max
    xor   H             ; 1:4        > max   invert sign if HL is negative
  if ((max)>=0x8000 || (max)<0)
    jp    m, else275    ; 3:10       > max   negative constant --> false if sign
  else
    jp    p, else275    ; 3:10       > max   positive constant --> false if not sign
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif275       ; 3:10      else
else275:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif275:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_275(xm)   variant -1.A: step -1 and stop 0, run 11x
idx275 EQU $+1          ;           -1 +loop_275(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_275(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_275(xm)
    or    B             ; 1:4       -1 +loop_275(xm)
    dec  BC             ; 1:6       -1 +loop_275(xm)   index--
    jp   nz, do275save  ; 3:10      -1 +loop_275(xm)
leave275:               ;           -1 +loop_275(xm)
exit275:                ;           xloop LOOP_STACK
    ld   BC, string278  ; 3:10      print_i   Address of string278 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 10         ; 3:10      0 10 do_276(xm)
do276save:              ;           0 10 do_276(xm)
    ld  (idx276),BC     ; 4:20      0 10 do_276(xm)
do276:                  ;           0 10 do_276(xm)
    push DE             ; 1:11      i_276(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_276(m)
    ld   HL, (idx276)   ; 3:16      i_276(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_max<<<
    ld   BC, _max       ; 3:10      _max +
    add  HL, BC         ; 1:11      _max +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[13:54]      > max   _TMP_STACK_INFO variant: variable
    ld    A, low max    ; 2:7        > max   HL>max --> 0>max-HL
    sub   L             ; 1:4        > max   HL>max --> 0>max-HL
    ld    A, high max   ; 2:7        > max   HL>max --> 0>max-HL
    sbc   A, H          ; 1:4        > max   HL>max --> 0>max-HL --> false if not carry
    rra                 ; 1:4        > max
    xor   H             ; 1:4        > max   invert sign if HL is negative
    ex   DE, HL         ; 1:4        > max
    pop  DE             ; 1:10       > max
  .warning The condition "max" cannot be evaluated
  if ((max)>=0x8000 || (max)<0)
    jp    m, else276    ; 3:10       > max
  else
    jp    p, else276    ; 3:10       > max
  endif
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif276       ; 3:10      else
else276:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif276:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_276(xm)   variant -1.A: step -1 and stop 0, run 11x
idx276 EQU $+1          ;           -1 +loop_276(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_276(xm)   10.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_276(xm)
    or    B             ; 1:4       -1 +loop_276(xm)
    dec  BC             ; 1:6       -1 +loop_276(xm)   index--
    jp   nz, do276save  ; 3:10      -1 +loop_276(xm)
leave276:               ;           -1 +loop_276(xm)
exit276:                ;           xloop LOOP_STACK
    ld   BC, string279  ; 3:10      print_i   Address of string279 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, string280  ; 3:10      print_i   Address of string280 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0 ------
    ld   BC, 6          ; 3:10      0 6 do_277(xm)
do277save:              ;           0 6 do_277(xm)
    ld  (idx277),BC     ; 4:20      0 6 do_277(xm)
do277:                  ;           0 6 do_277(xm)
    push DE             ; 1:11      i_277(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_277(m)
    ld   HL, (idx277)   ; 3:16      i_277(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[3:10]     u< 0   _TMP_STACK_INFO variant: u<min
  .warning The condition is always False!
    jp   else277        ; 3:10      u< 0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif277       ; 3:10      else
else277:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif277:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_277(xm)   variant -1.A: step -1 and stop 0, run 7x
idx277 EQU $+1          ;           -1 +loop_277(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_277(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_277(xm)
    or    B             ; 1:4       -1 +loop_277(xm)
    dec  BC             ; 1:6       -1 +loop_277(xm)   index--
    jp   nz, do277save  ; 3:10      -1 +loop_277(xm)
leave277:               ;           -1 +loop_277(xm)
exit277:                ;           xloop LOOP_STACK
    ld   BC, string281  ; 3:10      print_i   Address of string281 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_278(xm)
do278save:              ;           0 6 do_278(xm)
    ld  (idx278),BC     ; 4:20      0 6 do_278(xm)
do278:                  ;           0 6 do_278(xm)
    push DE             ; 1:11      i_278(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_278(m)
    ld   HL, (idx278)   ; 3:16      i_278(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[5:24]     u< 0   _TMP_STACK_INFO variant: u<min
  .warning The condition is always False!
    ex   DE, HL         ; 1:4       u< 0
    pop  DE             ; 1:10      u< 0
    jp   else278        ; 3:10      u< 0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif278       ; 3:10      else
else278:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif278:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_278(xm)   variant -1.A: step -1 and stop 0, run 7x
idx278 EQU $+1          ;           -1 +loop_278(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_278(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_278(xm)
    or    B             ; 1:4       -1 +loop_278(xm)
    dec  BC             ; 1:6       -1 +loop_278(xm)   index--
    jp   nz, do278save  ; 3:10      -1 +loop_278(xm)
leave278:               ;           -1 +loop_278(xm)
exit278:                ;           xloop LOOP_STACK
    ld   BC, string281  ; 3:10      print_i   Address of string282 ending with inverted most significant bit == string281
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_279(xm)
do279save:              ;           0 6 do_279(xm)
    ld  (idx279),BC     ; 4:20      0 6 do_279(xm)
do279:                  ;           0 6 do_279(xm)
    push DE             ; 1:11      i_279(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_279(m)
    ld   HL, (idx279)   ; 3:16      i_279(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u< zero   _TMP_STACK_INFO #variant: variable
  .warning The condition "zero" cannot be evaluated
    ld    A, L          ; 1:4       u< zero   HL<zero --> HL-zero<0 --> false if not carry
    sub   low zero      ; 2:7       u< zero   HL<zero --> HL-zero<0 --> false if not carry
    ld    A, H          ; 1:4       u< zero   HL<zero --> HL-zero<0 --> false if not carry
    sbc   A, high zero  ; 2:7       u< zero   HL<zero --> HL-zero<0 --> false if not carry
    jp   nc, else279    ; 3:10      u< zero   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif279       ; 3:10      else
else279:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif279:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_279(xm)   variant -1.A: step -1 and stop 0, run 7x
idx279 EQU $+1          ;           -1 +loop_279(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_279(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_279(xm)
    or    B             ; 1:4       -1 +loop_279(xm)
    dec  BC             ; 1:6       -1 +loop_279(xm)   index--
    jp   nz, do279save  ; 3:10      -1 +loop_279(xm)
leave279:               ;           -1 +loop_279(xm)
exit279:                ;           xloop LOOP_STACK
    ld   BC, string283  ; 3:10      print_i   Address of string283 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_280(xm)
do280save:              ;           0 6 do_280(xm)
    ld  (idx280),BC     ; 4:20      0 6 do_280(xm)
do280:                  ;           0 6 do_280(xm)
    push DE             ; 1:11      i_280(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_280(m)
    ld   HL, (idx280)   ; 3:16      i_280(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u< zero   _TMP_STACK_INFO #variant: variable
  .warning The condition "zero" cannot be evaluated
    ld    A, L          ; 1:4       u< zero   HL<zero --> HL-zero<0 --> false if not carry
    sub   low zero      ; 2:7       u< zero   HL<zero --> HL-zero<0 --> false if not carry
    ld    A, H          ; 1:4       u< zero   HL<zero --> HL-zero<0 --> false if not carry
    sbc   A, high zero  ; 2:7       u< zero   HL<zero --> HL-zero<0 --> false if not carry
    ex   DE, HL         ; 1:4       u< zero
    pop  DE             ; 1:10      u< zero
    jp   nc, else280    ; 3:10      u< zero   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif280       ; 3:10      else
else280:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif280:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_280(xm)   variant -1.A: step -1 and stop 0, run 7x
idx280 EQU $+1          ;           -1 +loop_280(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_280(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_280(xm)
    or    B             ; 1:4       -1 +loop_280(xm)
    dec  BC             ; 1:6       -1 +loop_280(xm)   index--
    jp   nz, do280save  ; 3:10      -1 +loop_280(xm)
leave280:               ;           -1 +loop_280(xm)
exit280:                ;           xloop LOOP_STACK
    ld   BC, string284  ; 3:10      print_i   Address of string284 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 1 ------
    ld   BC, 6          ; 3:10      0 6 do_281(xm)
do281save:              ;           0 6 do_281(xm)
    ld  (idx281),BC     ; 4:20      0 6 do_281(xm)
do281:                  ;           0 6 do_281(xm)
    push DE             ; 1:11      i_281(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_281(m)
    ld   HL, (idx281)   ; 3:16      i_281(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[5:18]     u< +1   _TMP_STACK_INFO variant: u<=1
    ld    A, H          ; 1:4       u< +1
    or    L             ; 1:4       u< +1
    jp   nz, else281    ; 3:10      u< +1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif281       ; 3:10      else
else281:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif281:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_281(xm)   variant -1.A: step -1 and stop 0, run 7x
idx281 EQU $+1          ;           -1 +loop_281(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_281(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_281(xm)
    or    B             ; 1:4       -1 +loop_281(xm)
    dec  BC             ; 1:6       -1 +loop_281(xm)   index--
    jp   nz, do281save  ; 3:10      -1 +loop_281(xm)
leave281:               ;           -1 +loop_281(xm)
exit281:                ;           xloop LOOP_STACK
    ld   BC, string285  ; 3:10      print_i   Address of string285 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_282(xm)
do282save:              ;           0 6 do_282(xm)
    ld  (idx282),BC     ; 4:20      0 6 do_282(xm)
do282:                  ;           0 6 do_282(xm)
    push DE             ; 1:11      i_282(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_282(m)
    ld   HL, (idx282)   ; 3:16      i_282(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:32]     u< +1   _TMP_STACK_INFO variant: u<=1
    ld    A, H          ; 1:4       u< +1
    or    L             ; 1:4       u< +1
    ex   DE, HL         ; 1:4       u< +1
    pop  DE             ; 1:10      u< +1
    jp   nz, else282    ; 3:10      u< +1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif282       ; 3:10      else
else282:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif282:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_282(xm)   variant -1.A: step -1 and stop 0, run 7x
idx282 EQU $+1          ;           -1 +loop_282(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_282(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_282(xm)
    or    B             ; 1:4       -1 +loop_282(xm)
    dec  BC             ; 1:6       -1 +loop_282(xm)   index--
    jp   nz, do282save  ; 3:10      -1 +loop_282(xm)
leave282:               ;           -1 +loop_282(xm)
exit282:                ;           xloop LOOP_STACK
    ld   BC, string285  ; 3:10      print_i   Address of string286 ending with inverted most significant bit == string285
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_283(xm)
do283save:              ;           0 6 do_283(xm)
    ld  (idx283),BC     ; 4:20      0 6 do_283(xm)
do283:                  ;           0 6 do_283(xm)
    push DE             ; 1:11      i_283(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_283(m)
    ld   HL, (idx283)   ; 3:16      i_283(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u< p1   _TMP_STACK_INFO #variant: variable
  .warning The condition "p1" cannot be evaluated
    ld    A, L          ; 1:4       u< p1   HL<p1 --> HL-p1<0 --> false if not carry
    sub   low p1        ; 2:7       u< p1   HL<p1 --> HL-p1<0 --> false if not carry
    ld    A, H          ; 1:4       u< p1   HL<p1 --> HL-p1<0 --> false if not carry
    sbc   A, high p1    ; 2:7       u< p1   HL<p1 --> HL-p1<0 --> false if not carry
    jp   nc, else283    ; 3:10      u< p1   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif283       ; 3:10      else
else283:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif283:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_283(xm)   variant -1.A: step -1 and stop 0, run 7x
idx283 EQU $+1          ;           -1 +loop_283(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_283(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_283(xm)
    or    B             ; 1:4       -1 +loop_283(xm)
    dec  BC             ; 1:6       -1 +loop_283(xm)   index--
    jp   nz, do283save  ; 3:10      -1 +loop_283(xm)
leave283:               ;           -1 +loop_283(xm)
exit283:                ;           xloop LOOP_STACK
    ld   BC, string287  ; 3:10      print_i   Address of string287 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_284(xm)
do284save:              ;           0 6 do_284(xm)
    ld  (idx284),BC     ; 4:20      0 6 do_284(xm)
do284:                  ;           0 6 do_284(xm)
    push DE             ; 1:11      i_284(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_284(m)
    ld   HL, (idx284)   ; 3:16      i_284(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u< p1   _TMP_STACK_INFO #variant: variable
  .warning The condition "p1" cannot be evaluated
    ld    A, L          ; 1:4       u< p1   HL<p1 --> HL-p1<0 --> false if not carry
    sub   low p1        ; 2:7       u< p1   HL<p1 --> HL-p1<0 --> false if not carry
    ld    A, H          ; 1:4       u< p1   HL<p1 --> HL-p1<0 --> false if not carry
    sbc   A, high p1    ; 2:7       u< p1   HL<p1 --> HL-p1<0 --> false if not carry
    ex   DE, HL         ; 1:4       u< p1
    pop  DE             ; 1:10      u< p1
    jp   nc, else284    ; 3:10      u< p1   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif284       ; 3:10      else
else284:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif284:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_284(xm)   variant -1.A: step -1 and stop 0, run 7x
idx284 EQU $+1          ;           -1 +loop_284(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_284(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_284(xm)
    or    B             ; 1:4       -1 +loop_284(xm)
    dec  BC             ; 1:6       -1 +loop_284(xm)   index--
    jp   nz, do284save  ; 3:10      -1 +loop_284(xm)
leave284:               ;           -1 +loop_284(xm)
exit284:                ;           xloop LOOP_STACK
    ld   BC, string288  ; 3:10      print_i   Address of string288 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3332 = 13106 ------
    ld   BC, 6          ; 3:10      0 6 do_285(xm)
do285save:              ;           0 6 do_285(xm)
    ld  (idx285),BC     ; 4:20      0 6 do_285(xm)
do285:                  ;           0 6 do_285(xm)
    push DE             ; 1:11      i_285(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_285(m)
    ld   HL, (idx285)   ; 3:16      i_285(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u< +13106   _TMP_STACK_INFO #variant: default
    ld    A, L          ; 1:4       u< +13106   HL<13106 --> L-0x32<0 --> false if not carry
    sub  0x32           ; 2:7       u< +13106   HL<13106 --> L-0x32<0 --> false if not carry
    ld    A, H          ; 1:4       u< +13106   HL<13106 --> H-0x33<0 --> false if not carry
    sbc   A, 0x33       ; 2:7       u< +13106   HL<13106 --> H-0x33<0 --> false if not carry
    jp   nc, else285    ; 3:10      u< +13106   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif285       ; 3:10      else
else285:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif285:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_285(xm)   variant -1.A: step -1 and stop 0, run 7x
idx285 EQU $+1          ;           -1 +loop_285(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_285(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_285(xm)
    or    B             ; 1:4       -1 +loop_285(xm)
    dec  BC             ; 1:6       -1 +loop_285(xm)   index--
    jp   nz, do285save  ; 3:10      -1 +loop_285(xm)
leave285:               ;           -1 +loop_285(xm)
exit285:                ;           xloop LOOP_STACK
    ld   BC, string289  ; 3:10      print_i   Address of string289 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_286(xm)
do286save:              ;           0 6 do_286(xm)
    ld  (idx286),BC     ; 4:20      0 6 do_286(xm)
do286:                  ;           0 6 do_286(xm)
    push DE             ; 1:11      i_286(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_286(m)
    ld   HL, (idx286)   ; 3:16      i_286(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u< +13106   _TMP_STACK_INFO #variant: default
    ld    A, L          ; 1:4       u< +13106   HL<13106 --> L-0x32<0 --> false if not carry
    sub  0x32           ; 2:7       u< +13106   HL<13106 --> L-0x32<0 --> false if not carry
    ld    A, H          ; 1:4       u< +13106   HL<13106 --> H-0x33<0 --> false if not carry
    sbc   A, 0x33       ; 2:7       u< +13106   HL<13106 --> H-0x33<0 --> false if not carry
    ex   DE, HL         ; 1:4       u< +13106
    pop  DE             ; 1:10      u< +13106
    jp   nc, else286    ; 3:10      u< +13106   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif286       ; 3:10      else
else286:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif286:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_286(xm)   variant -1.A: step -1 and stop 0, run 7x
idx286 EQU $+1          ;           -1 +loop_286(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_286(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_286(xm)
    or    B             ; 1:4       -1 +loop_286(xm)
    dec  BC             ; 1:6       -1 +loop_286(xm)   index--
    jp   nz, do286save  ; 3:10      -1 +loop_286(xm)
leave286:               ;           -1 +loop_286(xm)
exit286:                ;           xloop LOOP_STACK
    ld   BC, string289  ; 3:10      print_i   Address of string290 ending with inverted most significant bit == string289
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_287(xm)
do287save:              ;           0 6 do_287(xm)
    ld  (idx287),BC     ; 4:20      0 6 do_287(xm)
do287:                  ;           0 6 do_287(xm)
    push DE             ; 1:11      i_287(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_287(m)
    ld   HL, (idx287)   ; 3:16      i_287(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u< x3332   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3332" cannot be evaluated
    ld    A, L          ; 1:4       u< x3332   HL<x3332 --> HL-x3332<0 --> false if not carry
    sub   low x3332     ; 2:7       u< x3332   HL<x3332 --> HL-x3332<0 --> false if not carry
    ld    A, H          ; 1:4       u< x3332   HL<x3332 --> HL-x3332<0 --> false if not carry
    sbc   A, high x3332 ; 2:7       u< x3332   HL<x3332 --> HL-x3332<0 --> false if not carry
    jp   nc, else287    ; 3:10      u< x3332   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif287       ; 3:10      else
else287:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif287:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_287(xm)   variant -1.A: step -1 and stop 0, run 7x
idx287 EQU $+1          ;           -1 +loop_287(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_287(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_287(xm)
    or    B             ; 1:4       -1 +loop_287(xm)
    dec  BC             ; 1:6       -1 +loop_287(xm)   index--
    jp   nz, do287save  ; 3:10      -1 +loop_287(xm)
leave287:               ;           -1 +loop_287(xm)
exit287:                ;           xloop LOOP_STACK
    ld   BC, string291  ; 3:10      print_i   Address of string291 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_288(xm)
do288save:              ;           0 6 do_288(xm)
    ld  (idx288),BC     ; 4:20      0 6 do_288(xm)
do288:                  ;           0 6 do_288(xm)
    push DE             ; 1:11      i_288(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_288(m)
    ld   HL, (idx288)   ; 3:16      i_288(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u< x3332   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3332" cannot be evaluated
    ld    A, L          ; 1:4       u< x3332   HL<x3332 --> HL-x3332<0 --> false if not carry
    sub   low x3332     ; 2:7       u< x3332   HL<x3332 --> HL-x3332<0 --> false if not carry
    ld    A, H          ; 1:4       u< x3332   HL<x3332 --> HL-x3332<0 --> false if not carry
    sbc   A, high x3332 ; 2:7       u< x3332   HL<x3332 --> HL-x3332<0 --> false if not carry
    ex   DE, HL         ; 1:4       u< x3332
    pop  DE             ; 1:10      u< x3332
    jp   nc, else288    ; 3:10      u< x3332   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif288       ; 3:10      else
else288:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif288:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_288(xm)   variant -1.A: step -1 and stop 0, run 7x
idx288 EQU $+1          ;           -1 +loop_288(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_288(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_288(xm)
    or    B             ; 1:4       -1 +loop_288(xm)
    dec  BC             ; 1:6       -1 +loop_288(xm)   index--
    jp   nz, do288save  ; 3:10      -1 +loop_288(xm)
leave288:               ;           -1 +loop_288(xm)
exit288:                ;           xloop LOOP_STACK
    ld   BC, string292  ; 3:10      print_i   Address of string292 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3333 = 13107 ------
    ld   BC, 6          ; 3:10      0 6 do_289(xm)
do289save:              ;           0 6 do_289(xm)
    ld  (idx289),BC     ; 4:20      0 6 do_289(xm)
do289:                  ;           0 6 do_289(xm)
    push DE             ; 1:11      i_289(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_289(m)
    ld   HL, (idx289)   ; 3:16      i_289(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u< +13107   _TMP_STACK_INFO #variant: default
    ld    A, L          ; 1:4       u< +13107   HL<13107 --> L-0x33<0 --> false if not carry
    sub  0x33           ; 2:7       u< +13107   HL<13107 --> L-0x33<0 --> false if not carry
    ld    A, H          ; 1:4       u< +13107   HL<13107 --> H-0x33<0 --> false if not carry
    sbc   A, 0x33       ; 2:7       u< +13107   HL<13107 --> H-0x33<0 --> false if not carry
    jp   nc, else289    ; 3:10      u< +13107   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif289       ; 3:10      else
else289:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif289:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_289(xm)   variant -1.A: step -1 and stop 0, run 7x
idx289 EQU $+1          ;           -1 +loop_289(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_289(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_289(xm)
    or    B             ; 1:4       -1 +loop_289(xm)
    dec  BC             ; 1:6       -1 +loop_289(xm)   index--
    jp   nz, do289save  ; 3:10      -1 +loop_289(xm)
leave289:               ;           -1 +loop_289(xm)
exit289:                ;           xloop LOOP_STACK
    ld   BC, string293  ; 3:10      print_i   Address of string293 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_290(xm)
do290save:              ;           0 6 do_290(xm)
    ld  (idx290),BC     ; 4:20      0 6 do_290(xm)
do290:                  ;           0 6 do_290(xm)
    push DE             ; 1:11      i_290(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_290(m)
    ld   HL, (idx290)   ; 3:16      i_290(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u< +13107   _TMP_STACK_INFO #variant: default
    ld    A, L          ; 1:4       u< +13107   HL<13107 --> L-0x33<0 --> false if not carry
    sub  0x33           ; 2:7       u< +13107   HL<13107 --> L-0x33<0 --> false if not carry
    ld    A, H          ; 1:4       u< +13107   HL<13107 --> H-0x33<0 --> false if not carry
    sbc   A, 0x33       ; 2:7       u< +13107   HL<13107 --> H-0x33<0 --> false if not carry
    ex   DE, HL         ; 1:4       u< +13107
    pop  DE             ; 1:10      u< +13107
    jp   nc, else290    ; 3:10      u< +13107   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif290       ; 3:10      else
else290:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif290:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_290(xm)   variant -1.A: step -1 and stop 0, run 7x
idx290 EQU $+1          ;           -1 +loop_290(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_290(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_290(xm)
    or    B             ; 1:4       -1 +loop_290(xm)
    dec  BC             ; 1:6       -1 +loop_290(xm)   index--
    jp   nz, do290save  ; 3:10      -1 +loop_290(xm)
leave290:               ;           -1 +loop_290(xm)
exit290:                ;           xloop LOOP_STACK
    ld   BC, string293  ; 3:10      print_i   Address of string294 ending with inverted most significant bit == string293
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_291(xm)
do291save:              ;           0 6 do_291(xm)
    ld  (idx291),BC     ; 4:20      0 6 do_291(xm)
do291:                  ;           0 6 do_291(xm)
    push DE             ; 1:11      i_291(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_291(m)
    ld   HL, (idx291)   ; 3:16      i_291(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u< x3333   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3333" cannot be evaluated
    ld    A, L          ; 1:4       u< x3333   HL<x3333 --> HL-x3333<0 --> false if not carry
    sub   low x3333     ; 2:7       u< x3333   HL<x3333 --> HL-x3333<0 --> false if not carry
    ld    A, H          ; 1:4       u< x3333   HL<x3333 --> HL-x3333<0 --> false if not carry
    sbc   A, high x3333 ; 2:7       u< x3333   HL<x3333 --> HL-x3333<0 --> false if not carry
    jp   nc, else291    ; 3:10      u< x3333   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif291       ; 3:10      else
else291:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif291:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_291(xm)   variant -1.A: step -1 and stop 0, run 7x
idx291 EQU $+1          ;           -1 +loop_291(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_291(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_291(xm)
    or    B             ; 1:4       -1 +loop_291(xm)
    dec  BC             ; 1:6       -1 +loop_291(xm)   index--
    jp   nz, do291save  ; 3:10      -1 +loop_291(xm)
leave291:               ;           -1 +loop_291(xm)
exit291:                ;           xloop LOOP_STACK
    ld   BC, string295  ; 3:10      print_i   Address of string295 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_292(xm)
do292save:              ;           0 6 do_292(xm)
    ld  (idx292),BC     ; 4:20      0 6 do_292(xm)
do292:                  ;           0 6 do_292(xm)
    push DE             ; 1:11      i_292(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_292(m)
    ld   HL, (idx292)   ; 3:16      i_292(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u< x3333   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3333" cannot be evaluated
    ld    A, L          ; 1:4       u< x3333   HL<x3333 --> HL-x3333<0 --> false if not carry
    sub   low x3333     ; 2:7       u< x3333   HL<x3333 --> HL-x3333<0 --> false if not carry
    ld    A, H          ; 1:4       u< x3333   HL<x3333 --> HL-x3333<0 --> false if not carry
    sbc   A, high x3333 ; 2:7       u< x3333   HL<x3333 --> HL-x3333<0 --> false if not carry
    ex   DE, HL         ; 1:4       u< x3333
    pop  DE             ; 1:10      u< x3333
    jp   nc, else292    ; 3:10      u< x3333   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif292       ; 3:10      else
else292:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif292:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_292(xm)   variant -1.A: step -1 and stop 0, run 7x
idx292 EQU $+1          ;           -1 +loop_292(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_292(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_292(xm)
    or    B             ; 1:4       -1 +loop_292(xm)
    dec  BC             ; 1:6       -1 +loop_292(xm)   index--
    jp   nz, do292save  ; 3:10      -1 +loop_292(xm)
leave292:               ;           -1 +loop_292(xm)
exit292:                ;           xloop LOOP_STACK
    ld   BC, string296  ; 3:10      print_i   Address of string296 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3334 = 13108 ------
    ld   BC, 6          ; 3:10      0 6 do_293(xm)
do293save:              ;           0 6 do_293(xm)
    ld  (idx293),BC     ; 4:20      0 6 do_293(xm)
do293:                  ;           0 6 do_293(xm)
    push DE             ; 1:11      i_293(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_293(m)
    ld   HL, (idx293)   ; 3:16      i_293(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:25]     u< +13108   _TMP_STACK_INFO #variant: hi == lo-1
    ld    A, 0x33       ; 2:7       u< +13108   HL< 0x3334 --> HL<=0x3333
    cp    L             ; 1:4       u< +13108   HL<=0x3333 -->  0<=0x33-L --> false if carry
    sbc   A, H          ; 1:4       u< +13108   HL<=0x3333 -->  0<=0x33-H --> false if carry
    jp    c, else293    ; 3:10      u< +13108   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif293       ; 3:10      else
else293:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif293:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_293(xm)   variant -1.A: step -1 and stop 0, run 7x
idx293 EQU $+1          ;           -1 +loop_293(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_293(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_293(xm)
    or    B             ; 1:4       -1 +loop_293(xm)
    dec  BC             ; 1:6       -1 +loop_293(xm)   index--
    jp   nz, do293save  ; 3:10      -1 +loop_293(xm)
leave293:               ;           -1 +loop_293(xm)
exit293:                ;           xloop LOOP_STACK
    ld   BC, string297  ; 3:10      print_i   Address of string297 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_294(xm)
do294save:              ;           0 6 do_294(xm)
    ld  (idx294),BC     ; 4:20      0 6 do_294(xm)
do294:                  ;           0 6 do_294(xm)
    push DE             ; 1:11      i_294(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_294(m)
    ld   HL, (idx294)   ; 3:16      i_294(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:39]     u< +13108   _TMP_STACK_INFO #variant: hi == lo-1
    ld    A, 0x33       ; 2:7       u< +13108   HL< 0x3334 --> HL<=0x3333
    cp    L             ; 1:4       u< +13108   HL<=0x3333 -->  0<=0x33-L --> false if carry
    sbc   A, H          ; 1:4       u< +13108   HL<=0x3333 -->  0<=0x33-H --> false if carry
    ex   DE, HL         ; 1:4       u< +13108
    pop  DE             ; 1:10      u< +13108
    jp    c, else294    ; 3:10      u< +13108   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif294       ; 3:10      else
else294:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif294:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_294(xm)   variant -1.A: step -1 and stop 0, run 7x
idx294 EQU $+1          ;           -1 +loop_294(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_294(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_294(xm)
    or    B             ; 1:4       -1 +loop_294(xm)
    dec  BC             ; 1:6       -1 +loop_294(xm)   index--
    jp   nz, do294save  ; 3:10      -1 +loop_294(xm)
leave294:               ;           -1 +loop_294(xm)
exit294:                ;           xloop LOOP_STACK
    ld   BC, string297  ; 3:10      print_i   Address of string298 ending with inverted most significant bit == string297
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_295(xm)
do295save:              ;           0 6 do_295(xm)
    ld  (idx295),BC     ; 4:20      0 6 do_295(xm)
do295:                  ;           0 6 do_295(xm)
    push DE             ; 1:11      i_295(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_295(m)
    ld   HL, (idx295)   ; 3:16      i_295(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u< x3334   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3334" cannot be evaluated
    ld    A, L          ; 1:4       u< x3334   HL<x3334 --> HL-x3334<0 --> false if not carry
    sub   low x3334     ; 2:7       u< x3334   HL<x3334 --> HL-x3334<0 --> false if not carry
    ld    A, H          ; 1:4       u< x3334   HL<x3334 --> HL-x3334<0 --> false if not carry
    sbc   A, high x3334 ; 2:7       u< x3334   HL<x3334 --> HL-x3334<0 --> false if not carry
    jp   nc, else295    ; 3:10      u< x3334   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif295       ; 3:10      else
else295:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif295:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_295(xm)   variant -1.A: step -1 and stop 0, run 7x
idx295 EQU $+1          ;           -1 +loop_295(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_295(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_295(xm)
    or    B             ; 1:4       -1 +loop_295(xm)
    dec  BC             ; 1:6       -1 +loop_295(xm)   index--
    jp   nz, do295save  ; 3:10      -1 +loop_295(xm)
leave295:               ;           -1 +loop_295(xm)
exit295:                ;           xloop LOOP_STACK
    ld   BC, string299  ; 3:10      print_i   Address of string299 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_296(xm)
do296save:              ;           0 6 do_296(xm)
    ld  (idx296),BC     ; 4:20      0 6 do_296(xm)
do296:                  ;           0 6 do_296(xm)
    push DE             ; 1:11      i_296(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_296(m)
    ld   HL, (idx296)   ; 3:16      i_296(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u< x3334   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3334" cannot be evaluated
    ld    A, L          ; 1:4       u< x3334   HL<x3334 --> HL-x3334<0 --> false if not carry
    sub   low x3334     ; 2:7       u< x3334   HL<x3334 --> HL-x3334<0 --> false if not carry
    ld    A, H          ; 1:4       u< x3334   HL<x3334 --> HL-x3334<0 --> false if not carry
    sbc   A, high x3334 ; 2:7       u< x3334   HL<x3334 --> HL-x3334<0 --> false if not carry
    ex   DE, HL         ; 1:4       u< x3334
    pop  DE             ; 1:10      u< x3334
    jp   nc, else296    ; 3:10      u< x3334   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif296       ; 3:10      else
else296:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif296:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_296(xm)   variant -1.A: step -1 and stop 0, run 7x
idx296 EQU $+1          ;           -1 +loop_296(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_296(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_296(xm)
    or    B             ; 1:4       -1 +loop_296(xm)
    dec  BC             ; 1:6       -1 +loop_296(xm)   index--
    jp   nz, do296save  ; 3:10      -1 +loop_296(xm)
leave296:               ;           -1 +loop_296(xm)
exit296:                ;           xloop LOOP_STACK
    ld   BC, string300  ; 3:10      print_i   Address of string300 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- -2 ------
    ld   BC, 6          ; 3:10      0 6 do_297(xm)
do297save:              ;           0 6 do_297(xm)
    ld  (idx297),BC     ; 4:20      0 6 do_297(xm)
do297:                  ;           0 6 do_297(xm)
    push DE             ; 1:11      i_297(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_297(m)
    ld   HL, (idx297)   ; 3:16      i_297(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u< -2   _TMP_STACK_INFO #variant: default
    ld    A, L          ; 1:4       u< -2   HL<-2 --> L-0xFE<0 --> false if not carry
    sub  0xFE           ; 2:7       u< -2   HL<-2 --> L-0xFE<0 --> false if not carry
    ld    A, H          ; 1:4       u< -2   HL<-2 --> H-0xFF<0 --> false if not carry
    sbc   A, 0xFF       ; 2:7       u< -2   HL<-2 --> H-0xFF<0 --> false if not carry
    jp   nc, else297    ; 3:10      u< -2   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif297       ; 3:10      else
else297:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif297:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_297(xm)   variant -1.A: step -1 and stop 0, run 7x
idx297 EQU $+1          ;           -1 +loop_297(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_297(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_297(xm)
    or    B             ; 1:4       -1 +loop_297(xm)
    dec  BC             ; 1:6       -1 +loop_297(xm)   index--
    jp   nz, do297save  ; 3:10      -1 +loop_297(xm)
leave297:               ;           -1 +loop_297(xm)
exit297:                ;           xloop LOOP_STACK
    ld   BC, string301  ; 3:10      print_i   Address of string301 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_298(xm)
do298save:              ;           0 6 do_298(xm)
    ld  (idx298),BC     ; 4:20      0 6 do_298(xm)
do298:                  ;           0 6 do_298(xm)
    push DE             ; 1:11      i_298(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_298(m)
    ld   HL, (idx298)   ; 3:16      i_298(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u< -2   _TMP_STACK_INFO #variant: default
    ld    A, L          ; 1:4       u< -2   HL<-2 --> L-0xFE<0 --> false if not carry
    sub  0xFE           ; 2:7       u< -2   HL<-2 --> L-0xFE<0 --> false if not carry
    ld    A, H          ; 1:4       u< -2   HL<-2 --> H-0xFF<0 --> false if not carry
    sbc   A, 0xFF       ; 2:7       u< -2   HL<-2 --> H-0xFF<0 --> false if not carry
    ex   DE, HL         ; 1:4       u< -2
    pop  DE             ; 1:10      u< -2
    jp   nc, else298    ; 3:10      u< -2   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif298       ; 3:10      else
else298:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif298:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_298(xm)   variant -1.A: step -1 and stop 0, run 7x
idx298 EQU $+1          ;           -1 +loop_298(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_298(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_298(xm)
    or    B             ; 1:4       -1 +loop_298(xm)
    dec  BC             ; 1:6       -1 +loop_298(xm)   index--
    jp   nz, do298save  ; 3:10      -1 +loop_298(xm)
leave298:               ;           -1 +loop_298(xm)
exit298:                ;           xloop LOOP_STACK
    ld   BC, string301  ; 3:10      print_i   Address of string302 ending with inverted most significant bit == string301
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_299(xm)
do299save:              ;           0 6 do_299(xm)
    ld  (idx299),BC     ; 4:20      0 6 do_299(xm)
do299:                  ;           0 6 do_299(xm)
    push DE             ; 1:11      i_299(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_299(m)
    ld   HL, (idx299)   ; 3:16      i_299(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u< m2   _TMP_STACK_INFO #variant: variable
  .warning The condition "m2" cannot be evaluated
    ld    A, L          ; 1:4       u< m2   HL<m2 --> HL-m2<0 --> false if not carry
    sub   low m2        ; 2:7       u< m2   HL<m2 --> HL-m2<0 --> false if not carry
    ld    A, H          ; 1:4       u< m2   HL<m2 --> HL-m2<0 --> false if not carry
    sbc   A, high m2    ; 2:7       u< m2   HL<m2 --> HL-m2<0 --> false if not carry
    jp   nc, else299    ; 3:10      u< m2   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif299       ; 3:10      else
else299:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif299:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_299(xm)   variant -1.A: step -1 and stop 0, run 7x
idx299 EQU $+1          ;           -1 +loop_299(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_299(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_299(xm)
    or    B             ; 1:4       -1 +loop_299(xm)
    dec  BC             ; 1:6       -1 +loop_299(xm)   index--
    jp   nz, do299save  ; 3:10      -1 +loop_299(xm)
leave299:               ;           -1 +loop_299(xm)
exit299:                ;           xloop LOOP_STACK
    ld   BC, string303  ; 3:10      print_i   Address of string303 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_300(xm)
do300save:              ;           0 6 do_300(xm)
    ld  (idx300),BC     ; 4:20      0 6 do_300(xm)
do300:                  ;           0 6 do_300(xm)
    push DE             ; 1:11      i_300(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_300(m)
    ld   HL, (idx300)   ; 3:16      i_300(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u< m2   _TMP_STACK_INFO #variant: variable
  .warning The condition "m2" cannot be evaluated
    ld    A, L          ; 1:4       u< m2   HL<m2 --> HL-m2<0 --> false if not carry
    sub   low m2        ; 2:7       u< m2   HL<m2 --> HL-m2<0 --> false if not carry
    ld    A, H          ; 1:4       u< m2   HL<m2 --> HL-m2<0 --> false if not carry
    sbc   A, high m2    ; 2:7       u< m2   HL<m2 --> HL-m2<0 --> false if not carry
    ex   DE, HL         ; 1:4       u< m2
    pop  DE             ; 1:10      u< m2
    jp   nc, else300    ; 3:10      u< m2   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif300       ; 3:10      else
else300:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif300:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_300(xm)   variant -1.A: step -1 and stop 0, run 7x
idx300 EQU $+1          ;           -1 +loop_300(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_300(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_300(xm)
    or    B             ; 1:4       -1 +loop_300(xm)
    dec  BC             ; 1:6       -1 +loop_300(xm)   index--
    jp   nz, do300save  ; 3:10      -1 +loop_300(xm)
leave300:               ;           -1 +loop_300(xm)
exit300:                ;           xloop LOOP_STACK
    ld   BC, string304  ; 3:10      print_i   Address of string304 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- -1 ------
    ld   BC, 6          ; 3:10      0 6 do_301(xm)
do301save:              ;           0 6 do_301(xm)
    ld  (idx301),BC     ; 4:20      0 6 do_301(xm)
do301:                  ;           0 6 do_301(xm)
    push DE             ; 1:11      i_301(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_301(m)
    ld   HL, (idx301)   ; 3:16      i_301(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[6:22]     u< -1   _TMP_STACK_INFO variant: u<max
    ld    A, H          ; 1:4       u< -1
    and   L             ; 1:4       u< -1
    inc   A             ; 1:4       u< -1
    jp    z, else301    ; 3:10      u< -1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif301       ; 3:10      else
else301:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif301:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_301(xm)   variant -1.A: step -1 and stop 0, run 7x
idx301 EQU $+1          ;           -1 +loop_301(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_301(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_301(xm)
    or    B             ; 1:4       -1 +loop_301(xm)
    dec  BC             ; 1:6       -1 +loop_301(xm)   index--
    jp   nz, do301save  ; 3:10      -1 +loop_301(xm)
leave301:               ;           -1 +loop_301(xm)
exit301:                ;           xloop LOOP_STACK
    ld   BC, string305  ; 3:10      print_i   Address of string305 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_302(xm)
do302save:              ;           0 6 do_302(xm)
    ld  (idx302),BC     ; 4:20      0 6 do_302(xm)
do302:                  ;           0 6 do_302(xm)
    push DE             ; 1:11      i_302(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_302(m)
    ld   HL, (idx302)   ; 3:16      i_302(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[8:36]     u< -1   _TMP_STACK_INFO variant: u<max
    ld    A, H          ; 1:4       u< -1
    and   L             ; 1:4       u< -1
    inc   A             ; 1:4       u< -1
    ex   DE, HL         ; 1:4       u< -1
    pop  DE             ; 1:10      u< -1
    jp    z, else302    ; 3:10      u< -1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif302       ; 3:10      else
else302:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif302:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_302(xm)   variant -1.A: step -1 and stop 0, run 7x
idx302 EQU $+1          ;           -1 +loop_302(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_302(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_302(xm)
    or    B             ; 1:4       -1 +loop_302(xm)
    dec  BC             ; 1:6       -1 +loop_302(xm)   index--
    jp   nz, do302save  ; 3:10      -1 +loop_302(xm)
leave302:               ;           -1 +loop_302(xm)
exit302:                ;           xloop LOOP_STACK
    ld   BC, string305  ; 3:10      print_i   Address of string306 ending with inverted most significant bit == string305
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_303(xm)
do303save:              ;           0 6 do_303(xm)
    ld  (idx303),BC     ; 4:20      0 6 do_303(xm)
do303:                  ;           0 6 do_303(xm)
    push DE             ; 1:11      i_303(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_303(m)
    ld   HL, (idx303)   ; 3:16      i_303(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u< m1   _TMP_STACK_INFO #variant: variable
  .warning The condition "m1" cannot be evaluated
    ld    A, L          ; 1:4       u< m1   HL<m1 --> HL-m1<0 --> false if not carry
    sub   low m1        ; 2:7       u< m1   HL<m1 --> HL-m1<0 --> false if not carry
    ld    A, H          ; 1:4       u< m1   HL<m1 --> HL-m1<0 --> false if not carry
    sbc   A, high m1    ; 2:7       u< m1   HL<m1 --> HL-m1<0 --> false if not carry
    jp   nc, else303    ; 3:10      u< m1   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif303       ; 3:10      else
else303:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif303:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_303(xm)   variant -1.A: step -1 and stop 0, run 7x
idx303 EQU $+1          ;           -1 +loop_303(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_303(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_303(xm)
    or    B             ; 1:4       -1 +loop_303(xm)
    dec  BC             ; 1:6       -1 +loop_303(xm)   index--
    jp   nz, do303save  ; 3:10      -1 +loop_303(xm)
leave303:               ;           -1 +loop_303(xm)
exit303:                ;           xloop LOOP_STACK
    ld   BC, string307  ; 3:10      print_i   Address of string307 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_304(xm)
do304save:              ;           0 6 do_304(xm)
    ld  (idx304),BC     ; 4:20      0 6 do_304(xm)
do304:                  ;           0 6 do_304(xm)
    push DE             ; 1:11      i_304(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_304(m)
    ld   HL, (idx304)   ; 3:16      i_304(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u< m1   _TMP_STACK_INFO #variant: variable
  .warning The condition "m1" cannot be evaluated
    ld    A, L          ; 1:4       u< m1   HL<m1 --> HL-m1<0 --> false if not carry
    sub   low m1        ; 2:7       u< m1   HL<m1 --> HL-m1<0 --> false if not carry
    ld    A, H          ; 1:4       u< m1   HL<m1 --> HL-m1<0 --> false if not carry
    sbc   A, high m1    ; 2:7       u< m1   HL<m1 --> HL-m1<0 --> false if not carry
    ex   DE, HL         ; 1:4       u< m1
    pop  DE             ; 1:10      u< m1
    jp   nc, else304    ; 3:10      u< m1   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif304       ; 3:10      else
else304:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif304:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_304(xm)   variant -1.A: step -1 and stop 0, run 7x
idx304 EQU $+1          ;           -1 +loop_304(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_304(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_304(xm)
    or    B             ; 1:4       -1 +loop_304(xm)
    dec  BC             ; 1:6       -1 +loop_304(xm)   index--
    jp   nz, do304save  ; 3:10      -1 +loop_304(xm)
leave304:               ;           -1 +loop_304(xm)
exit304:                ;           xloop LOOP_STACK
    ld   BC, string308  ; 3:10      print_i   Address of string308 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0 ------
    ld   BC, 6          ; 3:10      0 6 do_305(xm)
do305save:              ;           0 6 do_305(xm)
    ld  (idx305),BC     ; 4:20      0 6 do_305(xm)
do305:                  ;           0 6 do_305(xm)
    push DE             ; 1:11      i_305(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_305(m)
    ld   HL, (idx305)   ; 3:16      i_305(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[5:18]     u<=0   _TMP_STACK_INFO variant: u<=min
    ld    A, H          ; 1:4       u<=0
    or    L             ; 1:4       u<=0
    jp   nz, else305    ; 3:10      u<=0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif305       ; 3:10      else
else305:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif305:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_305(xm)   variant -1.A: step -1 and stop 0, run 7x
idx305 EQU $+1          ;           -1 +loop_305(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_305(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_305(xm)
    or    B             ; 1:4       -1 +loop_305(xm)
    dec  BC             ; 1:6       -1 +loop_305(xm)   index--
    jp   nz, do305save  ; 3:10      -1 +loop_305(xm)
leave305:               ;           -1 +loop_305(xm)
exit305:                ;           xloop LOOP_STACK
    ld   BC, string309  ; 3:10      print_i   Address of string309 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_306(xm)
do306save:              ;           0 6 do_306(xm)
    ld  (idx306),BC     ; 4:20      0 6 do_306(xm)
do306:                  ;           0 6 do_306(xm)
    push DE             ; 1:11      i_306(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_306(m)
    ld   HL, (idx306)   ; 3:16      i_306(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:32]     u<=0   _TMP_STACK_INFO variant: u<=min
    ld    A, H          ; 1:4       u<=0
    or    L             ; 1:4       u<=0
    ex   DE, HL         ; 1:4       u<=0
    pop  DE             ; 1:10      u<=0
    jp   nz, else306    ; 3:10      u<=0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif306       ; 3:10      else
else306:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif306:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_306(xm)   variant -1.A: step -1 and stop 0, run 7x
idx306 EQU $+1          ;           -1 +loop_306(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_306(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_306(xm)
    or    B             ; 1:4       -1 +loop_306(xm)
    dec  BC             ; 1:6       -1 +loop_306(xm)   index--
    jp   nz, do306save  ; 3:10      -1 +loop_306(xm)
leave306:               ;           -1 +loop_306(xm)
exit306:                ;           xloop LOOP_STACK
    ld   BC, string309  ; 3:10      print_i   Address of string310 ending with inverted most significant bit == string309
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_307(xm)
do307save:              ;           0 6 do_307(xm)
    ld  (idx307),BC     ; 4:20      0 6 do_307(xm)
do307:                  ;           0 6 do_307(xm)
    push DE             ; 1:11      i_307(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_307(m)
    ld   HL, (idx307)   ; 3:16      i_307(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u<=zero   _TMP_STACK_INFO #variant: variable
  .warning The condition "zero" cannot be evaluated
    ld    A, low zero   ; 2:7       u<=zero   HL<=zero --> 0<=zero-HL --> false if carry
    sub   L             ; 1:4       u<=zero   HL<=zero --> 0<=zero-HL --> false if carry
    ld    A, high zero  ; 2:7       u<=zero   HL<=zero --> 0<=zero-HL --> false if carry
    sbc   A, H          ; 1:4       u<=zero   HL<=zero --> 0<=zero-HL --> false if carry
    jp    c, else307    ; 3:10      u<=zero   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif307       ; 3:10      else
else307:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif307:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_307(xm)   variant -1.A: step -1 and stop 0, run 7x
idx307 EQU $+1          ;           -1 +loop_307(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_307(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_307(xm)
    or    B             ; 1:4       -1 +loop_307(xm)
    dec  BC             ; 1:6       -1 +loop_307(xm)   index--
    jp   nz, do307save  ; 3:10      -1 +loop_307(xm)
leave307:               ;           -1 +loop_307(xm)
exit307:                ;           xloop LOOP_STACK
    ld   BC, string311  ; 3:10      print_i   Address of string311 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_308(xm)
do308save:              ;           0 6 do_308(xm)
    ld  (idx308),BC     ; 4:20      0 6 do_308(xm)
do308:                  ;           0 6 do_308(xm)
    push DE             ; 1:11      i_308(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_308(m)
    ld   HL, (idx308)   ; 3:16      i_308(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u<=zero   _TMP_STACK_INFO #variant: variable
  .warning The condition "zero" cannot be evaluated
    ld    A, low zero   ; 2:7       u<=zero   HL<=zero --> 0<=zero-HL --> false if carry
    sub   L             ; 1:4       u<=zero   HL<=zero --> 0<=zero-HL --> false if carry
    ld    A, high zero  ; 2:7       u<=zero   HL<=zero --> 0<=zero-HL --> false if carry
    sbc   A, H          ; 1:4       u<=zero   HL<=zero --> 0<=zero-HL --> false if carry
    ex   DE, HL         ; 1:4       u<=zero
    pop  DE             ; 1:10      u<=zero
    jp    c, else308    ; 3:10      u<=zero   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif308       ; 3:10      else
else308:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif308:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_308(xm)   variant -1.A: step -1 and stop 0, run 7x
idx308 EQU $+1          ;           -1 +loop_308(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_308(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_308(xm)
    or    B             ; 1:4       -1 +loop_308(xm)
    dec  BC             ; 1:6       -1 +loop_308(xm)   index--
    jp   nz, do308save  ; 3:10      -1 +loop_308(xm)
leave308:               ;           -1 +loop_308(xm)
exit308:                ;           xloop LOOP_STACK
    ld   BC, string312  ; 3:10      print_i   Address of string312 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 1 ------
    ld   BC, 6          ; 3:10      0 6 do_309(xm)
do309save:              ;           0 6 do_309(xm)
    ld  (idx309),BC     ; 4:20      0 6 do_309(xm)
do309:                  ;           0 6 do_309(xm)
    push DE             ; 1:11      i_309(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_309(m)
    ld   HL, (idx309)   ; 3:16      i_309(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u<=+1   _TMP_STACK_INFO #variant: default
    ld    A, 0x01       ; 2:7       u<=+1   HL<=1 --> 0<=0x01-L --> false if carry
    sub   L             ; 1:4       u<=+1   HL<=1 --> 0<=0x01-L --> false if carry
    ld    A, 0x00       ; 2:7       u<=+1   HL<=1 --> 0<=0x00-H --> false if carry
    sbc   A, H          ; 1:4       u<=+1   HL<=1 --> 0<=0x00-H --> false if carry
    jp    c, else309    ; 3:10      u<=+1   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif309       ; 3:10      else
else309:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif309:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_309(xm)   variant -1.A: step -1 and stop 0, run 7x
idx309 EQU $+1          ;           -1 +loop_309(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_309(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_309(xm)
    or    B             ; 1:4       -1 +loop_309(xm)
    dec  BC             ; 1:6       -1 +loop_309(xm)   index--
    jp   nz, do309save  ; 3:10      -1 +loop_309(xm)
leave309:               ;           -1 +loop_309(xm)
exit309:                ;           xloop LOOP_STACK
    ld   BC, string313  ; 3:10      print_i   Address of string313 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_310(xm)
do310save:              ;           0 6 do_310(xm)
    ld  (idx310),BC     ; 4:20      0 6 do_310(xm)
do310:                  ;           0 6 do_310(xm)
    push DE             ; 1:11      i_310(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_310(m)
    ld   HL, (idx310)   ; 3:16      i_310(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u<=+1   _TMP_STACK_INFO #variant: default
    ld    A, 0x01       ; 2:7       u<=+1   HL<=1 --> 0<=0x01-L --> false if carry
    sub   L             ; 1:4       u<=+1   HL<=1 --> 0<=0x01-L --> false if carry
    ld    A, 0x00       ; 2:7       u<=+1   HL<=1 --> 0<=0x00-H --> false if carry
    sbc   A, H          ; 1:4       u<=+1   HL<=1 --> 0<=0x00-H --> false if carry
    ex   DE, HL         ; 1:4       u<=+1
    pop  DE             ; 1:10      u<=+1
    jp    c, else310    ; 3:10      u<=+1   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif310       ; 3:10      else
else310:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif310:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_310(xm)   variant -1.A: step -1 and stop 0, run 7x
idx310 EQU $+1          ;           -1 +loop_310(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_310(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_310(xm)
    or    B             ; 1:4       -1 +loop_310(xm)
    dec  BC             ; 1:6       -1 +loop_310(xm)   index--
    jp   nz, do310save  ; 3:10      -1 +loop_310(xm)
leave310:               ;           -1 +loop_310(xm)
exit310:                ;           xloop LOOP_STACK
    ld   BC, string313  ; 3:10      print_i   Address of string314 ending with inverted most significant bit == string313
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_311(xm)
do311save:              ;           0 6 do_311(xm)
    ld  (idx311),BC     ; 4:20      0 6 do_311(xm)
do311:                  ;           0 6 do_311(xm)
    push DE             ; 1:11      i_311(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_311(m)
    ld   HL, (idx311)   ; 3:16      i_311(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u<=p1   _TMP_STACK_INFO #variant: variable
  .warning The condition "p1" cannot be evaluated
    ld    A, low p1     ; 2:7       u<=p1   HL<=p1 --> 0<=p1-HL --> false if carry
    sub   L             ; 1:4       u<=p1   HL<=p1 --> 0<=p1-HL --> false if carry
    ld    A, high p1    ; 2:7       u<=p1   HL<=p1 --> 0<=p1-HL --> false if carry
    sbc   A, H          ; 1:4       u<=p1   HL<=p1 --> 0<=p1-HL --> false if carry
    jp    c, else311    ; 3:10      u<=p1   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif311       ; 3:10      else
else311:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif311:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_311(xm)   variant -1.A: step -1 and stop 0, run 7x
idx311 EQU $+1          ;           -1 +loop_311(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_311(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_311(xm)
    or    B             ; 1:4       -1 +loop_311(xm)
    dec  BC             ; 1:6       -1 +loop_311(xm)   index--
    jp   nz, do311save  ; 3:10      -1 +loop_311(xm)
leave311:               ;           -1 +loop_311(xm)
exit311:                ;           xloop LOOP_STACK
    ld   BC, string315  ; 3:10      print_i   Address of string315 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_312(xm)
do312save:              ;           0 6 do_312(xm)
    ld  (idx312),BC     ; 4:20      0 6 do_312(xm)
do312:                  ;           0 6 do_312(xm)
    push DE             ; 1:11      i_312(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_312(m)
    ld   HL, (idx312)   ; 3:16      i_312(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u<=p1   _TMP_STACK_INFO #variant: variable
  .warning The condition "p1" cannot be evaluated
    ld    A, low p1     ; 2:7       u<=p1   HL<=p1 --> 0<=p1-HL --> false if carry
    sub   L             ; 1:4       u<=p1   HL<=p1 --> 0<=p1-HL --> false if carry
    ld    A, high p1    ; 2:7       u<=p1   HL<=p1 --> 0<=p1-HL --> false if carry
    sbc   A, H          ; 1:4       u<=p1   HL<=p1 --> 0<=p1-HL --> false if carry
    ex   DE, HL         ; 1:4       u<=p1
    pop  DE             ; 1:10      u<=p1
    jp    c, else312    ; 3:10      u<=p1   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif312       ; 3:10      else
else312:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif312:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_312(xm)   variant -1.A: step -1 and stop 0, run 7x
idx312 EQU $+1          ;           -1 +loop_312(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_312(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_312(xm)
    or    B             ; 1:4       -1 +loop_312(xm)
    dec  BC             ; 1:6       -1 +loop_312(xm)   index--
    jp   nz, do312save  ; 3:10      -1 +loop_312(xm)
leave312:               ;           -1 +loop_312(xm)
exit312:                ;           xloop LOOP_STACK
    ld   BC, string316  ; 3:10      print_i   Address of string316 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3332 = 13106 ------
    ld   BC, 6          ; 3:10      0 6 do_313(xm)
do313save:              ;           0 6 do_313(xm)
    ld  (idx313),BC     ; 4:20      0 6 do_313(xm)
do313:                  ;           0 6 do_313(xm)
    push DE             ; 1:11      i_313(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_313(m)
    ld   HL, (idx313)   ; 3:16      i_313(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u<=+13106   _TMP_STACK_INFO #variant: default
    ld    A, 0x32       ; 2:7       u<=+13106   HL<=13106 --> 0<=0x32-L --> false if carry
    sub   L             ; 1:4       u<=+13106   HL<=13106 --> 0<=0x32-L --> false if carry
    ld    A, 0x33       ; 2:7       u<=+13106   HL<=13106 --> 0<=0x33-H --> false if carry
    sbc   A, H          ; 1:4       u<=+13106   HL<=13106 --> 0<=0x33-H --> false if carry
    jp    c, else313    ; 3:10      u<=+13106   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif313       ; 3:10      else
else313:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif313:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_313(xm)   variant -1.A: step -1 and stop 0, run 7x
idx313 EQU $+1          ;           -1 +loop_313(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_313(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_313(xm)
    or    B             ; 1:4       -1 +loop_313(xm)
    dec  BC             ; 1:6       -1 +loop_313(xm)   index--
    jp   nz, do313save  ; 3:10      -1 +loop_313(xm)
leave313:               ;           -1 +loop_313(xm)
exit313:                ;           xloop LOOP_STACK
    ld   BC, string317  ; 3:10      print_i   Address of string317 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_314(xm)
do314save:              ;           0 6 do_314(xm)
    ld  (idx314),BC     ; 4:20      0 6 do_314(xm)
do314:                  ;           0 6 do_314(xm)
    push DE             ; 1:11      i_314(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_314(m)
    ld   HL, (idx314)   ; 3:16      i_314(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u<=+13106   _TMP_STACK_INFO #variant: default
    ld    A, 0x32       ; 2:7       u<=+13106   HL<=13106 --> 0<=0x32-L --> false if carry
    sub   L             ; 1:4       u<=+13106   HL<=13106 --> 0<=0x32-L --> false if carry
    ld    A, 0x33       ; 2:7       u<=+13106   HL<=13106 --> 0<=0x33-H --> false if carry
    sbc   A, H          ; 1:4       u<=+13106   HL<=13106 --> 0<=0x33-H --> false if carry
    ex   DE, HL         ; 1:4       u<=+13106
    pop  DE             ; 1:10      u<=+13106
    jp    c, else314    ; 3:10      u<=+13106   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif314       ; 3:10      else
else314:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif314:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_314(xm)   variant -1.A: step -1 and stop 0, run 7x
idx314 EQU $+1          ;           -1 +loop_314(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_314(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_314(xm)
    or    B             ; 1:4       -1 +loop_314(xm)
    dec  BC             ; 1:6       -1 +loop_314(xm)   index--
    jp   nz, do314save  ; 3:10      -1 +loop_314(xm)
leave314:               ;           -1 +loop_314(xm)
exit314:                ;           xloop LOOP_STACK
    ld   BC, string317  ; 3:10      print_i   Address of string318 ending with inverted most significant bit == string317
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_315(xm)
do315save:              ;           0 6 do_315(xm)
    ld  (idx315),BC     ; 4:20      0 6 do_315(xm)
do315:                  ;           0 6 do_315(xm)
    push DE             ; 1:11      i_315(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_315(m)
    ld   HL, (idx315)   ; 3:16      i_315(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u<=x3332   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3332" cannot be evaluated
    ld    A, low x3332  ; 2:7       u<=x3332   HL<=x3332 --> 0<=x3332-HL --> false if carry
    sub   L             ; 1:4       u<=x3332   HL<=x3332 --> 0<=x3332-HL --> false if carry
    ld    A, high x3332 ; 2:7       u<=x3332   HL<=x3332 --> 0<=x3332-HL --> false if carry
    sbc   A, H          ; 1:4       u<=x3332   HL<=x3332 --> 0<=x3332-HL --> false if carry
    jp    c, else315    ; 3:10      u<=x3332   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif315       ; 3:10      else
else315:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif315:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_315(xm)   variant -1.A: step -1 and stop 0, run 7x
idx315 EQU $+1          ;           -1 +loop_315(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_315(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_315(xm)
    or    B             ; 1:4       -1 +loop_315(xm)
    dec  BC             ; 1:6       -1 +loop_315(xm)   index--
    jp   nz, do315save  ; 3:10      -1 +loop_315(xm)
leave315:               ;           -1 +loop_315(xm)
exit315:                ;           xloop LOOP_STACK
    ld   BC, string319  ; 3:10      print_i   Address of string319 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_316(xm)
do316save:              ;           0 6 do_316(xm)
    ld  (idx316),BC     ; 4:20      0 6 do_316(xm)
do316:                  ;           0 6 do_316(xm)
    push DE             ; 1:11      i_316(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_316(m)
    ld   HL, (idx316)   ; 3:16      i_316(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u<=x3332   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3332" cannot be evaluated
    ld    A, low x3332  ; 2:7       u<=x3332   HL<=x3332 --> 0<=x3332-HL --> false if carry
    sub   L             ; 1:4       u<=x3332   HL<=x3332 --> 0<=x3332-HL --> false if carry
    ld    A, high x3332 ; 2:7       u<=x3332   HL<=x3332 --> 0<=x3332-HL --> false if carry
    sbc   A, H          ; 1:4       u<=x3332   HL<=x3332 --> 0<=x3332-HL --> false if carry
    ex   DE, HL         ; 1:4       u<=x3332
    pop  DE             ; 1:10      u<=x3332
    jp    c, else316    ; 3:10      u<=x3332   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif316       ; 3:10      else
else316:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif316:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_316(xm)   variant -1.A: step -1 and stop 0, run 7x
idx316 EQU $+1          ;           -1 +loop_316(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_316(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_316(xm)
    or    B             ; 1:4       -1 +loop_316(xm)
    dec  BC             ; 1:6       -1 +loop_316(xm)   index--
    jp   nz, do316save  ; 3:10      -1 +loop_316(xm)
leave316:               ;           -1 +loop_316(xm)
exit316:                ;           xloop LOOP_STACK
    ld   BC, string320  ; 3:10      print_i   Address of string320 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3333 = 13107 ------
    ld   BC, 6          ; 3:10      0 6 do_317(xm)
do317save:              ;           0 6 do_317(xm)
    ld  (idx317),BC     ; 4:20      0 6 do_317(xm)
do317:                  ;           0 6 do_317(xm)
    push DE             ; 1:11      i_317(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_317(m)
    ld   HL, (idx317)   ; 3:16      i_317(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:25]     u<=+13107   _TMP_STACK_INFO #variant: hi == lo
    ld    A, 0x33       ; 2:7       u<=+13107   HL<=0x3333 --> 0<=0x3333-HL
    cp    L             ; 1:4       u<=+13107   HL<=0x3333 --> 0<=0x33-L --> false if carry
    sbc   A, H          ; 1:4       u<=+13107   HL<=0x3333 --> 0<=0x33-H --> false if carry
    jp    c, else317    ; 3:10      u<=+13107   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif317       ; 3:10      else
else317:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif317:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_317(xm)   variant -1.A: step -1 and stop 0, run 7x
idx317 EQU $+1          ;           -1 +loop_317(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_317(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_317(xm)
    or    B             ; 1:4       -1 +loop_317(xm)
    dec  BC             ; 1:6       -1 +loop_317(xm)   index--
    jp   nz, do317save  ; 3:10      -1 +loop_317(xm)
leave317:               ;           -1 +loop_317(xm)
exit317:                ;           xloop LOOP_STACK
    ld   BC, string321  ; 3:10      print_i   Address of string321 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_318(xm)
do318save:              ;           0 6 do_318(xm)
    ld  (idx318),BC     ; 4:20      0 6 do_318(xm)
do318:                  ;           0 6 do_318(xm)
    push DE             ; 1:11      i_318(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_318(m)
    ld   HL, (idx318)   ; 3:16      i_318(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:39]     u<=+13107   _TMP_STACK_INFO #variant: hi == lo
    ld    A, 0x33       ; 2:7       u<=+13107   HL<=0x3333 --> 0<=0x3333-HL
    cp    L             ; 1:4       u<=+13107   HL<=0x3333 --> 0<=0x33-L --> false if carry
    sbc   A, H          ; 1:4       u<=+13107   HL<=0x3333 --> 0<=0x33-H --> false if carry
    ex   DE, HL         ; 1:4       u<=+13107
    pop  DE             ; 1:10      u<=+13107
    jp    c, else318    ; 3:10      u<=+13107   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif318       ; 3:10      else
else318:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif318:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_318(xm)   variant -1.A: step -1 and stop 0, run 7x
idx318 EQU $+1          ;           -1 +loop_318(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_318(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_318(xm)
    or    B             ; 1:4       -1 +loop_318(xm)
    dec  BC             ; 1:6       -1 +loop_318(xm)   index--
    jp   nz, do318save  ; 3:10      -1 +loop_318(xm)
leave318:               ;           -1 +loop_318(xm)
exit318:                ;           xloop LOOP_STACK
    ld   BC, string321  ; 3:10      print_i   Address of string322 ending with inverted most significant bit == string321
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_319(xm)
do319save:              ;           0 6 do_319(xm)
    ld  (idx319),BC     ; 4:20      0 6 do_319(xm)
do319:                  ;           0 6 do_319(xm)
    push DE             ; 1:11      i_319(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_319(m)
    ld   HL, (idx319)   ; 3:16      i_319(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u<=x3333   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3333" cannot be evaluated
    ld    A, low x3333  ; 2:7       u<=x3333   HL<=x3333 --> 0<=x3333-HL --> false if carry
    sub   L             ; 1:4       u<=x3333   HL<=x3333 --> 0<=x3333-HL --> false if carry
    ld    A, high x3333 ; 2:7       u<=x3333   HL<=x3333 --> 0<=x3333-HL --> false if carry
    sbc   A, H          ; 1:4       u<=x3333   HL<=x3333 --> 0<=x3333-HL --> false if carry
    jp    c, else319    ; 3:10      u<=x3333   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif319       ; 3:10      else
else319:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif319:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_319(xm)   variant -1.A: step -1 and stop 0, run 7x
idx319 EQU $+1          ;           -1 +loop_319(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_319(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_319(xm)
    or    B             ; 1:4       -1 +loop_319(xm)
    dec  BC             ; 1:6       -1 +loop_319(xm)   index--
    jp   nz, do319save  ; 3:10      -1 +loop_319(xm)
leave319:               ;           -1 +loop_319(xm)
exit319:                ;           xloop LOOP_STACK
    ld   BC, string323  ; 3:10      print_i   Address of string323 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_320(xm)
do320save:              ;           0 6 do_320(xm)
    ld  (idx320),BC     ; 4:20      0 6 do_320(xm)
do320:                  ;           0 6 do_320(xm)
    push DE             ; 1:11      i_320(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_320(m)
    ld   HL, (idx320)   ; 3:16      i_320(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u<=x3333   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3333" cannot be evaluated
    ld    A, low x3333  ; 2:7       u<=x3333   HL<=x3333 --> 0<=x3333-HL --> false if carry
    sub   L             ; 1:4       u<=x3333   HL<=x3333 --> 0<=x3333-HL --> false if carry
    ld    A, high x3333 ; 2:7       u<=x3333   HL<=x3333 --> 0<=x3333-HL --> false if carry
    sbc   A, H          ; 1:4       u<=x3333   HL<=x3333 --> 0<=x3333-HL --> false if carry
    ex   DE, HL         ; 1:4       u<=x3333
    pop  DE             ; 1:10      u<=x3333
    jp    c, else320    ; 3:10      u<=x3333   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif320       ; 3:10      else
else320:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif320:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_320(xm)   variant -1.A: step -1 and stop 0, run 7x
idx320 EQU $+1          ;           -1 +loop_320(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_320(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_320(xm)
    or    B             ; 1:4       -1 +loop_320(xm)
    dec  BC             ; 1:6       -1 +loop_320(xm)   index--
    jp   nz, do320save  ; 3:10      -1 +loop_320(xm)
leave320:               ;           -1 +loop_320(xm)
exit320:                ;           xloop LOOP_STACK
    ld   BC, string324  ; 3:10      print_i   Address of string324 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3334 = 13108 ------
    ld   BC, 6          ; 3:10      0 6 do_321(xm)
do321save:              ;           0 6 do_321(xm)
    ld  (idx321),BC     ; 4:20      0 6 do_321(xm)
do321:                  ;           0 6 do_321(xm)
    push DE             ; 1:11      i_321(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_321(m)
    ld   HL, (idx321)   ; 3:16      i_321(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u<=+13108   _TMP_STACK_INFO #variant: default
    ld    A, 0x34       ; 2:7       u<=+13108   HL<=13108 --> 0<=0x34-L --> false if carry
    sub   L             ; 1:4       u<=+13108   HL<=13108 --> 0<=0x34-L --> false if carry
    ld    A, 0x33       ; 2:7       u<=+13108   HL<=13108 --> 0<=0x33-H --> false if carry
    sbc   A, H          ; 1:4       u<=+13108   HL<=13108 --> 0<=0x33-H --> false if carry
    jp    c, else321    ; 3:10      u<=+13108   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif321       ; 3:10      else
else321:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif321:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_321(xm)   variant -1.A: step -1 and stop 0, run 7x
idx321 EQU $+1          ;           -1 +loop_321(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_321(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_321(xm)
    or    B             ; 1:4       -1 +loop_321(xm)
    dec  BC             ; 1:6       -1 +loop_321(xm)   index--
    jp   nz, do321save  ; 3:10      -1 +loop_321(xm)
leave321:               ;           -1 +loop_321(xm)
exit321:                ;           xloop LOOP_STACK
    ld   BC, string325  ; 3:10      print_i   Address of string325 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_322(xm)
do322save:              ;           0 6 do_322(xm)
    ld  (idx322),BC     ; 4:20      0 6 do_322(xm)
do322:                  ;           0 6 do_322(xm)
    push DE             ; 1:11      i_322(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_322(m)
    ld   HL, (idx322)   ; 3:16      i_322(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u<=+13108   _TMP_STACK_INFO #variant: default
    ld    A, 0x34       ; 2:7       u<=+13108   HL<=13108 --> 0<=0x34-L --> false if carry
    sub   L             ; 1:4       u<=+13108   HL<=13108 --> 0<=0x34-L --> false if carry
    ld    A, 0x33       ; 2:7       u<=+13108   HL<=13108 --> 0<=0x33-H --> false if carry
    sbc   A, H          ; 1:4       u<=+13108   HL<=13108 --> 0<=0x33-H --> false if carry
    ex   DE, HL         ; 1:4       u<=+13108
    pop  DE             ; 1:10      u<=+13108
    jp    c, else322    ; 3:10      u<=+13108   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif322       ; 3:10      else
else322:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif322:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_322(xm)   variant -1.A: step -1 and stop 0, run 7x
idx322 EQU $+1          ;           -1 +loop_322(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_322(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_322(xm)
    or    B             ; 1:4       -1 +loop_322(xm)
    dec  BC             ; 1:6       -1 +loop_322(xm)   index--
    jp   nz, do322save  ; 3:10      -1 +loop_322(xm)
leave322:               ;           -1 +loop_322(xm)
exit322:                ;           xloop LOOP_STACK
    ld   BC, string325  ; 3:10      print_i   Address of string326 ending with inverted most significant bit == string325
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_323(xm)
do323save:              ;           0 6 do_323(xm)
    ld  (idx323),BC     ; 4:20      0 6 do_323(xm)
do323:                  ;           0 6 do_323(xm)
    push DE             ; 1:11      i_323(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_323(m)
    ld   HL, (idx323)   ; 3:16      i_323(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u<=x3334   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3334" cannot be evaluated
    ld    A, low x3334  ; 2:7       u<=x3334   HL<=x3334 --> 0<=x3334-HL --> false if carry
    sub   L             ; 1:4       u<=x3334   HL<=x3334 --> 0<=x3334-HL --> false if carry
    ld    A, high x3334 ; 2:7       u<=x3334   HL<=x3334 --> 0<=x3334-HL --> false if carry
    sbc   A, H          ; 1:4       u<=x3334   HL<=x3334 --> 0<=x3334-HL --> false if carry
    jp    c, else323    ; 3:10      u<=x3334   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif323       ; 3:10      else
else323:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif323:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_323(xm)   variant -1.A: step -1 and stop 0, run 7x
idx323 EQU $+1          ;           -1 +loop_323(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_323(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_323(xm)
    or    B             ; 1:4       -1 +loop_323(xm)
    dec  BC             ; 1:6       -1 +loop_323(xm)   index--
    jp   nz, do323save  ; 3:10      -1 +loop_323(xm)
leave323:               ;           -1 +loop_323(xm)
exit323:                ;           xloop LOOP_STACK
    ld   BC, string327  ; 3:10      print_i   Address of string327 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_324(xm)
do324save:              ;           0 6 do_324(xm)
    ld  (idx324),BC     ; 4:20      0 6 do_324(xm)
do324:                  ;           0 6 do_324(xm)
    push DE             ; 1:11      i_324(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_324(m)
    ld   HL, (idx324)   ; 3:16      i_324(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u<=x3334   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3334" cannot be evaluated
    ld    A, low x3334  ; 2:7       u<=x3334   HL<=x3334 --> 0<=x3334-HL --> false if carry
    sub   L             ; 1:4       u<=x3334   HL<=x3334 --> 0<=x3334-HL --> false if carry
    ld    A, high x3334 ; 2:7       u<=x3334   HL<=x3334 --> 0<=x3334-HL --> false if carry
    sbc   A, H          ; 1:4       u<=x3334   HL<=x3334 --> 0<=x3334-HL --> false if carry
    ex   DE, HL         ; 1:4       u<=x3334
    pop  DE             ; 1:10      u<=x3334
    jp    c, else324    ; 3:10      u<=x3334   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif324       ; 3:10      else
else324:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif324:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_324(xm)   variant -1.A: step -1 and stop 0, run 7x
idx324 EQU $+1          ;           -1 +loop_324(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_324(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_324(xm)
    or    B             ; 1:4       -1 +loop_324(xm)
    dec  BC             ; 1:6       -1 +loop_324(xm)   index--
    jp   nz, do324save  ; 3:10      -1 +loop_324(xm)
leave324:               ;           -1 +loop_324(xm)
exit324:                ;           xloop LOOP_STACK
    ld   BC, string328  ; 3:10      print_i   Address of string328 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- -2 ------
    ld   BC, 6          ; 3:10      0 6 do_325(xm)
do325save:              ;           0 6 do_325(xm)
    ld  (idx325),BC     ; 4:20      0 6 do_325(xm)
do325:                  ;           0 6 do_325(xm)
    push DE             ; 1:11      i_325(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_325(m)
    ld   HL, (idx325)   ; 3:16      i_325(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u<=-2   _TMP_STACK_INFO #variant: default
    ld    A, 0xFE       ; 2:7       u<=-2   HL<=-2 --> 0<=0xFE-L --> false if carry
    sub   L             ; 1:4       u<=-2   HL<=-2 --> 0<=0xFE-L --> false if carry
    ld    A, 0xFF       ; 2:7       u<=-2   HL<=-2 --> 0<=0xFF-H --> false if carry
    sbc   A, H          ; 1:4       u<=-2   HL<=-2 --> 0<=0xFF-H --> false if carry
    jp    c, else325    ; 3:10      u<=-2   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif325       ; 3:10      else
else325:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif325:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_325(xm)   variant -1.A: step -1 and stop 0, run 7x
idx325 EQU $+1          ;           -1 +loop_325(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_325(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_325(xm)
    or    B             ; 1:4       -1 +loop_325(xm)
    dec  BC             ; 1:6       -1 +loop_325(xm)   index--
    jp   nz, do325save  ; 3:10      -1 +loop_325(xm)
leave325:               ;           -1 +loop_325(xm)
exit325:                ;           xloop LOOP_STACK
    ld   BC, string329  ; 3:10      print_i   Address of string329 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_326(xm)
do326save:              ;           0 6 do_326(xm)
    ld  (idx326),BC     ; 4:20      0 6 do_326(xm)
do326:                  ;           0 6 do_326(xm)
    push DE             ; 1:11      i_326(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_326(m)
    ld   HL, (idx326)   ; 3:16      i_326(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u<=-2   _TMP_STACK_INFO #variant: default
    ld    A, 0xFE       ; 2:7       u<=-2   HL<=-2 --> 0<=0xFE-L --> false if carry
    sub   L             ; 1:4       u<=-2   HL<=-2 --> 0<=0xFE-L --> false if carry
    ld    A, 0xFF       ; 2:7       u<=-2   HL<=-2 --> 0<=0xFF-H --> false if carry
    sbc   A, H          ; 1:4       u<=-2   HL<=-2 --> 0<=0xFF-H --> false if carry
    ex   DE, HL         ; 1:4       u<=-2
    pop  DE             ; 1:10      u<=-2
    jp    c, else326    ; 3:10      u<=-2   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif326       ; 3:10      else
else326:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif326:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_326(xm)   variant -1.A: step -1 and stop 0, run 7x
idx326 EQU $+1          ;           -1 +loop_326(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_326(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_326(xm)
    or    B             ; 1:4       -1 +loop_326(xm)
    dec  BC             ; 1:6       -1 +loop_326(xm)   index--
    jp   nz, do326save  ; 3:10      -1 +loop_326(xm)
leave326:               ;           -1 +loop_326(xm)
exit326:                ;           xloop LOOP_STACK
    ld   BC, string329  ; 3:10      print_i   Address of string330 ending with inverted most significant bit == string329
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_327(xm)
do327save:              ;           0 6 do_327(xm)
    ld  (idx327),BC     ; 4:20      0 6 do_327(xm)
do327:                  ;           0 6 do_327(xm)
    push DE             ; 1:11      i_327(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_327(m)
    ld   HL, (idx327)   ; 3:16      i_327(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u<=m2   _TMP_STACK_INFO #variant: variable
  .warning The condition "m2" cannot be evaluated
    ld    A, low m2     ; 2:7       u<=m2   HL<=m2 --> 0<=m2-HL --> false if carry
    sub   L             ; 1:4       u<=m2   HL<=m2 --> 0<=m2-HL --> false if carry
    ld    A, high m2    ; 2:7       u<=m2   HL<=m2 --> 0<=m2-HL --> false if carry
    sbc   A, H          ; 1:4       u<=m2   HL<=m2 --> 0<=m2-HL --> false if carry
    jp    c, else327    ; 3:10      u<=m2   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif327       ; 3:10      else
else327:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif327:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_327(xm)   variant -1.A: step -1 and stop 0, run 7x
idx327 EQU $+1          ;           -1 +loop_327(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_327(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_327(xm)
    or    B             ; 1:4       -1 +loop_327(xm)
    dec  BC             ; 1:6       -1 +loop_327(xm)   index--
    jp   nz, do327save  ; 3:10      -1 +loop_327(xm)
leave327:               ;           -1 +loop_327(xm)
exit327:                ;           xloop LOOP_STACK
    ld   BC, string331  ; 3:10      print_i   Address of string331 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_328(xm)
do328save:              ;           0 6 do_328(xm)
    ld  (idx328),BC     ; 4:20      0 6 do_328(xm)
do328:                  ;           0 6 do_328(xm)
    push DE             ; 1:11      i_328(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_328(m)
    ld   HL, (idx328)   ; 3:16      i_328(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u<=m2   _TMP_STACK_INFO #variant: variable
  .warning The condition "m2" cannot be evaluated
    ld    A, low m2     ; 2:7       u<=m2   HL<=m2 --> 0<=m2-HL --> false if carry
    sub   L             ; 1:4       u<=m2   HL<=m2 --> 0<=m2-HL --> false if carry
    ld    A, high m2    ; 2:7       u<=m2   HL<=m2 --> 0<=m2-HL --> false if carry
    sbc   A, H          ; 1:4       u<=m2   HL<=m2 --> 0<=m2-HL --> false if carry
    ex   DE, HL         ; 1:4       u<=m2
    pop  DE             ; 1:10      u<=m2
    jp    c, else328    ; 3:10      u<=m2   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif328       ; 3:10      else
else328:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif328:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_328(xm)   variant -1.A: step -1 and stop 0, run 7x
idx328 EQU $+1          ;           -1 +loop_328(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_328(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_328(xm)
    or    B             ; 1:4       -1 +loop_328(xm)
    dec  BC             ; 1:6       -1 +loop_328(xm)   index--
    jp   nz, do328save  ; 3:10      -1 +loop_328(xm)
leave328:               ;           -1 +loop_328(xm)
exit328:                ;           xloop LOOP_STACK
    ld   BC, string332  ; 3:10      print_i   Address of string332 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- -1 ------
    ld   BC, 6          ; 3:10      0 6 do_329(xm)
do329save:              ;           0 6 do_329(xm)
    ld  (idx329),BC     ; 4:20      0 6 do_329(xm)
do329:                  ;           0 6 do_329(xm)
    push DE             ; 1:11      i_329(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_329(m)
    ld   HL, (idx329)   ; 3:16      i_329(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[0:0]      u<=-1   _TMP_STACK_INFO variant: u<=max
  .warning The condition is always True!
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif329       ; 3:10      else
else329:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif329:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_329(xm)   variant -1.A: step -1 and stop 0, run 7x
idx329 EQU $+1          ;           -1 +loop_329(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_329(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_329(xm)
    or    B             ; 1:4       -1 +loop_329(xm)
    dec  BC             ; 1:6       -1 +loop_329(xm)   index--
    jp   nz, do329save  ; 3:10      -1 +loop_329(xm)
leave329:               ;           -1 +loop_329(xm)
exit329:                ;           xloop LOOP_STACK
    ld   BC, string333  ; 3:10      print_i   Address of string333 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_330(xm)
do330save:              ;           0 6 do_330(xm)
    ld  (idx330),BC     ; 4:20      0 6 do_330(xm)
do330:                  ;           0 6 do_330(xm)
    push DE             ; 1:11      i_330(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_330(m)
    ld   HL, (idx330)   ; 3:16      i_330(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[2:14]     u<=-1   _TMP_STACK_INFO variant: u<=max
  .warning The condition is always True!
    ex   DE, HL         ; 1:4       u<=-1
    pop  DE             ; 1:10      u<=-1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif330       ; 3:10      else
else330:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif330:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_330(xm)   variant -1.A: step -1 and stop 0, run 7x
idx330 EQU $+1          ;           -1 +loop_330(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_330(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_330(xm)
    or    B             ; 1:4       -1 +loop_330(xm)
    dec  BC             ; 1:6       -1 +loop_330(xm)   index--
    jp   nz, do330save  ; 3:10      -1 +loop_330(xm)
leave330:               ;           -1 +loop_330(xm)
exit330:                ;           xloop LOOP_STACK
    ld   BC, string333  ; 3:10      print_i   Address of string334 ending with inverted most significant bit == string333
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_331(xm)
do331save:              ;           0 6 do_331(xm)
    ld  (idx331),BC     ; 4:20      0 6 do_331(xm)
do331:                  ;           0 6 do_331(xm)
    push DE             ; 1:11      i_331(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_331(m)
    ld   HL, (idx331)   ; 3:16      i_331(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u<=m1   _TMP_STACK_INFO #variant: variable
  .warning The condition "m1" cannot be evaluated
    ld    A, low m1     ; 2:7       u<=m1   HL<=m1 --> 0<=m1-HL --> false if carry
    sub   L             ; 1:4       u<=m1   HL<=m1 --> 0<=m1-HL --> false if carry
    ld    A, high m1    ; 2:7       u<=m1   HL<=m1 --> 0<=m1-HL --> false if carry
    sbc   A, H          ; 1:4       u<=m1   HL<=m1 --> 0<=m1-HL --> false if carry
    jp    c, else331    ; 3:10      u<=m1   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif331       ; 3:10      else
else331:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif331:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_331(xm)   variant -1.A: step -1 and stop 0, run 7x
idx331 EQU $+1          ;           -1 +loop_331(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_331(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_331(xm)
    or    B             ; 1:4       -1 +loop_331(xm)
    dec  BC             ; 1:6       -1 +loop_331(xm)   index--
    jp   nz, do331save  ; 3:10      -1 +loop_331(xm)
leave331:               ;           -1 +loop_331(xm)
exit331:                ;           xloop LOOP_STACK
    ld   BC, string335  ; 3:10      print_i   Address of string335 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_332(xm)
do332save:              ;           0 6 do_332(xm)
    ld  (idx332),BC     ; 4:20      0 6 do_332(xm)
do332:                  ;           0 6 do_332(xm)
    push DE             ; 1:11      i_332(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_332(m)
    ld   HL, (idx332)   ; 3:16      i_332(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u<=m1   _TMP_STACK_INFO #variant: variable
  .warning The condition "m1" cannot be evaluated
    ld    A, low m1     ; 2:7       u<=m1   HL<=m1 --> 0<=m1-HL --> false if carry
    sub   L             ; 1:4       u<=m1   HL<=m1 --> 0<=m1-HL --> false if carry
    ld    A, high m1    ; 2:7       u<=m1   HL<=m1 --> 0<=m1-HL --> false if carry
    sbc   A, H          ; 1:4       u<=m1   HL<=m1 --> 0<=m1-HL --> false if carry
    ex   DE, HL         ; 1:4       u<=m1
    pop  DE             ; 1:10      u<=m1
    jp    c, else332    ; 3:10      u<=m1   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif332       ; 3:10      else
else332:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif332:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_332(xm)   variant -1.A: step -1 and stop 0, run 7x
idx332 EQU $+1          ;           -1 +loop_332(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_332(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_332(xm)
    or    B             ; 1:4       -1 +loop_332(xm)
    dec  BC             ; 1:6       -1 +loop_332(xm)   index--
    jp   nz, do332save  ; 3:10      -1 +loop_332(xm)
leave332:               ;           -1 +loop_332(xm)
exit332:                ;           xloop LOOP_STACK
    ld   BC, string336  ; 3:10      print_i   Address of string336 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0 ------
    ld   BC, 6          ; 3:10      0 6 do_333(xm)
do333save:              ;           0 6 do_333(xm)
    ld  (idx333),BC     ; 4:20      0 6 do_333(xm)
do333:                  ;           0 6 do_333(xm)
    push DE             ; 1:11      i_333(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_333(m)
    ld   HL, (idx333)   ; 3:16      i_333(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[0:0]      u>=0   _TMP_STACK_INFO variant: u>=min
  .warning The condition is always True!
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif333       ; 3:10      else
else333:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif333:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_333(xm)   variant -1.A: step -1 and stop 0, run 7x
idx333 EQU $+1          ;           -1 +loop_333(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_333(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_333(xm)
    or    B             ; 1:4       -1 +loop_333(xm)
    dec  BC             ; 1:6       -1 +loop_333(xm)   index--
    jp   nz, do333save  ; 3:10      -1 +loop_333(xm)
leave333:               ;           -1 +loop_333(xm)
exit333:                ;           xloop LOOP_STACK
    ld   BC, string337  ; 3:10      print_i   Address of string337 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_334(xm)
do334save:              ;           0 6 do_334(xm)
    ld  (idx334),BC     ; 4:20      0 6 do_334(xm)
do334:                  ;           0 6 do_334(xm)
    push DE             ; 1:11      i_334(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_334(m)
    ld   HL, (idx334)   ; 3:16      i_334(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[2:14]     u>=0   _TMP_STACK_INFO variant: u>=min
  .warning The condition is always True!
    ex   DE, HL         ; 1:4       u>=0
    pop  DE             ; 1:10      u>=0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif334       ; 3:10      else
else334:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif334:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_334(xm)   variant -1.A: step -1 and stop 0, run 7x
idx334 EQU $+1          ;           -1 +loop_334(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_334(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_334(xm)
    or    B             ; 1:4       -1 +loop_334(xm)
    dec  BC             ; 1:6       -1 +loop_334(xm)   index--
    jp   nz, do334save  ; 3:10      -1 +loop_334(xm)
leave334:               ;           -1 +loop_334(xm)
exit334:                ;           xloop LOOP_STACK
    ld   BC, string337  ; 3:10      print_i   Address of string338 ending with inverted most significant bit == string337
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_335(xm)
do335save:              ;           0 6 do_335(xm)
    ld  (idx335),BC     ; 4:20      0 6 do_335(xm)
do335:                  ;           0 6 do_335(xm)
    push DE             ; 1:11      i_335(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_335(m)
    ld   HL, (idx335)   ; 3:16      i_335(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u>=zero   _TMP_STACK_INFO #variant: variable
  .warning The condition "zero" cannot be evaluated
    ld    A, L          ; 1:4       u>=zero   HL>=zero --> HL-zero>=0 --> false if carry
    sub   low zero      ; 2:7       u>=zero   HL>=zero --> HL-zero>=0 --> false if carry
    ld    A, H          ; 1:4       u>=zero   HL>=zero --> HL-zero>=0 --> false if carry
    sbc   A, high zero  ; 2:7       u>=zero   HL>=zero --> HL-zero>=0 --> false if carry
    jp    c, else335    ; 3:10      u>=zero   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif335       ; 3:10      else
else335:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif335:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_335(xm)   variant -1.A: step -1 and stop 0, run 7x
idx335 EQU $+1          ;           -1 +loop_335(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_335(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_335(xm)
    or    B             ; 1:4       -1 +loop_335(xm)
    dec  BC             ; 1:6       -1 +loop_335(xm)   index--
    jp   nz, do335save  ; 3:10      -1 +loop_335(xm)
leave335:               ;           -1 +loop_335(xm)
exit335:                ;           xloop LOOP_STACK
    ld   BC, string339  ; 3:10      print_i   Address of string339 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_336(xm)
do336save:              ;           0 6 do_336(xm)
    ld  (idx336),BC     ; 4:20      0 6 do_336(xm)
do336:                  ;           0 6 do_336(xm)
    push DE             ; 1:11      i_336(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_336(m)
    ld   HL, (idx336)   ; 3:16      i_336(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u>=zero   _TMP_STACK_INFO #variant: variable
  .warning The condition "zero" cannot be evaluated
    ld    A, L          ; 1:4       u>=zero   HL>=zero --> HL-zero>=0 --> false if carry
    sub   low zero      ; 2:7       u>=zero   HL>=zero --> HL-zero>=0 --> false if carry
    ld    A, H          ; 1:4       u>=zero   HL>=zero --> HL-zero>=0 --> false if carry
    sbc   A, high zero  ; 2:7       u>=zero   HL>=zero --> HL-zero>=0 --> false if carry
    ex   DE, HL         ; 1:4       u>=zero
    pop  DE             ; 1:10      u>=zero
    jp    c, else336    ; 3:10      u>=zero   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif336       ; 3:10      else
else336:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif336:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_336(xm)   variant -1.A: step -1 and stop 0, run 7x
idx336 EQU $+1          ;           -1 +loop_336(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_336(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_336(xm)
    or    B             ; 1:4       -1 +loop_336(xm)
    dec  BC             ; 1:6       -1 +loop_336(xm)   index--
    jp   nz, do336save  ; 3:10      -1 +loop_336(xm)
leave336:               ;           -1 +loop_336(xm)
exit336:                ;           xloop LOOP_STACK
    ld   BC, string340  ; 3:10      print_i   Address of string340 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 1 ------
    ld   BC, 6          ; 3:10      0 6 do_337(xm)
do337save:              ;           0 6 do_337(xm)
    ld  (idx337),BC     ; 4:20      0 6 do_337(xm)
do337:                  ;           0 6 do_337(xm)
    push DE             ; 1:11      i_337(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_337(m)
    ld   HL, (idx337)   ; 3:16      i_337(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:25]     u>=+1   _TMP_STACK_INFO #variant: hi == lo-1
    ld    A, 0x00       ; 2:7       u>=+1   HL>=0x0001 --> HL> 0x0000
    cp    L             ; 1:4       u>=+1   HL> 0x0000 -->  0> 0x00-L --> false if not carry
    sbc   A, H          ; 1:4       u>=+1   HL> 0x0000 -->  0> 0x00-H --> false if not carry
    jp   nc, else337    ; 3:10      u>=+1   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif337       ; 3:10      else
else337:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif337:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_337(xm)   variant -1.A: step -1 and stop 0, run 7x
idx337 EQU $+1          ;           -1 +loop_337(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_337(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_337(xm)
    or    B             ; 1:4       -1 +loop_337(xm)
    dec  BC             ; 1:6       -1 +loop_337(xm)   index--
    jp   nz, do337save  ; 3:10      -1 +loop_337(xm)
leave337:               ;           -1 +loop_337(xm)
exit337:                ;           xloop LOOP_STACK
    ld   BC, string341  ; 3:10      print_i   Address of string341 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_338(xm)
do338save:              ;           0 6 do_338(xm)
    ld  (idx338),BC     ; 4:20      0 6 do_338(xm)
do338:                  ;           0 6 do_338(xm)
    push DE             ; 1:11      i_338(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_338(m)
    ld   HL, (idx338)   ; 3:16      i_338(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:39]     u>=+1   _TMP_STACK_INFO #variant: hi == lo-1
    ld    A, 0x00       ; 2:7       u>=+1   HL>=0x0001 --> HL> 0x0000
    cp    L             ; 1:4       u>=+1   HL> 0x0000 -->  0> 0x00-L --> false if not carry
    sbc   A, H          ; 1:4       u>=+1   HL> 0x0000 -->  0> 0x00-H --> false if not carry
    ex   DE, HL         ; 1:4       u>=+1
    pop  DE             ; 1:10      u>=+1
    jp   nc, else338    ; 3:10      u>=+1   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif338       ; 3:10      else
else338:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif338:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_338(xm)   variant -1.A: step -1 and stop 0, run 7x
idx338 EQU $+1          ;           -1 +loop_338(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_338(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_338(xm)
    or    B             ; 1:4       -1 +loop_338(xm)
    dec  BC             ; 1:6       -1 +loop_338(xm)   index--
    jp   nz, do338save  ; 3:10      -1 +loop_338(xm)
leave338:               ;           -1 +loop_338(xm)
exit338:                ;           xloop LOOP_STACK
    ld   BC, string341  ; 3:10      print_i   Address of string342 ending with inverted most significant bit == string341
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_339(xm)
do339save:              ;           0 6 do_339(xm)
    ld  (idx339),BC     ; 4:20      0 6 do_339(xm)
do339:                  ;           0 6 do_339(xm)
    push DE             ; 1:11      i_339(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_339(m)
    ld   HL, (idx339)   ; 3:16      i_339(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u>=p1   _TMP_STACK_INFO #variant: variable
  .warning The condition "p1" cannot be evaluated
    ld    A, L          ; 1:4       u>=p1   HL>=p1 --> HL-p1>=0 --> false if carry
    sub   low p1        ; 2:7       u>=p1   HL>=p1 --> HL-p1>=0 --> false if carry
    ld    A, H          ; 1:4       u>=p1   HL>=p1 --> HL-p1>=0 --> false if carry
    sbc   A, high p1    ; 2:7       u>=p1   HL>=p1 --> HL-p1>=0 --> false if carry
    jp    c, else339    ; 3:10      u>=p1   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif339       ; 3:10      else
else339:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif339:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_339(xm)   variant -1.A: step -1 and stop 0, run 7x
idx339 EQU $+1          ;           -1 +loop_339(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_339(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_339(xm)
    or    B             ; 1:4       -1 +loop_339(xm)
    dec  BC             ; 1:6       -1 +loop_339(xm)   index--
    jp   nz, do339save  ; 3:10      -1 +loop_339(xm)
leave339:               ;           -1 +loop_339(xm)
exit339:                ;           xloop LOOP_STACK
    ld   BC, string343  ; 3:10      print_i   Address of string343 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_340(xm)
do340save:              ;           0 6 do_340(xm)
    ld  (idx340),BC     ; 4:20      0 6 do_340(xm)
do340:                  ;           0 6 do_340(xm)
    push DE             ; 1:11      i_340(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_340(m)
    ld   HL, (idx340)   ; 3:16      i_340(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u>=p1   _TMP_STACK_INFO #variant: variable
  .warning The condition "p1" cannot be evaluated
    ld    A, L          ; 1:4       u>=p1   HL>=p1 --> HL-p1>=0 --> false if carry
    sub   low p1        ; 2:7       u>=p1   HL>=p1 --> HL-p1>=0 --> false if carry
    ld    A, H          ; 1:4       u>=p1   HL>=p1 --> HL-p1>=0 --> false if carry
    sbc   A, high p1    ; 2:7       u>=p1   HL>=p1 --> HL-p1>=0 --> false if carry
    ex   DE, HL         ; 1:4       u>=p1
    pop  DE             ; 1:10      u>=p1
    jp    c, else340    ; 3:10      u>=p1   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif340       ; 3:10      else
else340:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif340:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_340(xm)   variant -1.A: step -1 and stop 0, run 7x
idx340 EQU $+1          ;           -1 +loop_340(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_340(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_340(xm)
    or    B             ; 1:4       -1 +loop_340(xm)
    dec  BC             ; 1:6       -1 +loop_340(xm)   index--
    jp   nz, do340save  ; 3:10      -1 +loop_340(xm)
leave340:               ;           -1 +loop_340(xm)
exit340:                ;           xloop LOOP_STACK
    ld   BC, string344  ; 3:10      print_i   Address of string344 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3332 = 13106 ------
    ld   BC, 6          ; 3:10      0 6 do_341(xm)
do341save:              ;           0 6 do_341(xm)
    ld  (idx341),BC     ; 4:20      0 6 do_341(xm)
do341:                  ;           0 6 do_341(xm)
    push DE             ; 1:11      i_341(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_341(m)
    ld   HL, (idx341)   ; 3:16      i_341(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u>=+13106   _TMP_STACK_INFO #variant: default
    ld    A, L          ; 1:4       u>=+13106   HL>=13106 --> L-0x32>=0 --> false if carry
    sub  0x32           ; 2:7       u>=+13106   HL>=13106 --> L-0x32>=0 --> false if carry
    ld    A, H          ; 1:4       u>=+13106   HL>=13106 --> H-0x33>=0 --> false if carry
    sbc   A, 0x33       ; 2:7       u>=+13106   HL>=13106 --> H-0x33>=0 --> false if carry
    jp    c, else341    ; 3:10      u>=+13106   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif341       ; 3:10      else
else341:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif341:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_341(xm)   variant -1.A: step -1 and stop 0, run 7x
idx341 EQU $+1          ;           -1 +loop_341(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_341(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_341(xm)
    or    B             ; 1:4       -1 +loop_341(xm)
    dec  BC             ; 1:6       -1 +loop_341(xm)   index--
    jp   nz, do341save  ; 3:10      -1 +loop_341(xm)
leave341:               ;           -1 +loop_341(xm)
exit341:                ;           xloop LOOP_STACK
    ld   BC, string345  ; 3:10      print_i   Address of string345 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_342(xm)
do342save:              ;           0 6 do_342(xm)
    ld  (idx342),BC     ; 4:20      0 6 do_342(xm)
do342:                  ;           0 6 do_342(xm)
    push DE             ; 1:11      i_342(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_342(m)
    ld   HL, (idx342)   ; 3:16      i_342(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u>=+13106   _TMP_STACK_INFO #variant: default
    ld    A, L          ; 1:4       u>=+13106   HL>=13106 --> L-0x32>=0 --> false if carry
    sub  0x32           ; 2:7       u>=+13106   HL>=13106 --> L-0x32>=0 --> false if carry
    ld    A, H          ; 1:4       u>=+13106   HL>=13106 --> H-0x33>=0 --> false if carry
    sbc   A, 0x33       ; 2:7       u>=+13106   HL>=13106 --> H-0x33>=0 --> false if carry
    ex   DE, HL         ; 1:4       u>=+13106
    pop  DE             ; 1:10      u>=+13106
    jp    c, else342    ; 3:10      u>=+13106   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif342       ; 3:10      else
else342:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif342:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_342(xm)   variant -1.A: step -1 and stop 0, run 7x
idx342 EQU $+1          ;           -1 +loop_342(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_342(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_342(xm)
    or    B             ; 1:4       -1 +loop_342(xm)
    dec  BC             ; 1:6       -1 +loop_342(xm)   index--
    jp   nz, do342save  ; 3:10      -1 +loop_342(xm)
leave342:               ;           -1 +loop_342(xm)
exit342:                ;           xloop LOOP_STACK
    ld   BC, string345  ; 3:10      print_i   Address of string346 ending with inverted most significant bit == string345
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_343(xm)
do343save:              ;           0 6 do_343(xm)
    ld  (idx343),BC     ; 4:20      0 6 do_343(xm)
do343:                  ;           0 6 do_343(xm)
    push DE             ; 1:11      i_343(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_343(m)
    ld   HL, (idx343)   ; 3:16      i_343(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u>=x3332   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3332" cannot be evaluated
    ld    A, L          ; 1:4       u>=x3332   HL>=x3332 --> HL-x3332>=0 --> false if carry
    sub   low x3332     ; 2:7       u>=x3332   HL>=x3332 --> HL-x3332>=0 --> false if carry
    ld    A, H          ; 1:4       u>=x3332   HL>=x3332 --> HL-x3332>=0 --> false if carry
    sbc   A, high x3332 ; 2:7       u>=x3332   HL>=x3332 --> HL-x3332>=0 --> false if carry
    jp    c, else343    ; 3:10      u>=x3332   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif343       ; 3:10      else
else343:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif343:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_343(xm)   variant -1.A: step -1 and stop 0, run 7x
idx343 EQU $+1          ;           -1 +loop_343(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_343(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_343(xm)
    or    B             ; 1:4       -1 +loop_343(xm)
    dec  BC             ; 1:6       -1 +loop_343(xm)   index--
    jp   nz, do343save  ; 3:10      -1 +loop_343(xm)
leave343:               ;           -1 +loop_343(xm)
exit343:                ;           xloop LOOP_STACK
    ld   BC, string347  ; 3:10      print_i   Address of string347 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_344(xm)
do344save:              ;           0 6 do_344(xm)
    ld  (idx344),BC     ; 4:20      0 6 do_344(xm)
do344:                  ;           0 6 do_344(xm)
    push DE             ; 1:11      i_344(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_344(m)
    ld   HL, (idx344)   ; 3:16      i_344(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u>=x3332   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3332" cannot be evaluated
    ld    A, L          ; 1:4       u>=x3332   HL>=x3332 --> HL-x3332>=0 --> false if carry
    sub   low x3332     ; 2:7       u>=x3332   HL>=x3332 --> HL-x3332>=0 --> false if carry
    ld    A, H          ; 1:4       u>=x3332   HL>=x3332 --> HL-x3332>=0 --> false if carry
    sbc   A, high x3332 ; 2:7       u>=x3332   HL>=x3332 --> HL-x3332>=0 --> false if carry
    ex   DE, HL         ; 1:4       u>=x3332
    pop  DE             ; 1:10      u>=x3332
    jp    c, else344    ; 3:10      u>=x3332   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif344       ; 3:10      else
else344:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif344:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_344(xm)   variant -1.A: step -1 and stop 0, run 7x
idx344 EQU $+1          ;           -1 +loop_344(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_344(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_344(xm)
    or    B             ; 1:4       -1 +loop_344(xm)
    dec  BC             ; 1:6       -1 +loop_344(xm)   index--
    jp   nz, do344save  ; 3:10      -1 +loop_344(xm)
leave344:               ;           -1 +loop_344(xm)
exit344:                ;           xloop LOOP_STACK
    ld   BC, string348  ; 3:10      print_i   Address of string348 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3333 = 13107 ------
    ld   BC, 6          ; 3:10      0 6 do_345(xm)
do345save:              ;           0 6 do_345(xm)
    ld  (idx345),BC     ; 4:20      0 6 do_345(xm)
do345:                  ;           0 6 do_345(xm)
    push DE             ; 1:11      i_345(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_345(m)
    ld   HL, (idx345)   ; 3:16      i_345(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u>=+13107   _TMP_STACK_INFO #variant: default
    ld    A, L          ; 1:4       u>=+13107   HL>=13107 --> L-0x33>=0 --> false if carry
    sub  0x33           ; 2:7       u>=+13107   HL>=13107 --> L-0x33>=0 --> false if carry
    ld    A, H          ; 1:4       u>=+13107   HL>=13107 --> H-0x33>=0 --> false if carry
    sbc   A, 0x33       ; 2:7       u>=+13107   HL>=13107 --> H-0x33>=0 --> false if carry
    jp    c, else345    ; 3:10      u>=+13107   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif345       ; 3:10      else
else345:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif345:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_345(xm)   variant -1.A: step -1 and stop 0, run 7x
idx345 EQU $+1          ;           -1 +loop_345(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_345(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_345(xm)
    or    B             ; 1:4       -1 +loop_345(xm)
    dec  BC             ; 1:6       -1 +loop_345(xm)   index--
    jp   nz, do345save  ; 3:10      -1 +loop_345(xm)
leave345:               ;           -1 +loop_345(xm)
exit345:                ;           xloop LOOP_STACK
    ld   BC, string349  ; 3:10      print_i   Address of string349 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_346(xm)
do346save:              ;           0 6 do_346(xm)
    ld  (idx346),BC     ; 4:20      0 6 do_346(xm)
do346:                  ;           0 6 do_346(xm)
    push DE             ; 1:11      i_346(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_346(m)
    ld   HL, (idx346)   ; 3:16      i_346(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u>=+13107   _TMP_STACK_INFO #variant: default
    ld    A, L          ; 1:4       u>=+13107   HL>=13107 --> L-0x33>=0 --> false if carry
    sub  0x33           ; 2:7       u>=+13107   HL>=13107 --> L-0x33>=0 --> false if carry
    ld    A, H          ; 1:4       u>=+13107   HL>=13107 --> H-0x33>=0 --> false if carry
    sbc   A, 0x33       ; 2:7       u>=+13107   HL>=13107 --> H-0x33>=0 --> false if carry
    ex   DE, HL         ; 1:4       u>=+13107
    pop  DE             ; 1:10      u>=+13107
    jp    c, else346    ; 3:10      u>=+13107   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif346       ; 3:10      else
else346:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif346:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_346(xm)   variant -1.A: step -1 and stop 0, run 7x
idx346 EQU $+1          ;           -1 +loop_346(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_346(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_346(xm)
    or    B             ; 1:4       -1 +loop_346(xm)
    dec  BC             ; 1:6       -1 +loop_346(xm)   index--
    jp   nz, do346save  ; 3:10      -1 +loop_346(xm)
leave346:               ;           -1 +loop_346(xm)
exit346:                ;           xloop LOOP_STACK
    ld   BC, string349  ; 3:10      print_i   Address of string350 ending with inverted most significant bit == string349
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_347(xm)
do347save:              ;           0 6 do_347(xm)
    ld  (idx347),BC     ; 4:20      0 6 do_347(xm)
do347:                  ;           0 6 do_347(xm)
    push DE             ; 1:11      i_347(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_347(m)
    ld   HL, (idx347)   ; 3:16      i_347(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u>=x3333   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3333" cannot be evaluated
    ld    A, L          ; 1:4       u>=x3333   HL>=x3333 --> HL-x3333>=0 --> false if carry
    sub   low x3333     ; 2:7       u>=x3333   HL>=x3333 --> HL-x3333>=0 --> false if carry
    ld    A, H          ; 1:4       u>=x3333   HL>=x3333 --> HL-x3333>=0 --> false if carry
    sbc   A, high x3333 ; 2:7       u>=x3333   HL>=x3333 --> HL-x3333>=0 --> false if carry
    jp    c, else347    ; 3:10      u>=x3333   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif347       ; 3:10      else
else347:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif347:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_347(xm)   variant -1.A: step -1 and stop 0, run 7x
idx347 EQU $+1          ;           -1 +loop_347(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_347(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_347(xm)
    or    B             ; 1:4       -1 +loop_347(xm)
    dec  BC             ; 1:6       -1 +loop_347(xm)   index--
    jp   nz, do347save  ; 3:10      -1 +loop_347(xm)
leave347:               ;           -1 +loop_347(xm)
exit347:                ;           xloop LOOP_STACK
    ld   BC, string351  ; 3:10      print_i   Address of string351 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_348(xm)
do348save:              ;           0 6 do_348(xm)
    ld  (idx348),BC     ; 4:20      0 6 do_348(xm)
do348:                  ;           0 6 do_348(xm)
    push DE             ; 1:11      i_348(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_348(m)
    ld   HL, (idx348)   ; 3:16      i_348(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u>=x3333   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3333" cannot be evaluated
    ld    A, L          ; 1:4       u>=x3333   HL>=x3333 --> HL-x3333>=0 --> false if carry
    sub   low x3333     ; 2:7       u>=x3333   HL>=x3333 --> HL-x3333>=0 --> false if carry
    ld    A, H          ; 1:4       u>=x3333   HL>=x3333 --> HL-x3333>=0 --> false if carry
    sbc   A, high x3333 ; 2:7       u>=x3333   HL>=x3333 --> HL-x3333>=0 --> false if carry
    ex   DE, HL         ; 1:4       u>=x3333
    pop  DE             ; 1:10      u>=x3333
    jp    c, else348    ; 3:10      u>=x3333   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif348       ; 3:10      else
else348:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif348:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_348(xm)   variant -1.A: step -1 and stop 0, run 7x
idx348 EQU $+1          ;           -1 +loop_348(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_348(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_348(xm)
    or    B             ; 1:4       -1 +loop_348(xm)
    dec  BC             ; 1:6       -1 +loop_348(xm)   index--
    jp   nz, do348save  ; 3:10      -1 +loop_348(xm)
leave348:               ;           -1 +loop_348(xm)
exit348:                ;           xloop LOOP_STACK
    ld   BC, string352  ; 3:10      print_i   Address of string352 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3334 = 13108 ------
    ld   BC, 6          ; 3:10      0 6 do_349(xm)
do349save:              ;           0 6 do_349(xm)
    ld  (idx349),BC     ; 4:20      0 6 do_349(xm)
do349:                  ;           0 6 do_349(xm)
    push DE             ; 1:11      i_349(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_349(m)
    ld   HL, (idx349)   ; 3:16      i_349(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:25]     u>=+13108   _TMP_STACK_INFO #variant: hi == lo-1
    ld    A, 0x33       ; 2:7       u>=+13108   HL>=0x3334 --> HL> 0x3333
    cp    L             ; 1:4       u>=+13108   HL> 0x3333 -->  0> 0x33-L --> false if not carry
    sbc   A, H          ; 1:4       u>=+13108   HL> 0x3333 -->  0> 0x33-H --> false if not carry
    jp   nc, else349    ; 3:10      u>=+13108   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif349       ; 3:10      else
else349:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif349:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_349(xm)   variant -1.A: step -1 and stop 0, run 7x
idx349 EQU $+1          ;           -1 +loop_349(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_349(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_349(xm)
    or    B             ; 1:4       -1 +loop_349(xm)
    dec  BC             ; 1:6       -1 +loop_349(xm)   index--
    jp   nz, do349save  ; 3:10      -1 +loop_349(xm)
leave349:               ;           -1 +loop_349(xm)
exit349:                ;           xloop LOOP_STACK
    ld   BC, string353  ; 3:10      print_i   Address of string353 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_350(xm)
do350save:              ;           0 6 do_350(xm)
    ld  (idx350),BC     ; 4:20      0 6 do_350(xm)
do350:                  ;           0 6 do_350(xm)
    push DE             ; 1:11      i_350(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_350(m)
    ld   HL, (idx350)   ; 3:16      i_350(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:39]     u>=+13108   _TMP_STACK_INFO #variant: hi == lo-1
    ld    A, 0x33       ; 2:7       u>=+13108   HL>=0x3334 --> HL> 0x3333
    cp    L             ; 1:4       u>=+13108   HL> 0x3333 -->  0> 0x33-L --> false if not carry
    sbc   A, H          ; 1:4       u>=+13108   HL> 0x3333 -->  0> 0x33-H --> false if not carry
    ex   DE, HL         ; 1:4       u>=+13108
    pop  DE             ; 1:10      u>=+13108
    jp   nc, else350    ; 3:10      u>=+13108   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif350       ; 3:10      else
else350:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif350:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_350(xm)   variant -1.A: step -1 and stop 0, run 7x
idx350 EQU $+1          ;           -1 +loop_350(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_350(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_350(xm)
    or    B             ; 1:4       -1 +loop_350(xm)
    dec  BC             ; 1:6       -1 +loop_350(xm)   index--
    jp   nz, do350save  ; 3:10      -1 +loop_350(xm)
leave350:               ;           -1 +loop_350(xm)
exit350:                ;           xloop LOOP_STACK
    ld   BC, string353  ; 3:10      print_i   Address of string354 ending with inverted most significant bit == string353
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_351(xm)
do351save:              ;           0 6 do_351(xm)
    ld  (idx351),BC     ; 4:20      0 6 do_351(xm)
do351:                  ;           0 6 do_351(xm)
    push DE             ; 1:11      i_351(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_351(m)
    ld   HL, (idx351)   ; 3:16      i_351(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u>=x3334   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3334" cannot be evaluated
    ld    A, L          ; 1:4       u>=x3334   HL>=x3334 --> HL-x3334>=0 --> false if carry
    sub   low x3334     ; 2:7       u>=x3334   HL>=x3334 --> HL-x3334>=0 --> false if carry
    ld    A, H          ; 1:4       u>=x3334   HL>=x3334 --> HL-x3334>=0 --> false if carry
    sbc   A, high x3334 ; 2:7       u>=x3334   HL>=x3334 --> HL-x3334>=0 --> false if carry
    jp    c, else351    ; 3:10      u>=x3334   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif351       ; 3:10      else
else351:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif351:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_351(xm)   variant -1.A: step -1 and stop 0, run 7x
idx351 EQU $+1          ;           -1 +loop_351(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_351(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_351(xm)
    or    B             ; 1:4       -1 +loop_351(xm)
    dec  BC             ; 1:6       -1 +loop_351(xm)   index--
    jp   nz, do351save  ; 3:10      -1 +loop_351(xm)
leave351:               ;           -1 +loop_351(xm)
exit351:                ;           xloop LOOP_STACK
    ld   BC, string355  ; 3:10      print_i   Address of string355 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_352(xm)
do352save:              ;           0 6 do_352(xm)
    ld  (idx352),BC     ; 4:20      0 6 do_352(xm)
do352:                  ;           0 6 do_352(xm)
    push DE             ; 1:11      i_352(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_352(m)
    ld   HL, (idx352)   ; 3:16      i_352(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u>=x3334   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3334" cannot be evaluated
    ld    A, L          ; 1:4       u>=x3334   HL>=x3334 --> HL-x3334>=0 --> false if carry
    sub   low x3334     ; 2:7       u>=x3334   HL>=x3334 --> HL-x3334>=0 --> false if carry
    ld    A, H          ; 1:4       u>=x3334   HL>=x3334 --> HL-x3334>=0 --> false if carry
    sbc   A, high x3334 ; 2:7       u>=x3334   HL>=x3334 --> HL-x3334>=0 --> false if carry
    ex   DE, HL         ; 1:4       u>=x3334
    pop  DE             ; 1:10      u>=x3334
    jp    c, else352    ; 3:10      u>=x3334   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif352       ; 3:10      else
else352:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif352:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_352(xm)   variant -1.A: step -1 and stop 0, run 7x
idx352 EQU $+1          ;           -1 +loop_352(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_352(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_352(xm)
    or    B             ; 1:4       -1 +loop_352(xm)
    dec  BC             ; 1:6       -1 +loop_352(xm)   index--
    jp   nz, do352save  ; 3:10      -1 +loop_352(xm)
leave352:               ;           -1 +loop_352(xm)
exit352:                ;           xloop LOOP_STACK
    ld   BC, string356  ; 3:10      print_i   Address of string356 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- -2 ------
    ld   BC, 6          ; 3:10      0 6 do_353(xm)
do353save:              ;           0 6 do_353(xm)
    ld  (idx353),BC     ; 4:20      0 6 do_353(xm)
do353:                  ;           0 6 do_353(xm)
    push DE             ; 1:11      i_353(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_353(m)
    ld   HL, (idx353)   ; 3:16      i_353(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u>=-2   _TMP_STACK_INFO #variant: default
    ld    A, L          ; 1:4       u>=-2   HL>=-2 --> L-0xFE>=0 --> false if carry
    sub  0xFE           ; 2:7       u>=-2   HL>=-2 --> L-0xFE>=0 --> false if carry
    ld    A, H          ; 1:4       u>=-2   HL>=-2 --> H-0xFF>=0 --> false if carry
    sbc   A, 0xFF       ; 2:7       u>=-2   HL>=-2 --> H-0xFF>=0 --> false if carry
    jp    c, else353    ; 3:10      u>=-2   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif353       ; 3:10      else
else353:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif353:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_353(xm)   variant -1.A: step -1 and stop 0, run 7x
idx353 EQU $+1          ;           -1 +loop_353(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_353(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_353(xm)
    or    B             ; 1:4       -1 +loop_353(xm)
    dec  BC             ; 1:6       -1 +loop_353(xm)   index--
    jp   nz, do353save  ; 3:10      -1 +loop_353(xm)
leave353:               ;           -1 +loop_353(xm)
exit353:                ;           xloop LOOP_STACK
    ld   BC, string357  ; 3:10      print_i   Address of string357 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_354(xm)
do354save:              ;           0 6 do_354(xm)
    ld  (idx354),BC     ; 4:20      0 6 do_354(xm)
do354:                  ;           0 6 do_354(xm)
    push DE             ; 1:11      i_354(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_354(m)
    ld   HL, (idx354)   ; 3:16      i_354(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u>=-2   _TMP_STACK_INFO #variant: default
    ld    A, L          ; 1:4       u>=-2   HL>=-2 --> L-0xFE>=0 --> false if carry
    sub  0xFE           ; 2:7       u>=-2   HL>=-2 --> L-0xFE>=0 --> false if carry
    ld    A, H          ; 1:4       u>=-2   HL>=-2 --> H-0xFF>=0 --> false if carry
    sbc   A, 0xFF       ; 2:7       u>=-2   HL>=-2 --> H-0xFF>=0 --> false if carry
    ex   DE, HL         ; 1:4       u>=-2
    pop  DE             ; 1:10      u>=-2
    jp    c, else354    ; 3:10      u>=-2   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif354       ; 3:10      else
else354:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif354:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_354(xm)   variant -1.A: step -1 and stop 0, run 7x
idx354 EQU $+1          ;           -1 +loop_354(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_354(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_354(xm)
    or    B             ; 1:4       -1 +loop_354(xm)
    dec  BC             ; 1:6       -1 +loop_354(xm)   index--
    jp   nz, do354save  ; 3:10      -1 +loop_354(xm)
leave354:               ;           -1 +loop_354(xm)
exit354:                ;           xloop LOOP_STACK
    ld   BC, string357  ; 3:10      print_i   Address of string358 ending with inverted most significant bit == string357
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_355(xm)
do355save:              ;           0 6 do_355(xm)
    ld  (idx355),BC     ; 4:20      0 6 do_355(xm)
do355:                  ;           0 6 do_355(xm)
    push DE             ; 1:11      i_355(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_355(m)
    ld   HL, (idx355)   ; 3:16      i_355(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u>=m2   _TMP_STACK_INFO #variant: variable
  .warning The condition "m2" cannot be evaluated
    ld    A, L          ; 1:4       u>=m2   HL>=m2 --> HL-m2>=0 --> false if carry
    sub   low m2        ; 2:7       u>=m2   HL>=m2 --> HL-m2>=0 --> false if carry
    ld    A, H          ; 1:4       u>=m2   HL>=m2 --> HL-m2>=0 --> false if carry
    sbc   A, high m2    ; 2:7       u>=m2   HL>=m2 --> HL-m2>=0 --> false if carry
    jp    c, else355    ; 3:10      u>=m2   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif355       ; 3:10      else
else355:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif355:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_355(xm)   variant -1.A: step -1 and stop 0, run 7x
idx355 EQU $+1          ;           -1 +loop_355(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_355(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_355(xm)
    or    B             ; 1:4       -1 +loop_355(xm)
    dec  BC             ; 1:6       -1 +loop_355(xm)   index--
    jp   nz, do355save  ; 3:10      -1 +loop_355(xm)
leave355:               ;           -1 +loop_355(xm)
exit355:                ;           xloop LOOP_STACK
    ld   BC, string359  ; 3:10      print_i   Address of string359 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_356(xm)
do356save:              ;           0 6 do_356(xm)
    ld  (idx356),BC     ; 4:20      0 6 do_356(xm)
do356:                  ;           0 6 do_356(xm)
    push DE             ; 1:11      i_356(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_356(m)
    ld   HL, (idx356)   ; 3:16      i_356(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u>=m2   _TMP_STACK_INFO #variant: variable
  .warning The condition "m2" cannot be evaluated
    ld    A, L          ; 1:4       u>=m2   HL>=m2 --> HL-m2>=0 --> false if carry
    sub   low m2        ; 2:7       u>=m2   HL>=m2 --> HL-m2>=0 --> false if carry
    ld    A, H          ; 1:4       u>=m2   HL>=m2 --> HL-m2>=0 --> false if carry
    sbc   A, high m2    ; 2:7       u>=m2   HL>=m2 --> HL-m2>=0 --> false if carry
    ex   DE, HL         ; 1:4       u>=m2
    pop  DE             ; 1:10      u>=m2
    jp    c, else356    ; 3:10      u>=m2   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif356       ; 3:10      else
else356:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif356:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_356(xm)   variant -1.A: step -1 and stop 0, run 7x
idx356 EQU $+1          ;           -1 +loop_356(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_356(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_356(xm)
    or    B             ; 1:4       -1 +loop_356(xm)
    dec  BC             ; 1:6       -1 +loop_356(xm)   index--
    jp   nz, do356save  ; 3:10      -1 +loop_356(xm)
leave356:               ;           -1 +loop_356(xm)
exit356:                ;           xloop LOOP_STACK
    ld   BC, string360  ; 3:10      print_i   Address of string360 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- -1 ------
    ld   BC, 6          ; 3:10      0 6 do_357(xm)
do357save:              ;           0 6 do_357(xm)
    ld  (idx357),BC     ; 4:20      0 6 do_357(xm)
do357:                  ;           0 6 do_357(xm)
    push DE             ; 1:11      i_357(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_357(m)
    ld   HL, (idx357)   ; 3:16      i_357(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[6:22]     u>=-1   _TMP_STACK_INFO variant: u>=max
    ld    A, H          ; 1:4       u>=-1
    and   L             ; 1:4       u>=-1
    inc   A             ; 1:4       u>=-1
    jp   nz, else357    ; 3:10      u>=-1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif357       ; 3:10      else
else357:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif357:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_357(xm)   variant -1.A: step -1 and stop 0, run 7x
idx357 EQU $+1          ;           -1 +loop_357(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_357(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_357(xm)
    or    B             ; 1:4       -1 +loop_357(xm)
    dec  BC             ; 1:6       -1 +loop_357(xm)   index--
    jp   nz, do357save  ; 3:10      -1 +loop_357(xm)
leave357:               ;           -1 +loop_357(xm)
exit357:                ;           xloop LOOP_STACK
    ld   BC, string361  ; 3:10      print_i   Address of string361 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_358(xm)
do358save:              ;           0 6 do_358(xm)
    ld  (idx358),BC     ; 4:20      0 6 do_358(xm)
do358:                  ;           0 6 do_358(xm)
    push DE             ; 1:11      i_358(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_358(m)
    ld   HL, (idx358)   ; 3:16      i_358(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[8:36]     u>=-1   _TMP_STACK_INFO variant: u>=max
    ld    A, H          ; 1:4       u>=-1
    and   L             ; 1:4       u>=-1
    inc   A             ; 1:4       u>=-1
    ex   DE, HL         ; 1:4       u>=-1
    pop  DE             ; 1:10      u>=-1
    jp   nz, else358    ; 3:10      u>=-1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif358       ; 3:10      else
else358:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif358:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_358(xm)   variant -1.A: step -1 and stop 0, run 7x
idx358 EQU $+1          ;           -1 +loop_358(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_358(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_358(xm)
    or    B             ; 1:4       -1 +loop_358(xm)
    dec  BC             ; 1:6       -1 +loop_358(xm)   index--
    jp   nz, do358save  ; 3:10      -1 +loop_358(xm)
leave358:               ;           -1 +loop_358(xm)
exit358:                ;           xloop LOOP_STACK
    ld   BC, string361  ; 3:10      print_i   Address of string362 ending with inverted most significant bit == string361
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_359(xm)
do359save:              ;           0 6 do_359(xm)
    ld  (idx359),BC     ; 4:20      0 6 do_359(xm)
do359:                  ;           0 6 do_359(xm)
    push DE             ; 1:11      i_359(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_359(m)
    ld   HL, (idx359)   ; 3:16      i_359(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u>=m1   _TMP_STACK_INFO #variant: variable
  .warning The condition "m1" cannot be evaluated
    ld    A, L          ; 1:4       u>=m1   HL>=m1 --> HL-m1>=0 --> false if carry
    sub   low m1        ; 2:7       u>=m1   HL>=m1 --> HL-m1>=0 --> false if carry
    ld    A, H          ; 1:4       u>=m1   HL>=m1 --> HL-m1>=0 --> false if carry
    sbc   A, high m1    ; 2:7       u>=m1   HL>=m1 --> HL-m1>=0 --> false if carry
    jp    c, else359    ; 3:10      u>=m1   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif359       ; 3:10      else
else359:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif359:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_359(xm)   variant -1.A: step -1 and stop 0, run 7x
idx359 EQU $+1          ;           -1 +loop_359(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_359(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_359(xm)
    or    B             ; 1:4       -1 +loop_359(xm)
    dec  BC             ; 1:6       -1 +loop_359(xm)   index--
    jp   nz, do359save  ; 3:10      -1 +loop_359(xm)
leave359:               ;           -1 +loop_359(xm)
exit359:                ;           xloop LOOP_STACK
    ld   BC, string363  ; 3:10      print_i   Address of string363 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_360(xm)
do360save:              ;           0 6 do_360(xm)
    ld  (idx360),BC     ; 4:20      0 6 do_360(xm)
do360:                  ;           0 6 do_360(xm)
    push DE             ; 1:11      i_360(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_360(m)
    ld   HL, (idx360)   ; 3:16      i_360(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u>=m1   _TMP_STACK_INFO #variant: variable
  .warning The condition "m1" cannot be evaluated
    ld    A, L          ; 1:4       u>=m1   HL>=m1 --> HL-m1>=0 --> false if carry
    sub   low m1        ; 2:7       u>=m1   HL>=m1 --> HL-m1>=0 --> false if carry
    ld    A, H          ; 1:4       u>=m1   HL>=m1 --> HL-m1>=0 --> false if carry
    sbc   A, high m1    ; 2:7       u>=m1   HL>=m1 --> HL-m1>=0 --> false if carry
    ex   DE, HL         ; 1:4       u>=m1
    pop  DE             ; 1:10      u>=m1
    jp    c, else360    ; 3:10      u>=m1   false if carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif360       ; 3:10      else
else360:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif360:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_360(xm)   variant -1.A: step -1 and stop 0, run 7x
idx360 EQU $+1          ;           -1 +loop_360(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_360(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_360(xm)
    or    B             ; 1:4       -1 +loop_360(xm)
    dec  BC             ; 1:6       -1 +loop_360(xm)   index--
    jp   nz, do360save  ; 3:10      -1 +loop_360(xm)
leave360:               ;           -1 +loop_360(xm)
exit360:                ;           xloop LOOP_STACK
    ld   BC, string364  ; 3:10      print_i   Address of string364 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0 ------
    ld   BC, 6          ; 3:10      0 6 do_361(xm)
do361save:              ;           0 6 do_361(xm)
    ld  (idx361),BC     ; 4:20      0 6 do_361(xm)
do361:                  ;           0 6 do_361(xm)
    push DE             ; 1:11      i_361(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_361(m)
    ld   HL, (idx361)   ; 3:16      i_361(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[5:18]     u> 0   _TMP_STACK_INFO variant: u>min
    ld    A, H          ; 1:4       u> 0
    or    L             ; 1:4       u> 0
    jp    z, else361    ; 3:10      u> 0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif361       ; 3:10      else
else361:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif361:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_361(xm)   variant -1.A: step -1 and stop 0, run 7x
idx361 EQU $+1          ;           -1 +loop_361(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_361(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_361(xm)
    or    B             ; 1:4       -1 +loop_361(xm)
    dec  BC             ; 1:6       -1 +loop_361(xm)   index--
    jp   nz, do361save  ; 3:10      -1 +loop_361(xm)
leave361:               ;           -1 +loop_361(xm)
exit361:                ;           xloop LOOP_STACK
    ld   BC, string365  ; 3:10      print_i   Address of string365 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_362(xm)
do362save:              ;           0 6 do_362(xm)
    ld  (idx362),BC     ; 4:20      0 6 do_362(xm)
do362:                  ;           0 6 do_362(xm)
    push DE             ; 1:11      i_362(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_362(m)
    ld   HL, (idx362)   ; 3:16      i_362(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:32]     u> 0   _TMP_STACK_INFO variant: u>min
    ld    A, H          ; 1:4       u> 0
    or    L             ; 1:4       u> 0
    ex   DE, HL         ; 1:4       u> 0
    pop  DE             ; 1:10      u> 0
    jp    z, else362    ; 3:10      u> 0
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif362       ; 3:10      else
else362:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif362:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_362(xm)   variant -1.A: step -1 and stop 0, run 7x
idx362 EQU $+1          ;           -1 +loop_362(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_362(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_362(xm)
    or    B             ; 1:4       -1 +loop_362(xm)
    dec  BC             ; 1:6       -1 +loop_362(xm)   index--
    jp   nz, do362save  ; 3:10      -1 +loop_362(xm)
leave362:               ;           -1 +loop_362(xm)
exit362:                ;           xloop LOOP_STACK
    ld   BC, string365  ; 3:10      print_i   Address of string366 ending with inverted most significant bit == string365
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_363(xm)
do363save:              ;           0 6 do_363(xm)
    ld  (idx363),BC     ; 4:20      0 6 do_363(xm)
do363:                  ;           0 6 do_363(xm)
    push DE             ; 1:11      i_363(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_363(m)
    ld   HL, (idx363)   ; 3:16      i_363(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u> zero   _TMP_STACK_INFO #variant: variable
  .warning The condition "zero" cannot be evaluated
    ld    A, low zero   ; 2:7       u> zero   HL>zero --> 0>zero-HL --> false if not carry
    sub   L             ; 1:4       u> zero   HL>zero --> 0>zero-HL --> false if not carry
    ld    A, high zero  ; 2:7       u> zero   HL>zero --> 0>zero-HL --> false if not carry
    sbc   A, H          ; 1:4       u> zero   HL>zero --> 0>zero-HL --> false if not carry
    jp   nc, else363    ; 3:10      u> zero   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif363       ; 3:10      else
else363:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif363:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_363(xm)   variant -1.A: step -1 and stop 0, run 7x
idx363 EQU $+1          ;           -1 +loop_363(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_363(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_363(xm)
    or    B             ; 1:4       -1 +loop_363(xm)
    dec  BC             ; 1:6       -1 +loop_363(xm)   index--
    jp   nz, do363save  ; 3:10      -1 +loop_363(xm)
leave363:               ;           -1 +loop_363(xm)
exit363:                ;           xloop LOOP_STACK
    ld   BC, string367  ; 3:10      print_i   Address of string367 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_364(xm)
do364save:              ;           0 6 do_364(xm)
    ld  (idx364),BC     ; 4:20      0 6 do_364(xm)
do364:                  ;           0 6 do_364(xm)
    push DE             ; 1:11      i_364(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_364(m)
    ld   HL, (idx364)   ; 3:16      i_364(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u> zero   _TMP_STACK_INFO #variant: variable
  .warning The condition "zero" cannot be evaluated
    ld    A, low zero   ; 2:7       u> zero   HL>zero --> 0>zero-HL --> false if not carry
    sub   L             ; 1:4       u> zero   HL>zero --> 0>zero-HL --> false if not carry
    ld    A, high zero  ; 2:7       u> zero   HL>zero --> 0>zero-HL --> false if not carry
    sbc   A, H          ; 1:4       u> zero   HL>zero --> 0>zero-HL --> false if not carry
    ex   DE, HL         ; 1:4       u> zero
    pop  DE             ; 1:10      u> zero
    jp   nc, else364    ; 3:10      u> zero   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif364       ; 3:10      else
else364:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif364:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_364(xm)   variant -1.A: step -1 and stop 0, run 7x
idx364 EQU $+1          ;           -1 +loop_364(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_364(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_364(xm)
    or    B             ; 1:4       -1 +loop_364(xm)
    dec  BC             ; 1:6       -1 +loop_364(xm)   index--
    jp   nz, do364save  ; 3:10      -1 +loop_364(xm)
leave364:               ;           -1 +loop_364(xm)
exit364:                ;           xloop LOOP_STACK
    ld   BC, string368  ; 3:10      print_i   Address of string368 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 1 ------
    ld   BC, 6          ; 3:10      0 6 do_365(xm)
do365save:              ;           0 6 do_365(xm)
    ld  (idx365),BC     ; 4:20      0 6 do_365(xm)
do365:                  ;           0 6 do_365(xm)
    push DE             ; 1:11      i_365(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_365(m)
    ld   HL, (idx365)   ; 3:16      i_365(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u> +1   _TMP_STACK_INFO #variant: default
    ld    A, 0x01       ; 2:7       u> +1   HL>1 --> 0>0x01-L --> false if not carry
    sub   L             ; 1:4       u> +1   HL>1 --> 0>0x01-L --> false if not carry
    ld    A, 0x00       ; 2:7       u> +1   HL>1 --> 0>0x00-H --> false if not carry
    sbc   A, H          ; 1:4       u> +1   HL>1 --> 0>0x00-H --> false if not carry
    jp   nc, else365    ; 3:10      u> +1   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif365       ; 3:10      else
else365:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif365:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_365(xm)   variant -1.A: step -1 and stop 0, run 7x
idx365 EQU $+1          ;           -1 +loop_365(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_365(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_365(xm)
    or    B             ; 1:4       -1 +loop_365(xm)
    dec  BC             ; 1:6       -1 +loop_365(xm)   index--
    jp   nz, do365save  ; 3:10      -1 +loop_365(xm)
leave365:               ;           -1 +loop_365(xm)
exit365:                ;           xloop LOOP_STACK
    ld   BC, string369  ; 3:10      print_i   Address of string369 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_366(xm)
do366save:              ;           0 6 do_366(xm)
    ld  (idx366),BC     ; 4:20      0 6 do_366(xm)
do366:                  ;           0 6 do_366(xm)
    push DE             ; 1:11      i_366(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_366(m)
    ld   HL, (idx366)   ; 3:16      i_366(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u> +1   _TMP_STACK_INFO #variant: default
    ld    A, 0x01       ; 2:7       u> +1   HL>1 --> 0>0x01-L --> false if not carry
    sub   L             ; 1:4       u> +1   HL>1 --> 0>0x01-L --> false if not carry
    ld    A, 0x00       ; 2:7       u> +1   HL>1 --> 0>0x00-H --> false if not carry
    sbc   A, H          ; 1:4       u> +1   HL>1 --> 0>0x00-H --> false if not carry
    ex   DE, HL         ; 1:4       u> +1
    pop  DE             ; 1:10      u> +1
    jp   nc, else366    ; 3:10      u> +1   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif366       ; 3:10      else
else366:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif366:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_366(xm)   variant -1.A: step -1 and stop 0, run 7x
idx366 EQU $+1          ;           -1 +loop_366(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_366(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_366(xm)
    or    B             ; 1:4       -1 +loop_366(xm)
    dec  BC             ; 1:6       -1 +loop_366(xm)   index--
    jp   nz, do366save  ; 3:10      -1 +loop_366(xm)
leave366:               ;           -1 +loop_366(xm)
exit366:                ;           xloop LOOP_STACK
    ld   BC, string369  ; 3:10      print_i   Address of string370 ending with inverted most significant bit == string369
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_367(xm)
do367save:              ;           0 6 do_367(xm)
    ld  (idx367),BC     ; 4:20      0 6 do_367(xm)
do367:                  ;           0 6 do_367(xm)
    push DE             ; 1:11      i_367(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_367(m)
    ld   HL, (idx367)   ; 3:16      i_367(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u> p1   _TMP_STACK_INFO #variant: variable
  .warning The condition "p1" cannot be evaluated
    ld    A, low p1     ; 2:7       u> p1   HL>p1 --> 0>p1-HL --> false if not carry
    sub   L             ; 1:4       u> p1   HL>p1 --> 0>p1-HL --> false if not carry
    ld    A, high p1    ; 2:7       u> p1   HL>p1 --> 0>p1-HL --> false if not carry
    sbc   A, H          ; 1:4       u> p1   HL>p1 --> 0>p1-HL --> false if not carry
    jp   nc, else367    ; 3:10      u> p1   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif367       ; 3:10      else
else367:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif367:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_367(xm)   variant -1.A: step -1 and stop 0, run 7x
idx367 EQU $+1          ;           -1 +loop_367(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_367(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_367(xm)
    or    B             ; 1:4       -1 +loop_367(xm)
    dec  BC             ; 1:6       -1 +loop_367(xm)   index--
    jp   nz, do367save  ; 3:10      -1 +loop_367(xm)
leave367:               ;           -1 +loop_367(xm)
exit367:                ;           xloop LOOP_STACK
    ld   BC, string371  ; 3:10      print_i   Address of string371 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_368(xm)
do368save:              ;           0 6 do_368(xm)
    ld  (idx368),BC     ; 4:20      0 6 do_368(xm)
do368:                  ;           0 6 do_368(xm)
    push DE             ; 1:11      i_368(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_368(m)
    ld   HL, (idx368)   ; 3:16      i_368(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u> p1   _TMP_STACK_INFO #variant: variable
  .warning The condition "p1" cannot be evaluated
    ld    A, low p1     ; 2:7       u> p1   HL>p1 --> 0>p1-HL --> false if not carry
    sub   L             ; 1:4       u> p1   HL>p1 --> 0>p1-HL --> false if not carry
    ld    A, high p1    ; 2:7       u> p1   HL>p1 --> 0>p1-HL --> false if not carry
    sbc   A, H          ; 1:4       u> p1   HL>p1 --> 0>p1-HL --> false if not carry
    ex   DE, HL         ; 1:4       u> p1
    pop  DE             ; 1:10      u> p1
    jp   nc, else368    ; 3:10      u> p1   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif368       ; 3:10      else
else368:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif368:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_368(xm)   variant -1.A: step -1 and stop 0, run 7x
idx368 EQU $+1          ;           -1 +loop_368(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_368(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_368(xm)
    or    B             ; 1:4       -1 +loop_368(xm)
    dec  BC             ; 1:6       -1 +loop_368(xm)   index--
    jp   nz, do368save  ; 3:10      -1 +loop_368(xm)
leave368:               ;           -1 +loop_368(xm)
exit368:                ;           xloop LOOP_STACK
    ld   BC, string372  ; 3:10      print_i   Address of string372 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3332 = 13106 ------
    ld   BC, 6          ; 3:10      0 6 do_369(xm)
do369save:              ;           0 6 do_369(xm)
    ld  (idx369),BC     ; 4:20      0 6 do_369(xm)
do369:                  ;           0 6 do_369(xm)
    push DE             ; 1:11      i_369(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_369(m)
    ld   HL, (idx369)   ; 3:16      i_369(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u> +13106   _TMP_STACK_INFO #variant: default
    ld    A, 0x32       ; 2:7       u> +13106   HL>13106 --> 0>0x32-L --> false if not carry
    sub   L             ; 1:4       u> +13106   HL>13106 --> 0>0x32-L --> false if not carry
    ld    A, 0x33       ; 2:7       u> +13106   HL>13106 --> 0>0x33-H --> false if not carry
    sbc   A, H          ; 1:4       u> +13106   HL>13106 --> 0>0x33-H --> false if not carry
    jp   nc, else369    ; 3:10      u> +13106   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif369       ; 3:10      else
else369:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif369:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_369(xm)   variant -1.A: step -1 and stop 0, run 7x
idx369 EQU $+1          ;           -1 +loop_369(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_369(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_369(xm)
    or    B             ; 1:4       -1 +loop_369(xm)
    dec  BC             ; 1:6       -1 +loop_369(xm)   index--
    jp   nz, do369save  ; 3:10      -1 +loop_369(xm)
leave369:               ;           -1 +loop_369(xm)
exit369:                ;           xloop LOOP_STACK
    ld   BC, string373  ; 3:10      print_i   Address of string373 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_370(xm)
do370save:              ;           0 6 do_370(xm)
    ld  (idx370),BC     ; 4:20      0 6 do_370(xm)
do370:                  ;           0 6 do_370(xm)
    push DE             ; 1:11      i_370(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_370(m)
    ld   HL, (idx370)   ; 3:16      i_370(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u> +13106   _TMP_STACK_INFO #variant: default
    ld    A, 0x32       ; 2:7       u> +13106   HL>13106 --> 0>0x32-L --> false if not carry
    sub   L             ; 1:4       u> +13106   HL>13106 --> 0>0x32-L --> false if not carry
    ld    A, 0x33       ; 2:7       u> +13106   HL>13106 --> 0>0x33-H --> false if not carry
    sbc   A, H          ; 1:4       u> +13106   HL>13106 --> 0>0x33-H --> false if not carry
    ex   DE, HL         ; 1:4       u> +13106
    pop  DE             ; 1:10      u> +13106
    jp   nc, else370    ; 3:10      u> +13106   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif370       ; 3:10      else
else370:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif370:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_370(xm)   variant -1.A: step -1 and stop 0, run 7x
idx370 EQU $+1          ;           -1 +loop_370(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_370(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_370(xm)
    or    B             ; 1:4       -1 +loop_370(xm)
    dec  BC             ; 1:6       -1 +loop_370(xm)   index--
    jp   nz, do370save  ; 3:10      -1 +loop_370(xm)
leave370:               ;           -1 +loop_370(xm)
exit370:                ;           xloop LOOP_STACK
    ld   BC, string373  ; 3:10      print_i   Address of string374 ending with inverted most significant bit == string373
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_371(xm)
do371save:              ;           0 6 do_371(xm)
    ld  (idx371),BC     ; 4:20      0 6 do_371(xm)
do371:                  ;           0 6 do_371(xm)
    push DE             ; 1:11      i_371(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_371(m)
    ld   HL, (idx371)   ; 3:16      i_371(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u> x3332   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3332" cannot be evaluated
    ld    A, low x3332  ; 2:7       u> x3332   HL>x3332 --> 0>x3332-HL --> false if not carry
    sub   L             ; 1:4       u> x3332   HL>x3332 --> 0>x3332-HL --> false if not carry
    ld    A, high x3332 ; 2:7       u> x3332   HL>x3332 --> 0>x3332-HL --> false if not carry
    sbc   A, H          ; 1:4       u> x3332   HL>x3332 --> 0>x3332-HL --> false if not carry
    jp   nc, else371    ; 3:10      u> x3332   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif371       ; 3:10      else
else371:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif371:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_371(xm)   variant -1.A: step -1 and stop 0, run 7x
idx371 EQU $+1          ;           -1 +loop_371(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_371(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_371(xm)
    or    B             ; 1:4       -1 +loop_371(xm)
    dec  BC             ; 1:6       -1 +loop_371(xm)   index--
    jp   nz, do371save  ; 3:10      -1 +loop_371(xm)
leave371:               ;           -1 +loop_371(xm)
exit371:                ;           xloop LOOP_STACK
    ld   BC, string375  ; 3:10      print_i   Address of string375 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_372(xm)
do372save:              ;           0 6 do_372(xm)
    ld  (idx372),BC     ; 4:20      0 6 do_372(xm)
do372:                  ;           0 6 do_372(xm)
    push DE             ; 1:11      i_372(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_372(m)
    ld   HL, (idx372)   ; 3:16      i_372(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u> x3332   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3332" cannot be evaluated
    ld    A, low x3332  ; 2:7       u> x3332   HL>x3332 --> 0>x3332-HL --> false if not carry
    sub   L             ; 1:4       u> x3332   HL>x3332 --> 0>x3332-HL --> false if not carry
    ld    A, high x3332 ; 2:7       u> x3332   HL>x3332 --> 0>x3332-HL --> false if not carry
    sbc   A, H          ; 1:4       u> x3332   HL>x3332 --> 0>x3332-HL --> false if not carry
    ex   DE, HL         ; 1:4       u> x3332
    pop  DE             ; 1:10      u> x3332
    jp   nc, else372    ; 3:10      u> x3332   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif372       ; 3:10      else
else372:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif372:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_372(xm)   variant -1.A: step -1 and stop 0, run 7x
idx372 EQU $+1          ;           -1 +loop_372(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_372(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_372(xm)
    or    B             ; 1:4       -1 +loop_372(xm)
    dec  BC             ; 1:6       -1 +loop_372(xm)   index--
    jp   nz, do372save  ; 3:10      -1 +loop_372(xm)
leave372:               ;           -1 +loop_372(xm)
exit372:                ;           xloop LOOP_STACK
    ld   BC, string376  ; 3:10      print_i   Address of string376 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3333 = 13107 ------
    ld   BC, 6          ; 3:10      0 6 do_373(xm)
do373save:              ;           0 6 do_373(xm)
    ld  (idx373),BC     ; 4:20      0 6 do_373(xm)
do373:                  ;           0 6 do_373(xm)
    push DE             ; 1:11      i_373(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_373(m)
    ld   HL, (idx373)   ; 3:16      i_373(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[7:25]     u> +13107   _TMP_STACK_INFO #variant: hi == lo
    ld    A, 0x33       ; 2:7       u> +13107   HL>0x3333 --> 0>0x3333-HL
    cp    L             ; 1:4       u> +13107   HL>0x3333 --> 0>0x33-L --> false if not carry
    sbc   A, H          ; 1:4       u> +13107   HL>0x3333 --> 0>0x33-H --> false if not carry
    jp   nc, else373    ; 3:10      u> +13107   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif373       ; 3:10      else
else373:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif373:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_373(xm)   variant -1.A: step -1 and stop 0, run 7x
idx373 EQU $+1          ;           -1 +loop_373(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_373(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_373(xm)
    or    B             ; 1:4       -1 +loop_373(xm)
    dec  BC             ; 1:6       -1 +loop_373(xm)   index--
    jp   nz, do373save  ; 3:10      -1 +loop_373(xm)
leave373:               ;           -1 +loop_373(xm)
exit373:                ;           xloop LOOP_STACK
    ld   BC, string377  ; 3:10      print_i   Address of string377 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_374(xm)
do374save:              ;           0 6 do_374(xm)
    ld  (idx374),BC     ; 4:20      0 6 do_374(xm)
do374:                  ;           0 6 do_374(xm)
    push DE             ; 1:11      i_374(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_374(m)
    ld   HL, (idx374)   ; 3:16      i_374(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:39]     u> +13107   _TMP_STACK_INFO #variant: hi == lo
    ld    A, 0x33       ; 2:7       u> +13107   HL>0x3333 --> 0>0x3333-HL
    cp    L             ; 1:4       u> +13107   HL>0x3333 --> 0>0x33-L --> false if not carry
    sbc   A, H          ; 1:4       u> +13107   HL>0x3333 --> 0>0x33-H --> false if not carry
    ex   DE, HL         ; 1:4       u> +13107
    pop  DE             ; 1:10      u> +13107
    jp   nc, else374    ; 3:10      u> +13107   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif374       ; 3:10      else
else374:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif374:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_374(xm)   variant -1.A: step -1 and stop 0, run 7x
idx374 EQU $+1          ;           -1 +loop_374(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_374(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_374(xm)
    or    B             ; 1:4       -1 +loop_374(xm)
    dec  BC             ; 1:6       -1 +loop_374(xm)   index--
    jp   nz, do374save  ; 3:10      -1 +loop_374(xm)
leave374:               ;           -1 +loop_374(xm)
exit374:                ;           xloop LOOP_STACK
    ld   BC, string377  ; 3:10      print_i   Address of string378 ending with inverted most significant bit == string377
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_375(xm)
do375save:              ;           0 6 do_375(xm)
    ld  (idx375),BC     ; 4:20      0 6 do_375(xm)
do375:                  ;           0 6 do_375(xm)
    push DE             ; 1:11      i_375(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_375(m)
    ld   HL, (idx375)   ; 3:16      i_375(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u> x3333   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3333" cannot be evaluated
    ld    A, low x3333  ; 2:7       u> x3333   HL>x3333 --> 0>x3333-HL --> false if not carry
    sub   L             ; 1:4       u> x3333   HL>x3333 --> 0>x3333-HL --> false if not carry
    ld    A, high x3333 ; 2:7       u> x3333   HL>x3333 --> 0>x3333-HL --> false if not carry
    sbc   A, H          ; 1:4       u> x3333   HL>x3333 --> 0>x3333-HL --> false if not carry
    jp   nc, else375    ; 3:10      u> x3333   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif375       ; 3:10      else
else375:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif375:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_375(xm)   variant -1.A: step -1 and stop 0, run 7x
idx375 EQU $+1          ;           -1 +loop_375(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_375(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_375(xm)
    or    B             ; 1:4       -1 +loop_375(xm)
    dec  BC             ; 1:6       -1 +loop_375(xm)   index--
    jp   nz, do375save  ; 3:10      -1 +loop_375(xm)
leave375:               ;           -1 +loop_375(xm)
exit375:                ;           xloop LOOP_STACK
    ld   BC, string379  ; 3:10      print_i   Address of string379 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_376(xm)
do376save:              ;           0 6 do_376(xm)
    ld  (idx376),BC     ; 4:20      0 6 do_376(xm)
do376:                  ;           0 6 do_376(xm)
    push DE             ; 1:11      i_376(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_376(m)
    ld   HL, (idx376)   ; 3:16      i_376(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u> x3333   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3333" cannot be evaluated
    ld    A, low x3333  ; 2:7       u> x3333   HL>x3333 --> 0>x3333-HL --> false if not carry
    sub   L             ; 1:4       u> x3333   HL>x3333 --> 0>x3333-HL --> false if not carry
    ld    A, high x3333 ; 2:7       u> x3333   HL>x3333 --> 0>x3333-HL --> false if not carry
    sbc   A, H          ; 1:4       u> x3333   HL>x3333 --> 0>x3333-HL --> false if not carry
    ex   DE, HL         ; 1:4       u> x3333
    pop  DE             ; 1:10      u> x3333
    jp   nc, else376    ; 3:10      u> x3333   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif376       ; 3:10      else
else376:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif376:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_376(xm)   variant -1.A: step -1 and stop 0, run 7x
idx376 EQU $+1          ;           -1 +loop_376(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_376(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_376(xm)
    or    B             ; 1:4       -1 +loop_376(xm)
    dec  BC             ; 1:6       -1 +loop_376(xm)   index--
    jp   nz, do376save  ; 3:10      -1 +loop_376(xm)
leave376:               ;           -1 +loop_376(xm)
exit376:                ;           xloop LOOP_STACK
    ld   BC, string380  ; 3:10      print_i   Address of string380 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- 0x3334 = 13108 ------
    ld   BC, 6          ; 3:10      0 6 do_377(xm)
do377save:              ;           0 6 do_377(xm)
    ld  (idx377),BC     ; 4:20      0 6 do_377(xm)
do377:                  ;           0 6 do_377(xm)
    push DE             ; 1:11      i_377(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_377(m)
    ld   HL, (idx377)   ; 3:16      i_377(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u> +13108   _TMP_STACK_INFO #variant: default
    ld    A, 0x34       ; 2:7       u> +13108   HL>13108 --> 0>0x34-L --> false if not carry
    sub   L             ; 1:4       u> +13108   HL>13108 --> 0>0x34-L --> false if not carry
    ld    A, 0x33       ; 2:7       u> +13108   HL>13108 --> 0>0x33-H --> false if not carry
    sbc   A, H          ; 1:4       u> +13108   HL>13108 --> 0>0x33-H --> false if not carry
    jp   nc, else377    ; 3:10      u> +13108   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif377       ; 3:10      else
else377:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif377:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_377(xm)   variant -1.A: step -1 and stop 0, run 7x
idx377 EQU $+1          ;           -1 +loop_377(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_377(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_377(xm)
    or    B             ; 1:4       -1 +loop_377(xm)
    dec  BC             ; 1:6       -1 +loop_377(xm)   index--
    jp   nz, do377save  ; 3:10      -1 +loop_377(xm)
leave377:               ;           -1 +loop_377(xm)
exit377:                ;           xloop LOOP_STACK
    ld   BC, string381  ; 3:10      print_i   Address of string381 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_378(xm)
do378save:              ;           0 6 do_378(xm)
    ld  (idx378),BC     ; 4:20      0 6 do_378(xm)
do378:                  ;           0 6 do_378(xm)
    push DE             ; 1:11      i_378(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_378(m)
    ld   HL, (idx378)   ; 3:16      i_378(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u> +13108   _TMP_STACK_INFO #variant: default
    ld    A, 0x34       ; 2:7       u> +13108   HL>13108 --> 0>0x34-L --> false if not carry
    sub   L             ; 1:4       u> +13108   HL>13108 --> 0>0x34-L --> false if not carry
    ld    A, 0x33       ; 2:7       u> +13108   HL>13108 --> 0>0x33-H --> false if not carry
    sbc   A, H          ; 1:4       u> +13108   HL>13108 --> 0>0x33-H --> false if not carry
    ex   DE, HL         ; 1:4       u> +13108
    pop  DE             ; 1:10      u> +13108
    jp   nc, else378    ; 3:10      u> +13108   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif378       ; 3:10      else
else378:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif378:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_378(xm)   variant -1.A: step -1 and stop 0, run 7x
idx378 EQU $+1          ;           -1 +loop_378(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_378(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_378(xm)
    or    B             ; 1:4       -1 +loop_378(xm)
    dec  BC             ; 1:6       -1 +loop_378(xm)   index--
    jp   nz, do378save  ; 3:10      -1 +loop_378(xm)
leave378:               ;           -1 +loop_378(xm)
exit378:                ;           xloop LOOP_STACK
    ld   BC, string381  ; 3:10      print_i   Address of string382 ending with inverted most significant bit == string381
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_379(xm)
do379save:              ;           0 6 do_379(xm)
    ld  (idx379),BC     ; 4:20      0 6 do_379(xm)
do379:                  ;           0 6 do_379(xm)
    push DE             ; 1:11      i_379(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_379(m)
    ld   HL, (idx379)   ; 3:16      i_379(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u> x3334   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3334" cannot be evaluated
    ld    A, low x3334  ; 2:7       u> x3334   HL>x3334 --> 0>x3334-HL --> false if not carry
    sub   L             ; 1:4       u> x3334   HL>x3334 --> 0>x3334-HL --> false if not carry
    ld    A, high x3334 ; 2:7       u> x3334   HL>x3334 --> 0>x3334-HL --> false if not carry
    sbc   A, H          ; 1:4       u> x3334   HL>x3334 --> 0>x3334-HL --> false if not carry
    jp   nc, else379    ; 3:10      u> x3334   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif379       ; 3:10      else
else379:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif379:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_379(xm)   variant -1.A: step -1 and stop 0, run 7x
idx379 EQU $+1          ;           -1 +loop_379(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_379(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_379(xm)
    or    B             ; 1:4       -1 +loop_379(xm)
    dec  BC             ; 1:6       -1 +loop_379(xm)   index--
    jp   nz, do379save  ; 3:10      -1 +loop_379(xm)
leave379:               ;           -1 +loop_379(xm)
exit379:                ;           xloop LOOP_STACK
    ld   BC, string383  ; 3:10      print_i   Address of string383 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_380(xm)
do380save:              ;           0 6 do_380(xm)
    ld  (idx380),BC     ; 4:20      0 6 do_380(xm)
do380:                  ;           0 6 do_380(xm)
    push DE             ; 1:11      i_380(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_380(m)
    ld   HL, (idx380)   ; 3:16      i_380(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u> x3334   _TMP_STACK_INFO #variant: variable
  .warning The condition "x3334" cannot be evaluated
    ld    A, low x3334  ; 2:7       u> x3334   HL>x3334 --> 0>x3334-HL --> false if not carry
    sub   L             ; 1:4       u> x3334   HL>x3334 --> 0>x3334-HL --> false if not carry
    ld    A, high x3334 ; 2:7       u> x3334   HL>x3334 --> 0>x3334-HL --> false if not carry
    sbc   A, H          ; 1:4       u> x3334   HL>x3334 --> 0>x3334-HL --> false if not carry
    ex   DE, HL         ; 1:4       u> x3334
    pop  DE             ; 1:10      u> x3334
    jp   nc, else380    ; 3:10      u> x3334   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif380       ; 3:10      else
else380:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif380:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_380(xm)   variant -1.A: step -1 and stop 0, run 7x
idx380 EQU $+1          ;           -1 +loop_380(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_380(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_380(xm)
    or    B             ; 1:4       -1 +loop_380(xm)
    dec  BC             ; 1:6       -1 +loop_380(xm)   index--
    jp   nz, do380save  ; 3:10      -1 +loop_380(xm)
leave380:               ;           -1 +loop_380(xm)
exit380:                ;           xloop LOOP_STACK
    ld   BC, string384  ; 3:10      print_i   Address of string384 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- -2 ------
    ld   BC, 6          ; 3:10      0 6 do_381(xm)
do381save:              ;           0 6 do_381(xm)
    ld  (idx381),BC     ; 4:20      0 6 do_381(xm)
do381:                  ;           0 6 do_381(xm)
    push DE             ; 1:11      i_381(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_381(m)
    ld   HL, (idx381)   ; 3:16      i_381(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[6:22]     u> -2   _TMP_STACK_INFO variant: u>max-1
    ld    A, H          ; 1:4       u> -2
    and   L             ; 1:4       u> -2
    inc   A             ; 1:4       u> -2
    jp   nz, else381    ; 3:10      u> -2
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif381       ; 3:10      else
else381:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif381:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_381(xm)   variant -1.A: step -1 and stop 0, run 7x
idx381 EQU $+1          ;           -1 +loop_381(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_381(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_381(xm)
    or    B             ; 1:4       -1 +loop_381(xm)
    dec  BC             ; 1:6       -1 +loop_381(xm)   index--
    jp   nz, do381save  ; 3:10      -1 +loop_381(xm)
leave381:               ;           -1 +loop_381(xm)
exit381:                ;           xloop LOOP_STACK
    ld   BC, string385  ; 3:10      print_i   Address of string385 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_382(xm)
do382save:              ;           0 6 do_382(xm)
    ld  (idx382),BC     ; 4:20      0 6 do_382(xm)
do382:                  ;           0 6 do_382(xm)
    push DE             ; 1:11      i_382(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_382(m)
    ld   HL, (idx382)   ; 3:16      i_382(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[8:36]     u> -2   _TMP_STACK_INFO variant: u>max-1
    ld    A, H          ; 1:4       u> -2
    and   L             ; 1:4       u> -2
    inc   A             ; 1:4       u> -2
    ex   DE, HL         ; 1:4       u> -2
    pop  DE             ; 1:10      u> -2
    jp   nz, else382    ; 3:10      u> -2
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif382       ; 3:10      else
else382:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif382:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_382(xm)   variant -1.A: step -1 and stop 0, run 7x
idx382 EQU $+1          ;           -1 +loop_382(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_382(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_382(xm)
    or    B             ; 1:4       -1 +loop_382(xm)
    dec  BC             ; 1:6       -1 +loop_382(xm)   index--
    jp   nz, do382save  ; 3:10      -1 +loop_382(xm)
leave382:               ;           -1 +loop_382(xm)
exit382:                ;           xloop LOOP_STACK
    ld   BC, string385  ; 3:10      print_i   Address of string386 ending with inverted most significant bit == string385
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_383(xm)
do383save:              ;           0 6 do_383(xm)
    ld  (idx383),BC     ; 4:20      0 6 do_383(xm)
do383:                  ;           0 6 do_383(xm)
    push DE             ; 1:11      i_383(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_383(m)
    ld   HL, (idx383)   ; 3:16      i_383(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u> m2   _TMP_STACK_INFO #variant: variable
  .warning The condition "m2" cannot be evaluated
    ld    A, low m2     ; 2:7       u> m2   HL>m2 --> 0>m2-HL --> false if not carry
    sub   L             ; 1:4       u> m2   HL>m2 --> 0>m2-HL --> false if not carry
    ld    A, high m2    ; 2:7       u> m2   HL>m2 --> 0>m2-HL --> false if not carry
    sbc   A, H          ; 1:4       u> m2   HL>m2 --> 0>m2-HL --> false if not carry
    jp   nc, else383    ; 3:10      u> m2   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif383       ; 3:10      else
else383:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif383:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_383(xm)   variant -1.A: step -1 and stop 0, run 7x
idx383 EQU $+1          ;           -1 +loop_383(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_383(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_383(xm)
    or    B             ; 1:4       -1 +loop_383(xm)
    dec  BC             ; 1:6       -1 +loop_383(xm)   index--
    jp   nz, do383save  ; 3:10      -1 +loop_383(xm)
leave383:               ;           -1 +loop_383(xm)
exit383:                ;           xloop LOOP_STACK
    ld   BC, string387  ; 3:10      print_i   Address of string387 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_384(xm)
do384save:              ;           0 6 do_384(xm)
    ld  (idx384),BC     ; 4:20      0 6 do_384(xm)
do384:                  ;           0 6 do_384(xm)
    push DE             ; 1:11      i_384(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_384(m)
    ld   HL, (idx384)   ; 3:16      i_384(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u> m2   _TMP_STACK_INFO #variant: variable
  .warning The condition "m2" cannot be evaluated
    ld    A, low m2     ; 2:7       u> m2   HL>m2 --> 0>m2-HL --> false if not carry
    sub   L             ; 1:4       u> m2   HL>m2 --> 0>m2-HL --> false if not carry
    ld    A, high m2    ; 2:7       u> m2   HL>m2 --> 0>m2-HL --> false if not carry
    sbc   A, H          ; 1:4       u> m2   HL>m2 --> 0>m2-HL --> false if not carry
    ex   DE, HL         ; 1:4       u> m2
    pop  DE             ; 1:10      u> m2
    jp   nc, else384    ; 3:10      u> m2   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif384       ; 3:10      else
else384:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif384:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_384(xm)   variant -1.A: step -1 and stop 0, run 7x
idx384 EQU $+1          ;           -1 +loop_384(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_384(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_384(xm)
    or    B             ; 1:4       -1 +loop_384(xm)
    dec  BC             ; 1:6       -1 +loop_384(xm)   index--
    jp   nz, do384save  ; 3:10      -1 +loop_384(xm)
leave384:               ;           -1 +loop_384(xm)
exit384:                ;           xloop LOOP_STACK
    ld   BC, string388  ; 3:10      print_i   Address of string388 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
; ---- -1 ------
    ld   BC, 6          ; 3:10      0 6 do_385(xm)
do385save:              ;           0 6 do_385(xm)
    ld  (idx385),BC     ; 4:20      0 6 do_385(xm)
do385:                  ;           0 6 do_385(xm)
    push DE             ; 1:11      i_385(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_385(m)
    ld   HL, (idx385)   ; 3:16      i_385(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[3:10]     u> -1   _TMP_STACK_INFO variant: u>max
  .warning The condition is always False!
    jp   else385        ; 3:10      u> -1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif385       ; 3:10      else
else385:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif385:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_385(xm)   variant -1.A: step -1 and stop 0, run 7x
idx385 EQU $+1          ;           -1 +loop_385(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_385(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_385(xm)
    or    B             ; 1:4       -1 +loop_385(xm)
    dec  BC             ; 1:6       -1 +loop_385(xm)   index--
    jp   nz, do385save  ; 3:10      -1 +loop_385(xm)
leave385:               ;           -1 +loop_385(xm)
exit385:                ;           xloop LOOP_STACK
    ld   BC, string389  ; 3:10      print_i   Address of string389 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_386(xm)
do386save:              ;           0 6 do_386(xm)
    ld  (idx386),BC     ; 4:20      0 6 do_386(xm)
do386:                  ;           0 6 do_386(xm)
    push DE             ; 1:11      i_386(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_386(m)
    ld   HL, (idx386)   ; 3:16      i_386(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[5:24]     u> -1   _TMP_STACK_INFO variant: u>max
  .warning The condition is always False!
    ex   DE, HL         ; 1:4       u> -1
    pop  DE             ; 1:10      u> -1
    jp   else386        ; 3:10      u> -1
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif386       ; 3:10      else
else386:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif386:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_386(xm)   variant -1.A: step -1 and stop 0, run 7x
idx386 EQU $+1          ;           -1 +loop_386(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_386(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_386(xm)
    or    B             ; 1:4       -1 +loop_386(xm)
    dec  BC             ; 1:6       -1 +loop_386(xm)   index--
    jp   nz, do386save  ; 3:10      -1 +loop_386(xm)
leave386:               ;           -1 +loop_386(xm)
exit386:                ;           xloop LOOP_STACK
    ld   BC, string389  ; 3:10      print_i   Address of string390 ending with inverted most significant bit == string389
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_387(xm)
do387save:              ;           0 6 do_387(xm)
    ld  (idx387),BC     ; 4:20      0 6 do_387(xm)
do387:                  ;           0 6 do_387(xm)
    push DE             ; 1:11      i_387(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_387(m)
    ld   HL, (idx387)   ; 3:16      i_387(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                        ;[9:32]     u> m1   _TMP_STACK_INFO #variant: variable
  .warning The condition "m1" cannot be evaluated
    ld    A, low m1     ; 2:7       u> m1   HL>m1 --> 0>m1-HL --> false if not carry
    sub   L             ; 1:4       u> m1   HL>m1 --> 0>m1-HL --> false if not carry
    ld    A, high m1    ; 2:7       u> m1   HL>m1 --> 0>m1-HL --> false if not carry
    sbc   A, H          ; 1:4       u> m1   HL>m1 --> 0>m1-HL --> false if not carry
    jp   nc, else387    ; 3:10      u> m1   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif387       ; 3:10      else
else387:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif387:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
    ex   DE, HL         ; 1:4       drop
    pop  DE             ; 1:10      drop   ( a -- )
                        ;[9:54/34]  -1 +loop_387(xm)   variant -1.A: step -1 and stop 0, run 7x
idx387 EQU $+1          ;           -1 +loop_387(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_387(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_387(xm)
    or    B             ; 1:4       -1 +loop_387(xm)
    dec  BC             ; 1:6       -1 +loop_387(xm)   index--
    jp   nz, do387save  ; 3:10      -1 +loop_387(xm)
leave387:               ;           -1 +loop_387(xm)
exit387:                ;           xloop LOOP_STACK
    ld   BC, string391  ; 3:10      print_i   Address of string391 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, 6          ; 3:10      0 6 do_388(xm)
do388save:              ;           0 6 do_388(xm)
    ld  (idx388),BC     ; 4:20      0 6 do_388(xm)
do388:                  ;           0 6 do_388(xm)
    push DE             ; 1:11      i_388(m)   ( -- i )
    ex   DE, HL         ; 1:4       i_388(m)
    ld   HL, (idx388)   ; 3:16      i_388(m)   idx always points to a 16-bit index
    add  HL, HL         ; 1:11      2*
    ; warning M4 does not know the numerical value of >>>_umax<<<
    ld   BC, _umax      ; 3:10      _umax +
    add  HL, BC         ; 1:11      _umax +
    ld    A, (HL)       ; 1:7       @   ( addr -- x )
    inc  HL             ; 1:6       @
    ld    H, (HL)       ; 1:7       @
    ld    L, A          ; 1:4       @

         
         
                       ;[11:46]     u> m1   _TMP_STACK_INFO #variant: variable
  .warning The condition "m1" cannot be evaluated
    ld    A, low m1     ; 2:7       u> m1   HL>m1 --> 0>m1-HL --> false if not carry
    sub   L             ; 1:4       u> m1   HL>m1 --> 0>m1-HL --> false if not carry
    ld    A, high m1    ; 2:7       u> m1   HL>m1 --> 0>m1-HL --> false if not carry
    sbc   A, H          ; 1:4       u> m1   HL>m1 --> 0>m1-HL --> false if not carry
    ex   DE, HL         ; 1:4       u> m1
    pop  DE             ; 1:10      u> m1
    jp   nc, else388    ; 3:10      u> m1   false if not carry
                        ;[0:0]      -1 if
  .warning: : The condition is always True!
    ld    A, '+'        ; 2:7       '+' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '+' emit   putchar(reg A) with ZX 48K ROM
    jp   endif388       ; 3:10      else
else388:                ;           else
    ld    A, '-'        ; 2:7       '-' emit   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      '-' emit   putchar(reg A) with ZX 48K ROM
endif388:               ;           then
    ld    A, ' '        ; 2:7       space   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      space   putchar(reg A) with ZX 48K ROM
                        ;[9:54/34]  -1 +loop_388(xm)   variant -1.A: step -1 and stop 0, run 7x
idx388 EQU $+1          ;           -1 +loop_388(xm)   idx always points to a 16-bit index
    ld   BC, 0x0000     ; 3:10      -1 +loop_388(xm)   6.. -1 ..0, real_stop:0xFFFF
    ld    A, C          ; 1:4       -1 +loop_388(xm)
    or    B             ; 1:4       -1 +loop_388(xm)
    dec  BC             ; 1:6       -1 +loop_388(xm)   index--
    jp   nz, do388save  ; 3:10      -1 +loop_388(xm)
leave388:               ;           -1 +loop_388(xm)
exit388:                ;           xloop LOOP_STACK
    ld   BC, string392  ; 3:10      print_i   Address of string392 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ld   BC, string393  ; 3:10      print_i   Address of string393 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
                        ;[13:72]    depth   ( -- +n )
    push DE             ; 1:11      depth
    ex   DE, HL         ; 1:4       depth
    ld   HL,(Stop+1)    ; 3:16      depth
    or    A             ; 1:4       depth
    sbc  HL, SP         ; 2:15      depth
    srl   H             ; 2:8       depth
    rr    L             ; 2:8       depth
    dec  HL             ; 1:6       depth
    call PRT_S16        ; 3:17      .   ( s -- )
    ld   BC, string394  ; 3:10      print_i   Address of string394 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
    ex   DE, HL         ; 1:4       ras   ( -- return_address_stack )
    exx                 ; 1:4       ras
    push HL             ; 1:11      ras
    exx                 ; 1:4       ras
    ex  (SP),HL         ; 1:19      ras
    call PRT_U16        ; 3:17      u.   ( u -- )
    ld    A, 0x0D       ; 2:7       cr   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      cr   putchar(reg A) with ZX 48K ROM
Stop:                   ;           stop
    ld   SP, 0x0000     ; 3:10      stop   restoring the original SP value when the "bye" word is used
    ld   HL, 0x2758     ; 3:10      stop
    exx                 ; 1:4       stop
    ret                 ; 1:10      stop
;   =====  e n d  =====
;   ---  the beginning of a non-recursive function  ---
x_x_test:               ;           
    pop  BC             ; 1:10      : ret
    ld  (x_x_test_end+1),BC; 4:20      : ( ret -- )
    ld    A, E          ; 1:4       2dup = if
    sub   L             ; 1:4       2dup = if
    jp   nz, else389    ; 3:10      2dup = if
    ld    A, D          ; 1:4       2dup = if
    sub   H             ; 1:4       2dup = if
    jp   nz, else389    ; 3:10      2dup = if
    ld   BC, string395  ; 3:10      print_i   Address of string395 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
else389  EQU $          ;           then  = endif
endif389:               ;           then
    push DE             ; 1:11      2dup =
    push HL             ; 1:11      2dup =   ( b a -- b a b a )
                        ;[9:48/49]  2dup =
    xor   A             ; 1:4       2dup =   A = 0x00
    sbc  HL, DE         ; 2:15      2dup =
    jr   nz, $+3        ; 2:7/12    2dup =
    dec   A             ; 1:4       2dup =   A = 0xFF
    ld    L, A          ; 1:4       2dup =
    ld    H, A          ; 1:4       2dup =   HL= flag
    pop  DE             ; 1:10      2dup =

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else390    ; 3:10      if
    ld   BC, string395  ; 3:10      print_i   Address of string396 ending with inverted most significant bit == string395
    call PRINT_STRING_I ; 3:17      print_i
else390  EQU $          ;           then  = endif
endif390:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                        ;[8:49]     = if   ( x2 x1 -- )  flag: x2 == x1
    or    A             ; 1:4       = if
    sbc  HL, DE         ; 2:15      = if
    pop  HL             ; 1:10      = if
    pop  DE             ; 1:10      = if
    jp   nz, else391    ; 3:10      = if
    ld   BC, string395  ; 3:10      print_i   Address of string397 ending with inverted most significant bit == string395
    call PRINT_STRING_I ; 3:17      print_i
else391  EQU $          ;           then  = endif
endif391:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                        ;[9:48/49]  =
    xor   A             ; 1:4       =   A = 0x00
    sbc  HL, DE         ; 2:15      =
    jr   nz, $+3        ; 2:7/12    =
    dec   A             ; 1:4       =   A = 0xFF
    ld    L, A          ; 1:4       =
    ld    H, A          ; 1:4       =   HL= flag
    pop  DE             ; 1:10      =

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else392    ; 3:10      if
    ld   BC, string398  ; 3:10      print_i   Address of string398 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
else392  EQU $          ;           then  = endif
endif392:               ;           then
    ld    A, E          ; 1:4       2dup <> if
    sub   L             ; 1:4       2dup <> if
    jr   nz, $+7        ; 2:7/12    2dup <> if
    ld    A, D          ; 1:4       2dup <> if
    sub   H             ; 1:4       2dup <> if
    jp    z, else393    ; 3:10      2dup <> if
    ld   BC, string399  ; 3:10      print_i   Address of string399 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
else393  EQU $          ;           then  = endif
endif393:               ;           then
    push DE             ; 1:11      2dup <>
    push HL             ; 1:11      2dup <>   ( b a -- b a b a )
    or    A             ; 1:4       2dup <>
    sbc  HL, DE         ; 2:15      2dup <>
    jr    z, $+5        ; 2:7/12    2dup <>
    ld   HL, 0xFFFF     ; 3:10      2dup <>
    pop  DE             ; 1:10      2dup <>

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else394    ; 3:10      if
    ld   BC, string399  ; 3:10      print_i   Address of string400 ending with inverted most significant bit == string399
    call PRINT_STRING_I ; 3:17      print_i
else394  EQU $          ;           then  = endif
endif394:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                        ;[8:49]     <> if   ( x2 x1 -- )  flag: x2 <> x1
    or    A             ; 1:4       <> if
    sbc  HL, DE         ; 2:15      <> if
    pop  HL             ; 1:10      <> if
    pop  DE             ; 1:10      <> if
    jp    z, else395    ; 3:10      <> if
    ld   BC, string399  ; 3:10      print_i   Address of string401 ending with inverted most significant bit == string399
    call PRINT_STRING_I ; 3:17      print_i
else395  EQU $          ;           then  = endif
endif395:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

    or    A             ; 1:4       <>
    sbc  HL, DE         ; 2:15      <>
    jr    z, $+5        ; 2:7/12    <>
    ld   HL, 0xFFFF     ; 3:10      <>
    pop  DE             ; 1:10      <>

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else396    ; 3:10      if
    ld   BC, string402  ; 3:10      print_i   Address of string402 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
else396  EQU $          ;           then  = endif
endif396:               ;           then
    ld    A, E          ; 1:4       2dup < if    DE<HL --> DE-HL<0 --> carry if true
    sub   L             ; 1:4       2dup < if    DE<HL --> DE-HL<0 --> carry if true
    ld    A, D          ; 1:4       2dup < if    DE<HL --> DE-HL<0 --> carry if true
    sbc   A, H          ; 1:4       2dup < if    DE<HL --> DE-HL<0 --> carry if true
    rra                 ; 1:4       2dup < if
    xor   D             ; 1:4       2dup < if
    xor   H             ; 1:4       2dup < if
    jp    p, else397    ; 3:10      2dup < if
    ld   BC, string403  ; 3:10      print_i   Address of string403 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
else397  EQU $          ;           then  = endif
endif397:               ;           then
    push DE             ; 1:11      2dup <
    push HL             ; 1:11      2dup <   ( b a -- b a b a )
                       ;[12:54]     2dup <   ( x2 x1 -- flag x2<x1 )
    ld    A, E          ; 1:4       2dup <   DE<HL --> DE-HL<0 --> carry if true
    sub   L             ; 1:4       2dup <   DE<HL --> DE-HL<0 --> carry if true
    ld    A, D          ; 1:4       2dup <   DE<HL --> DE-HL<0 --> carry if true
    sbc   A, H          ; 1:4       2dup <   DE<HL --> DE-HL<0 --> carry if true
    rra                 ; 1:4       2dup <   carry --> sign
    xor   H             ; 1:4       2dup <
    xor   D             ; 1:4       2dup <
    add   A, A          ; 1:4       2dup <   sign --> carry
    sbc   A, A          ; 1:4       2dup <   0x00 or 0xff
    ld    H, A          ; 1:4       2dup <
    ld    L, A          ; 1:4       2dup <
    pop  DE             ; 1:10      2dup <

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else398    ; 3:10      if
    ld   BC, string403  ; 3:10      print_i   Address of string404 ending with inverted most significant bit == string403
    call PRINT_STRING_I ; 3:17      print_i
else398  EQU $          ;           then  = endif
endif398:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                       ;[12:58]     < if   ( x2 x1 -- )  flag: x2 < x1
    ld    A, E          ; 1:4       < if   DE<HL --> DE-HL<0 --> false if not carry
    sub   L             ; 1:4       < if   DE<HL --> DE-HL<0 --> false if not carry
    ld    A, D          ; 1:4       < if   DE<HL --> DE-HL<0 --> false if not carry
    sbc   A, H          ; 1:4       < if   DE<HL --> DE-HL<0 --> false if not carry
    rra                 ; 1:4       < if
    xor   H             ; 1:4       < if
    xor   D             ; 1:4       < if
    pop  HL             ; 1:10      < if
    pop  DE             ; 1:10      < if
    jp    p, else399    ; 3:10      < if
    ld   BC, string403  ; 3:10      print_i   Address of string405 ending with inverted most significant bit == string403
    call PRINT_STRING_I ; 3:17      print_i
else399  EQU $          ;           then  = endif
endif399:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                       ;[12:54]     <   ( x2 x1 -- flag x2<x1 )
    ld    A, E          ; 1:4       <   DE<HL --> DE-HL<0 --> carry if true
    sub   L             ; 1:4       <   DE<HL --> DE-HL<0 --> carry if true
    ld    A, D          ; 1:4       <   DE<HL --> DE-HL<0 --> carry if true
    sbc   A, H          ; 1:4       <   DE<HL --> DE-HL<0 --> carry if true
    rra                 ; 1:4       <   carry --> sign
    xor   H             ; 1:4       <
    xor   D             ; 1:4       <
    add   A, A          ; 1:4       <   sign --> carry
    sbc   A, A          ; 1:4       <   0x00 or 0xff
    ld    H, A          ; 1:4       <
    ld    L, A          ; 1:4       <
    pop  DE             ; 1:10      <

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else400    ; 3:10      if
    ld   BC, string406  ; 3:10      print_i   Address of string406 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
else400  EQU $          ;           then  = endif
endif400:               ;           then
    ld    A, L          ; 1:4       2dup <= if    DE<=HL --> HL-DE>=0 --> not carry if true
    sub   E             ; 1:4       2dup <= if    DE<=HL --> HL-DE>=0 --> not carry if true
    ld    A, H          ; 1:4       2dup <= if    DE<=HL --> HL-DE>=0 --> not carry if true
    sbc   A, D          ; 1:4       2dup <= if    DE<=HL --> HL-DE>=0 --> not carry if true
    rra                 ; 1:4       2dup <= if
    xor   D             ; 1:4       2dup <= if
    xor   H             ; 1:4       2dup <= if
    jp    m, else401    ; 3:10      2dup <= if
    ld   BC, string407  ; 3:10      print_i   Address of string407 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
else401  EQU $          ;           then  = endif
endif401:               ;           then
    push DE             ; 1:11      2dup <=
    push HL             ; 1:11      2dup <=   ( b a -- b a b a )
                       ;[13:57]     2dup <=   ( x2 x1 -- flag x2<=x1 )
    ld    A, L          ; 1:4       2dup <=   DE<=HL --> 0<=HL-DE --> no carry if true
    sub   E             ; 1:4       2dup <=   DE<=HL --> 0<=HL-DE --> no carry if true
    ld    A, H          ; 1:4       2dup <=   DE<=HL --> 0<=HL-DE --> no carry if true
    sbc   A, D          ; 1:4       2dup <=   DE<=HL --> 0<=HL-DE --> no carry if true
    rra                 ; 1:4       2dup <=   carry --> sign
    xor   H             ; 1:4       2dup <=
    xor   D             ; 1:4       2dup <=
    sub  0x80           ; 2:7       2dup <=   sign --> invert carry
    sbc   A, A          ; 1:4       2dup <=   0x00 or 0xff
    ld    H, A          ; 1:4       2dup <=
    ld    L, A          ; 1:4       2dup <=
    pop  DE             ; 1:10      2dup <=

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else402    ; 3:10      if
    ld   BC, string407  ; 3:10      print_i   Address of string408 ending with inverted most significant bit == string407
    call PRINT_STRING_I ; 3:17      print_i
else402  EQU $          ;           then  = endif
endif402:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                       ;[12:58]     <= if   ( x2 x1 -- )  flag: x2 <= x1
    ld    A, L          ; 1:4       <= if   DE<=HL --> 0<=HL-DE --> false if carry
    sub   E             ; 1:4       <= if   DE<=HL --> 0<=HL-DE --> false if carry
    ld    A, H          ; 1:4       <= if   DE<=HL --> 0<=HL-DE --> false if carry
    sbc   A, D          ; 1:4       <= if   DE<=HL --> 0<=HL-DE --> false if carry
    rra                 ; 1:4       <= if
    xor   H             ; 1:4       <= if
    xor   D             ; 1:4       <= if
    pop  HL             ; 1:10      <= if
    pop  DE             ; 1:10      <= if
    jp    m, else403    ; 3:10      <= if
    ld   BC, string407  ; 3:10      print_i   Address of string409 ending with inverted most significant bit == string407
    call PRINT_STRING_I ; 3:17      print_i
else403  EQU $          ;           then  = endif
endif403:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                       ;[13:57]     <=   ( x2 x1 -- flag x2<=x1 )
    ld    A, L          ; 1:4       <=   DE<=HL --> 0<=HL-DE --> no carry if true
    sub   E             ; 1:4       <=   DE<=HL --> 0<=HL-DE --> no carry if true
    ld    A, H          ; 1:4       <=   DE<=HL --> 0<=HL-DE --> no carry if true
    sbc   A, D          ; 1:4       <=   DE<=HL --> 0<=HL-DE --> no carry if true
    rra                 ; 1:4       <=   carry --> sign
    xor   H             ; 1:4       <=
    xor   D             ; 1:4       <=
    sub  0x80           ; 2:7       <=   sign --> invert carry
    sbc   A, A          ; 1:4       <=   0x00 or 0xff
    ld    H, A          ; 1:4       <=
    ld    L, A          ; 1:4       <=
    pop  DE             ; 1:10      <=

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else404    ; 3:10      if
    ld   BC, string410  ; 3:10      print_i   Address of string410 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
else404  EQU $          ;           then  = endif
endif404:               ;           then
    ld    A, L          ; 1:4       2dup > if    DE>HL --> HL-DE<0 --> carry if true
    sub   E             ; 1:4       2dup > if    DE>HL --> HL-DE<0 --> carry if true
    ld    A, H          ; 1:4       2dup > if    DE>HL --> HL-DE<0 --> carry if true
    sbc   A, D          ; 1:4       2dup > if    DE>HL --> HL-DE<0 --> carry if true
    rra                 ; 1:4       2dup > if
    xor   D             ; 1:4       2dup > if
    xor   H             ; 1:4       2dup > if
    jp    p, else405    ; 3:10      2dup > if
    ld   BC, string411  ; 3:10      print_i   Address of string411 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
else405  EQU $          ;           then  = endif
endif405:               ;           then
    push DE             ; 1:11      2dup >
    push HL             ; 1:11      2dup >   ( b a -- b a b a )
                       ;[12:54]     2dup >   ( x2 x1 -- flag x2>x1 )
    ld    A, L          ; 1:4       2dup >   DE>HL --> 0>HL-DE --> carry if true
    sub   E             ; 1:4       2dup >   DE>HL --> 0>HL-DE --> carry if true
    ld    A, H          ; 1:4       2dup >   DE>HL --> 0>HL-DE --> carry if true
    sbc   A, D          ; 1:4       2dup >   DE>HL --> 0>HL-DE --> carry if true
    rra                 ; 1:4       2dup >   carry --> sign
    xor   H             ; 1:4       2dup >
    xor   D             ; 1:4       2dup >
    add   A, A          ; 1:4       2dup >   sign --> carry
    sbc   A, A          ; 1:4       2dup >   0x00 or 0xff
    ld    H, A          ; 1:4       2dup >
    ld    L, A          ; 1:4       2dup >
    pop  DE             ; 1:10      2dup >

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else406    ; 3:10      if
    ld   BC, string411  ; 3:10      print_i   Address of string412 ending with inverted most significant bit == string411
    call PRINT_STRING_I ; 3:17      print_i
else406  EQU $          ;           then  = endif
endif406:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                       ;[12:58]     > if   ( x2 x1 -- )  flag: x2 > x1
    ld    A, L          ; 1:4       > if   DE>HL --> 0>HL-DE --> false if not carry
    sub   E             ; 1:4       > if   DE>HL --> 0>HL-DE --> false if not carry
    ld    A, H          ; 1:4       > if   DE>HL --> 0>HL-DE --> false if not carry
    sbc   A, D          ; 1:4       > if   DE>HL --> 0>HL-DE --> false if not carry
    rra                 ; 1:4       > if
    xor   H             ; 1:4       > if
    xor   D             ; 1:4       > if
    pop  HL             ; 1:10      > if
    pop  DE             ; 1:10      > if
    jp    p, else407    ; 3:10      > if
    ld   BC, string411  ; 3:10      print_i   Address of string413 ending with inverted most significant bit == string411
    call PRINT_STRING_I ; 3:17      print_i
else407  EQU $          ;           then  = endif
endif407:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                       ;[12:54]     >   ( x2 x1 -- flag x2>x1 )
    ld    A, L          ; 1:4       >   DE>HL --> 0>HL-DE --> carry if true
    sub   E             ; 1:4       >   DE>HL --> 0>HL-DE --> carry if true
    ld    A, H          ; 1:4       >   DE>HL --> 0>HL-DE --> carry if true
    sbc   A, D          ; 1:4       >   DE>HL --> 0>HL-DE --> carry if true
    rra                 ; 1:4       >   carry --> sign
    xor   H             ; 1:4       >
    xor   D             ; 1:4       >
    add   A, A          ; 1:4       >   sign --> carry
    sbc   A, A          ; 1:4       >   0x00 or 0xff
    ld    H, A          ; 1:4       >
    ld    L, A          ; 1:4       >
    pop  DE             ; 1:10      >

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else408    ; 3:10      if
    ld   BC, string414  ; 3:10      print_i   Address of string414 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
else408  EQU $          ;           then  = endif
endif408:               ;           then
    ld    A, E          ; 1:4       2dup >= if    DE>=HL --> DE-HL>=0 --> not carry if true
    sub   L             ; 1:4       2dup >= if    DE>=HL --> DE-HL>=0 --> not carry if true
    ld    A, D          ; 1:4       2dup >= if    DE>=HL --> DE-HL>=0 --> not carry if true
    sbc   A, H          ; 1:4       2dup >= if    DE>=HL --> DE-HL>=0 --> not carry if true
    rra                 ; 1:4       2dup >= if
    xor   D             ; 1:4       2dup >= if
    xor   H             ; 1:4       2dup >= if
    jp    m, else409    ; 3:10      2dup >= if
    ld   BC, string415  ; 3:10      print_i   Address of string415 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
else409  EQU $          ;           then  = endif
endif409:               ;           then
    push DE             ; 1:11      2dup >=
    push HL             ; 1:11      2dup >=   ( b a -- b a b a )
                       ;[13:57]     2dup >=   ( x2 x1 -- flag x2>=x1 )
    ld    A, E          ; 1:4       2dup >=   DE>=HL --> DE-HL>=0 --> no carry if true
    sub   L             ; 1:4       2dup >=   DE>=HL --> DE-HL>=0 --> no carry if true
    ld    A, D          ; 1:4       2dup >=   DE>=HL --> DE-HL>=0 --> no carry if true
    sbc   A, H          ; 1:4       2dup >=   DE>=HL --> DE-HL>=0 --> no carry if true
    rra                 ; 1:4       2dup >=   carry --> sign
    xor   H             ; 1:4       2dup >=
    xor   D             ; 1:4       2dup >=
    sub  0x80           ; 2:7       2dup >=   sign --> invert carry
    sbc   A, A          ; 1:4       2dup >=   0x00 or 0xff
    ld    H, A          ; 1:4       2dup >=
    ld    L, A          ; 1:4       2dup >=
    pop  DE             ; 1:10      2dup >=

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else410    ; 3:10      if
    ld   BC, string415  ; 3:10      print_i   Address of string416 ending with inverted most significant bit == string415
    call PRINT_STRING_I ; 3:17      print_i
else410  EQU $          ;           then  = endif
endif410:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                       ;[12:58]     >= if   ( x2 x1 -- )  flag: x2 >= x1
    ld    A, E          ; 1:4       >= if   DE>=HL --> DE-HL>=0 --> false if carry
    sub   L             ; 1:4       >= if   DE>=HL --> DE-HL>=0 --> false if carry
    ld    A, D          ; 1:4       >= if   DE>=HL --> DE-HL>=0 --> false if carry
    sbc   A, H          ; 1:4       >= if   DE>=HL --> DE-HL>=0 --> false if carry
    rra                 ; 1:4       >= if
    xor   H             ; 1:4       >= if
    xor   D             ; 1:4       >= if
    pop  HL             ; 1:10      >= if
    pop  DE             ; 1:10      >= if
    jp    m, else411    ; 3:10      >= if
    ld   BC, string415  ; 3:10      print_i   Address of string417 ending with inverted most significant bit == string415
    call PRINT_STRING_I ; 3:17      print_i
else411  EQU $          ;           then  = endif
endif411:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                       ;[13:57]     >=   ( x2 x1 -- flag x2>=x1 )
    ld    A, E          ; 1:4       >=   DE>=HL --> DE-HL>=0 --> no carry if true
    sub   L             ; 1:4       >=   DE>=HL --> DE-HL>=0 --> no carry if true
    ld    A, D          ; 1:4       >=   DE>=HL --> DE-HL>=0 --> no carry if true
    sbc   A, H          ; 1:4       >=   DE>=HL --> DE-HL>=0 --> no carry if true
    rra                 ; 1:4       >=   carry --> sign
    xor   H             ; 1:4       >=
    xor   D             ; 1:4       >=
    sub  0x80           ; 2:7       >=   sign --> invert carry
    sbc   A, A          ; 1:4       >=   0x00 or 0xff
    ld    H, A          ; 1:4       >=
    ld    L, A          ; 1:4       >=
    pop  DE             ; 1:10      >=

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else412    ; 3:10      if
    ld   BC, string418  ; 3:10      print_i   Address of string418 ending with inverted most significant bit
    call PRINT_STRING_I ; 3:17      print_i
else412  EQU $          ;           then  = endif
endif412:               ;           then
    push DE             ; 1:11      over   ( b a -- b a b )
    ex   DE, HL         ; 1:4       over
    call PRT_S16        ; 3:17      .   ( s -- )
    push DE             ; 1:11      dup   ( a -- a a )
    ld    D, H          ; 1:4       dup
    ld    E, L          ; 1:4       dup
    call PRT_SP_S16     ; 3:17      space .   ( s -- )
    ld    A, 0x0D       ; 2:7       cr   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      cr   putchar(reg A) with ZX 48K ROM
    ld    A, E          ; 1:4       2dup u= if
    sub   L             ; 1:4       2dup u= if
    jp   nz, else413    ; 3:10      2dup u= if
    ld    A, D          ; 1:4       2dup u= if
    sub   H             ; 1:4       2dup u= if
    jp   nz, else413    ; 3:10      2dup u= if
    ld   BC, string395  ; 3:10      print_i   Address of string419 ending with inverted most significant bit == string395
    call PRINT_STRING_I ; 3:17      print_i
else413  EQU $          ;           then  = endif
endif413:               ;           then
    push DE             ; 1:11      2dup u=
    push HL             ; 1:11      2dup u=   ( b a -- b a b a )
                        ;[9:48/49]  2dup u=
    xor   A             ; 1:4       2dup u=   A = 0x00
    sbc  HL, DE         ; 2:15      2dup u=
    jr   nz, $+3        ; 2:7/12    2dup u=
    dec   A             ; 1:4       2dup u=   A = 0xFF
    ld    L, A          ; 1:4       2dup u=
    ld    H, A          ; 1:4       2dup u=   HL= flag
    pop  DE             ; 1:10      2dup u=

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else414    ; 3:10      if
    ld   BC, string395  ; 3:10      print_i   Address of string420 ending with inverted most significant bit == string395
    call PRINT_STRING_I ; 3:17      print_i
else414  EQU $          ;           then  = endif
endif414:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                        ;[8:49]     u= if   ( x2 x1 -- )  flag: x2 == x1
    or    A             ; 1:4       u= if
    sbc  HL, DE         ; 2:15      u= if
    pop  HL             ; 1:10      u= if
    pop  DE             ; 1:10      u= if
    jp   nz, else415    ; 3:10      u= if
    ld   BC, string395  ; 3:10      print_i   Address of string421 ending with inverted most significant bit == string395
    call PRINT_STRING_I ; 3:17      print_i
else415  EQU $          ;           then  = endif
endif415:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                        ;[9:48/49]  u=
    xor   A             ; 1:4       u=   A = 0x00
    sbc  HL, DE         ; 2:15      u=
    jr   nz, $+3        ; 2:7/12    u=
    dec   A             ; 1:4       u=   A = 0xFF
    ld    L, A          ; 1:4       u=
    ld    H, A          ; 1:4       u=   HL= flag
    pop  DE             ; 1:10      u=

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else416    ; 3:10      if
    ld   BC, string398  ; 3:10      print_i   Address of string422 ending with inverted most significant bit == string398
    call PRINT_STRING_I ; 3:17      print_i
else416  EQU $          ;           then  = endif
endif416:               ;           then
    ld    A, E          ; 1:4       2dup u<> if
    sub   L             ; 1:4       2dup u<> if
    jr   nz, $+7        ; 2:7/12    2dup u<> if
    ld    A, D          ; 1:4       2dup u<> if
    sub   H             ; 1:4       2dup u<> if
    jp    z, else417    ; 3:10      2dup u<> if
    ld   BC, string399  ; 3:10      print_i   Address of string423 ending with inverted most significant bit == string399
    call PRINT_STRING_I ; 3:17      print_i
else417  EQU $          ;           then  = endif
endif417:               ;           then
    push DE             ; 1:11      2dup u<>
    push HL             ; 1:11      2dup u<>   ( b a -- b a b a )
    or    A             ; 1:4       2dup u<>
    sbc  HL, DE         ; 2:15      2dup u<>
    jr    z, $+5        ; 2:7/12    2dup u<>
    ld   HL, 0xFFFF     ; 3:10      2dup u<>
    pop  DE             ; 1:10      2dup u<>

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else418    ; 3:10      if
    ld   BC, string399  ; 3:10      print_i   Address of string424 ending with inverted most significant bit == string399
    call PRINT_STRING_I ; 3:17      print_i
else418  EQU $          ;           then  = endif
endif418:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                        ;[8:49]     u<> if   ( x2 x1 -- )  flag: x2 <> x1
    or    A             ; 1:4       u<> if
    sbc  HL, DE         ; 2:15      u<> if
    pop  HL             ; 1:10      u<> if
    pop  DE             ; 1:10      u<> if
    jp    z, else419    ; 3:10      u<> if
    ld   BC, string399  ; 3:10      print_i   Address of string425 ending with inverted most significant bit == string399
    call PRINT_STRING_I ; 3:17      print_i
else419  EQU $          ;           then  = endif
endif419:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

    or    A             ; 1:4       u<>
    sbc  HL, DE         ; 2:15      u<>
    jr    z, $+5        ; 2:7/12    u<>
    ld   HL, 0xFFFF     ; 3:10      u<>
    pop  DE             ; 1:10      u<>

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else420    ; 3:10      if
    ld   BC, string402  ; 3:10      print_i   Address of string426 ending with inverted most significant bit == string402
    call PRINT_STRING_I ; 3:17      print_i
else420  EQU $          ;           then  = endif
endif420:               ;           then
    ld    A, E          ; 1:4       2dup u< if    DE<HL --> DE-HL<0 --> carry if true
    sub   L             ; 1:4       2dup u< if    DE<HL --> DE-HL<0 --> carry if true
    ld    A, D          ; 1:4       2dup u< if    DE<HL --> DE-HL<0 --> carry if true
    sbc   A, H          ; 1:4       2dup u< if    DE<HL --> DE-HL<0 --> carry if true
    jp   nc, else421    ; 3:10      2dup u< if
    ld   BC, string403  ; 3:10      print_i   Address of string427 ending with inverted most significant bit == string403
    call PRINT_STRING_I ; 3:17      print_i
else421  EQU $          ;           then  = endif
endif421:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )
                        ;[7:41]     u<
    ld    A, E          ; 1:4       u<   DE<HL --> DE-HL<0 --> carry if true
    sub   L             ; 1:4       u<   DE<HL --> DE-HL<0 --> carry if true
    ld    A, D          ; 1:4       u<   DE<HL --> DE-HL<0 --> carry if true
    sbc   A, H          ; 1:4       u<   DE<HL --> DE-HL<0 --> carry if true
    sbc  HL, HL         ; 2:15      u<
    pop  DE             ; 1:10      u<

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else422    ; 3:10      if
    ld   BC, string403  ; 3:10      print_i   Address of string428 ending with inverted most significant bit == string403
    call PRINT_STRING_I ; 3:17      print_i
else422  EQU $          ;           then  = endif
endif422:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

    ld    A, E          ; 1:4       u< if    DE<HL --> DE-HL<0 --> carry if true
    sub   L             ; 1:4       u< if    DE<HL --> DE-HL<0 --> carry if true
    ld    A, D          ; 1:4       u< if    DE<HL --> DE-HL<0 --> carry if true
    sbc   A, H          ; 1:4       u< if    DE<HL --> DE-HL<0 --> carry if true
    pop  HL             ; 1:10      u< if
    pop  DE             ; 1:10      u< if
    jp   nc, else423    ; 3:10      u< if
    ld   BC, string403  ; 3:10      print_i   Address of string429 ending with inverted most significant bit == string403
    call PRINT_STRING_I ; 3:17      print_i
else423  EQU $          ;           then  = endif
endif423:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

                        ;[7:41]     u<
    ld    A, E          ; 1:4       u<   DE<HL --> DE-HL<0 --> carry if true
    sub   L             ; 1:4       u<   DE<HL --> DE-HL<0 --> carry if true
    ld    A, D          ; 1:4       u<   DE<HL --> DE-HL<0 --> carry if true
    sbc   A, H          ; 1:4       u<   DE<HL --> DE-HL<0 --> carry if true
    sbc  HL, HL         ; 2:15      u<
    pop  DE             ; 1:10      u<

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else424    ; 3:10      if
    ld   BC, string406  ; 3:10      print_i   Address of string430 ending with inverted most significant bit == string406
    call PRINT_STRING_I ; 3:17      print_i
else424  EQU $          ;           then  = endif
endif424:               ;           then
    ld    A, L          ; 1:4       2dup u<= if    DE<=HL --> 0<=HL-DE --> not carry if true
    sub   E             ; 1:4       2dup u<= if    DE<=HL --> 0<=HL-DE --> not carry if true
    ld    A, H          ; 1:4       2dup u<= if    DE<=HL --> 0<=HL-DE --> not carry if true
    sbc   A, D          ; 1:4       2dup u<= if    DE<=HL --> 0<=HL-DE --> not carry if true
    jp    c, else425    ; 3:10      2dup u<= if
    ld   BC, string407  ; 3:10      print_i   Address of string431 ending with inverted most significant bit == string407
    call PRINT_STRING_I ; 3:17      print_i
else425  EQU $          ;           then  = endif
endif425:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )
    scf                 ; 1:4       u<=
    ex   DE, HL         ; 1:4       u<=
    sbc  HL, DE         ; 2:15      u<=
    sbc  HL, HL         ; 2:15      u<=
    pop  DE             ; 1:10      u<=

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else426    ; 3:10      if
    ld   BC, string407  ; 3:10      print_i   Address of string432 ending with inverted most significant bit == string407
    call PRINT_STRING_I ; 3:17      print_i
else426  EQU $          ;           then  = endif
endif426:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

    ld    A, L          ; 1:4       u<= if    DE<=HL --> 0<=HL-DE --> not carry if true
    sub   E             ; 1:4       u<= if    DE<=HL --> 0<=HL-DE --> not carry if true
    ld    A, H          ; 1:4       u<= if    DE<=HL --> 0<=HL-DE --> not carry if true
    sbc   A, D          ; 1:4       u<= if    DE<=HL --> 0<=HL-DE --> not carry if true
    pop  HL             ; 1:10      u<= if
    pop  DE             ; 1:10      u<= if
    jp    c, else427    ; 3:10      u<= if
    ld   BC, string407  ; 3:10      print_i   Address of string433 ending with inverted most significant bit == string407
    call PRINT_STRING_I ; 3:17      print_i
else427  EQU $          ;           then  = endif
endif427:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

    scf                 ; 1:4       u<=
    ex   DE, HL         ; 1:4       u<=
    sbc  HL, DE         ; 2:15      u<=
    sbc  HL, HL         ; 2:15      u<=
    pop  DE             ; 1:10      u<=

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else428    ; 3:10      if
    ld   BC, string410  ; 3:10      print_i   Address of string434 ending with inverted most significant bit == string410
    call PRINT_STRING_I ; 3:17      print_i
else428  EQU $          ;           then  = endif
endif428:               ;           then
    ld    A, L          ; 1:4       2dup u> if    DE>HL --> 0>HL-DE --> carry if true
    sub   E             ; 1:4       2dup u> if    DE>HL --> 0>HL-DE --> carry if true
    ld    A, H          ; 1:4       2dup u> if    DE>HL --> 0>HL-DE --> carry if true
    sbc   A, D          ; 1:4       2dup u> if    DE>HL --> 0>HL-DE --> carry if true
    jp   nc, else429    ; 3:10      2dup u> if
    ld   BC, string411  ; 3:10      print_i   Address of string435 ending with inverted most significant bit == string411
    call PRINT_STRING_I ; 3:17      print_i
else429  EQU $          ;           then  = endif
endif429:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )
    or    A             ; 1:4       u>
    sbc  HL, DE         ; 2:15      u>
    sbc  HL, HL         ; 2:15      u>
    pop  DE             ; 1:10      u>

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else430    ; 3:10      if
    ld   BC, string411  ; 3:10      print_i   Address of string436 ending with inverted most significant bit == string411
    call PRINT_STRING_I ; 3:17      print_i
else430  EQU $          ;           then  = endif
endif430:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

    ld    A, L          ; 1:4       u> if    DE>HL --> 0>HL-DE --> carry if true
    sub   E             ; 1:4       u> if    DE>HL --> 0>HL-DE --> carry if true
    ld    A, H          ; 1:4       u> if    DE>HL --> 0>HL-DE --> carry if true
    sbc   A, D          ; 1:4       u> if    DE>HL --> 0>HL-DE --> carry if true
    pop  HL             ; 1:10      u> if
    pop  DE             ; 1:10      u> if
    jp   nc, else431    ; 3:10      u> if
    ld   BC, string411  ; 3:10      print_i   Address of string437 ending with inverted most significant bit == string411
    call PRINT_STRING_I ; 3:17      print_i
else431  EQU $          ;           then  = endif
endif431:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

    or    A             ; 1:4       u>
    sbc  HL, DE         ; 2:15      u>
    sbc  HL, HL         ; 2:15      u>
    pop  DE             ; 1:10      u>

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else432    ; 3:10      if
    ld   BC, string414  ; 3:10      print_i   Address of string438 ending with inverted most significant bit == string414
    call PRINT_STRING_I ; 3:17      print_i
else432  EQU $          ;           then  = endif
endif432:               ;           then
    ld    A, E          ; 1:4       2dup u>= if    DE>=HL --> DE-HL>=0 --> not carry if true
    sub   L             ; 1:4       2dup u>= if    DE>=HL --> DE-HL>=0 --> not carry if true
    ld    A, D          ; 1:4       2dup u>= if    DE>=HL --> DE-HL>=0 --> not carry if true
    sbc   A, H          ; 1:4       2dup u>= if    DE>=HL --> DE-HL>=0 --> not carry if true
    jp    c, else433    ; 3:10      2dup u>= if
    ld   BC, string415  ; 3:10      print_i   Address of string439 ending with inverted most significant bit == string415
    call PRINT_STRING_I ; 3:17      print_i
else433  EQU $          ;           then  = endif
endif433:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )
    scf                 ; 1:4       u>=
    sbc  HL, DE         ; 2:15      u>=
    sbc  HL, HL         ; 2:15      u>=
    pop  DE             ; 1:10      u>=

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else434    ; 3:10      if
    ld   BC, string415  ; 3:10      print_i   Address of string440 ending with inverted most significant bit == string415
    call PRINT_STRING_I ; 3:17      print_i
else434  EQU $          ;           then  = endif
endif434:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

    ld    A, E          ; 1:4       u>= if    DE>=HL --> DE-HL>=0 --> not carry if true
    sub   L             ; 1:4       u>= if    DE>=HL --> DE-HL>=0 --> not carry if true
    ld    A, D          ; 1:4       u>= if    DE>=HL --> DE-HL>=0 --> not carry if true
    sbc   A, H          ; 1:4       u>= if    DE>=HL --> DE-HL>=0 --> not carry if true
    pop  HL             ; 1:10      u>= if
    pop  DE             ; 1:10      u>= if
    jp    c, else435    ; 3:10      u>= if
    ld   BC, string415  ; 3:10      print_i   Address of string441 ending with inverted most significant bit == string415
    call PRINT_STRING_I ; 3:17      print_i
else435  EQU $          ;           then  = endif
endif435:               ;           then
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )

    scf                 ; 1:4       u>=
    sbc  HL, DE         ; 2:15      u>=
    sbc  HL, HL         ; 2:15      u>=
    pop  DE             ; 1:10      u>=

    ld    A, H          ; 1:4       if
    or    L             ; 1:4       if
    ex   DE, HL         ; 1:4       if
    pop  DE             ; 1:10      if
    jp    z, else436    ; 3:10      if
    ld   BC, string418  ; 3:10      print_i   Address of string442 ending with inverted most significant bit == string418
    call PRINT_STRING_I ; 3:17      print_i
else436  EQU $          ;           then  = endif
endif436:               ;           then
    ex   DE, HL         ; 1:4       swap   ( b a -- a b )
    call PRT_U16        ; 3:17      u.   ( u -- )
    call PRT_SP_U16     ; 3:17      space u.   ( u -- )
    ld    A, 0x0D       ; 2:7       cr   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      cr   putchar(reg A) with ZX 48K ROM
x_x_test_end:
    jp   0x0000         ; 3:10      ;
;   ---------  end of non-recursive function  ---------
;   ---  the beginning of a non-recursive function  ---
d_d_test:               ;           
    pop  BC             ; 1:10      : ret
    ld  (d_d_test_end+1),BC; 4:20      : ( ret -- )
                   ;[16:132/73,132] 4dup D= if   ( d2 d1 -- d2 d1 )   # default version can be changed with "define({_TYP_DOUBLE},{function})"
    or   A              ; 1:4       4dup D= if   h2 l2 . h1 l1
    pop  BC             ; 1:10      4dup D= if   h2    . h1 l1  BC = l2 = lo16(d2)
    sbc  HL, BC         ; 2:15      4dup D= if   h2    . h1 --  cp l1-l2
    add  HL, BC         ; 1:11      4dup D= if   h2    . h1 l1  cp l1-l2
    jr   nz, $+7        ; 2:7/12    4dup D= if   h2    . h1 h2
    ex  (SP),HL         ; 1:19      4dup D= if   l1    . h1 h2  HL = h2 = hi16(d2)
    sbc  HL, DE         ; 2:15      4dup D= if   l1    . h1 --  cp h2-h1
    add  HL, DE         ; 1:11      4dup D= if   l1    . h1 h2  cp h2-h1
    ex  (SP),HL         ; 1:19      4dup D= if   h2    . h1 l1  HL = l1
    push BC             ; 1:11      4dup D= if   h2 l2 . h1 l1
    jp   nz, else437    ; 3:10      4dup D= if   h2 l2 . h1 l1
    ld   BC, string395  ; 3:10      print_i   Address of string443 ending with inverted most significant bit == string395
    call PRINT_STRING_I ; 3:17      print_i
else437  EQU $          ;           then  = endif
endif437:               ;           then
                   ;[16:132/73,132] 4dup D= if   ( d2 d1 -- d2 d1 )   # default version can be changed with "define({_TYP_DOUBLE},{function})"
    or   A              ; 1:4       4dup D= if   h2 l2 . h1 l1
    pop  BC             ; 1:10      4dup D= if   h2    . h1 l1  BC = l2 = lo16(d2)
    sbc  HL, BC         ; 2:15      4dup D= if   h2    . h1 --  cp l1-l2
    add  HL, BC         ; 1:11      4dup D= if   h2    . h1 l1  cp l1-l2
    jr   nz, $+7        ; 2:7/12    4dup D= if   h2    . h1 h2
    ex  (SP),HL         ; 1:19      4dup D= if   l1    . h1 h2  HL = h2 = hi16(d2)
    sbc  HL, DE         ; 2:15      4dup D= if   l1    . h1 --  cp h2-h1
    add  HL, DE         ; 1:11      4dup D= if   l1    . h1 h2  cp h2-h1
    ex  (SP),HL         ; 1:19      4dup D= if   h2    . h1 l1  HL = l1
    push BC             ; 1:11      4dup D= if   h2 l2 . h1 l1
    jp   nz, else438    ; 3:10      4dup D= if   h2 l2 . h1 l1
    ld   BC, string395  ; 3:10      print_i   Address of string444 ending with inverted most significant bit == string395
    call PRINT_STRING_I ; 3:17      print_i
else438  EQU $          ;           then  = endif
endif438:               ;           then
                        ;[8:86]     4dup   ( d c b a -- d c b a d c b a )
    pop  BC             ; 1:10      4dup
    pop  AF             ; 1:10      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
    push DE             ; 1:11      4dup
    push HL             ; 1:11      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
                       ;[14:91]     d= if   ( d2 d1 -- )  flag: d2 == d1
    pop  BC             ; 1:10      d= if   lo_2
    or    A             ; 1:4       d= if
    sbc  HL, BC         ; 2:15      d= if   lo_2=lo_1 --> BC=HL --> 0=HL-BC --> nz if false
    pop  HL             ; 1:10      d= if   hi_2
    jr   nz, $+4        ; 2:7/12    d= if
    sbc  HL, DE         ; 2:15      d= if   hi_2=hi_1 --> DE=HL --> 0=HL-DE --> nz if false
    pop  HL             ; 1:10      d= if
    pop  DE             ; 1:10      d= if
    jp   nz, else439    ; 3:10      d= if
    ld   BC, string398  ; 3:10      print_i   Address of string445 ending with inverted most significant bit == string398
    call PRINT_STRING_I ; 3:17      print_i
else439  EQU $          ;           then  = endif
endif439:               ;           then
            ;[21:51,66,123,122/122] 4dup D<> if  ( d2 d1 -- d2 d1 )   # "define({_TYP_DOUBLE},{default})" version can be changed with function,small,fast,default
    pop  BC             ; 1:10      4dup D<> if   h2    . h1 l1  BC= lo(d2) = l2
    ld    A, C          ; 1:4       4dup D<> if   h2    . h1 l1  A = lo(l2)
    sub   L             ; 1:4       4dup D<> if   h2    . h1 l1  lo(l2) - lo(l1)
    jr   nz, $+14       ; 2:7/12    4dup D<> if   h2    . h1 l1  --> push bc
    ld    A, B          ; 1:4       4dup D<> if   h2    . h1 l1  A = hi(l2)
    sub   H             ; 1:4       4dup D<> if   h2    . h1 l1  hi(l2) - hi(l1)
    jr   nz, $+10       ; 2:7/12    4dup D<> if   h2    . h1 l1  --> push bc
    ex (SP), HL         ; 1:19      4dup D<> if   l1    . h1 h2  HL= hi(d2) = h2
    ld    A, L          ; 1:4       4dup D<> if   l1    . h1 h2  A = lo(h2)
    sub   E             ; 1:4       4dup D<> if   l1    . h1 h2  lo(h2) - lo(l1)
    ld    A, H          ; 1:4       4dup D<> if   l1    . h1 h2  A = hi(h2)
    ex (SP), HL         ; 1:19      4dup D<> if   h2    . h1 l1
    jr   nz, $+3        ; 2:7/12    4dup D<> if   h2    . h1 l1  --> push bc
    sub   D             ; 1:4       4dup D<> if   h2    . h1 l1  hi(h2) - hi(h1)
    push BC             ; 1:11      4dup D<> if   h2 l2 . h1 l1
    jp    z, else440    ; 3:10      4dup D<> if
    ld   BC, string399  ; 3:10      print_i   Address of string446 ending with inverted most significant bit == string399
    call PRINT_STRING_I ; 3:17      print_i
else440  EQU $          ;           then  = endif
endif440:               ;           then
            ;[21:51,66,123,122/122] 4dup D<> if  ( d2 d1 -- d2 d1 )   # "define({_TYP_DOUBLE},{default})" version can be changed with function,small,fast,default
    pop  BC             ; 1:10      4dup D<> if   h2    . h1 l1  BC= lo(d2) = l2
    ld    A, C          ; 1:4       4dup D<> if   h2    . h1 l1  A = lo(l2)
    sub   L             ; 1:4       4dup D<> if   h2    . h1 l1  lo(l2) - lo(l1)
    jr   nz, $+14       ; 2:7/12    4dup D<> if   h2    . h1 l1  --> push bc
    ld    A, B          ; 1:4       4dup D<> if   h2    . h1 l1  A = hi(l2)
    sub   H             ; 1:4       4dup D<> if   h2    . h1 l1  hi(l2) - hi(l1)
    jr   nz, $+10       ; 2:7/12    4dup D<> if   h2    . h1 l1  --> push bc
    ex (SP), HL         ; 1:19      4dup D<> if   l1    . h1 h2  HL= hi(d2) = h2
    ld    A, L          ; 1:4       4dup D<> if   l1    . h1 h2  A = lo(h2)
    sub   E             ; 1:4       4dup D<> if   l1    . h1 h2  lo(h2) - lo(l1)
    ld    A, H          ; 1:4       4dup D<> if   l1    . h1 h2  A = hi(h2)
    ex (SP), HL         ; 1:19      4dup D<> if   h2    . h1 l1
    jr   nz, $+3        ; 2:7/12    4dup D<> if   h2    . h1 l1  --> push bc
    sub   D             ; 1:4       4dup D<> if   h2    . h1 l1  hi(h2) - hi(h1)
    push BC             ; 1:11      4dup D<> if   h2 l2 . h1 l1
    jp    z, else441    ; 3:10      4dup D<> if
    ld   BC, string399  ; 3:10      print_i   Address of string447 ending with inverted most significant bit == string399
    call PRINT_STRING_I ; 3:17      print_i
else441  EQU $          ;           then  = endif
endif441:               ;           then
                        ;[8:86]     4dup   ( d c b a -- d c b a d c b a )
    pop  BC             ; 1:10      4dup
    pop  AF             ; 1:10      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
    push DE             ; 1:11      4dup
    push HL             ; 1:11      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
                       ;[14:91]     d<> if   ( d2 d1 -- )  flag: d2 <> d1
    pop  BC             ; 1:10      d<> if   lo_2
    or    A             ; 1:4       d<> if
    sbc  HL, BC         ; 2:15      d<> if   lo_2=lo_1 --> BC=HL --> 0=HL-BC --> nz if true
    pop  HL             ; 1:10      d<> if   hi_2
    jr   nz, $+4        ; 2:7/12    d<> if
    sbc  HL, DE         ; 2:15      d<> if   hi_2=hi_1 --> DE=HL --> 0=HL-DE --> nz if true
    pop  HL             ; 1:10      d<> if
    pop  DE             ; 1:10      d<> if
    jp    z, else442    ; 3:10      d<> if
    ld   BC, string402  ; 3:10      print_i   Address of string448 ending with inverted most significant bit == string402
    call PRINT_STRING_I ; 3:17      print_i
else442  EQU $          ;           then  = endif
endif442:               ;           then
                        ;[6:27]     4dup D< if   ( d2 d1 -- d2 d1 )
    call FCE_4DUP_DLT   ; 3:17      4dup D< if   carry if true
    jp   nc, else443    ; 3:10      4dup D< if
    ld   BC, string403  ; 3:10      print_i   Address of string449 ending with inverted most significant bit == string403
    call PRINT_STRING_I ; 3:17      print_i
else443  EQU $          ;           then  = endif
endif443:               ;           then
                        ;[6:27]     4dup D< if   ( d2 d1 -- d2 d1 )
    call FCE_4DUP_DLT   ; 3:17      4dup D< if   carry if true
    jp   nc, else444    ; 3:10      4dup D< if
    ld   BC, string403  ; 3:10      print_i   Address of string450 ending with inverted most significant bit == string403
    call PRINT_STRING_I ; 3:17      print_i
else444  EQU $          ;           then  = endif
endif444:               ;           then
                        ;[8:86]     4dup   ( d c b a -- d c b a d c b a )
    pop  BC             ; 1:10      4dup
    pop  AF             ; 1:10      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
    push DE             ; 1:11      4dup
    push HL             ; 1:11      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
                       ;[18:94]     d< if   ( d2 d1 -- )   # default version can be changed with "define({_TYP_DOUBLE},{fast})"
    pop  BC             ; 1:10      d< if   lo_2
    ld    A, C          ; 1:4       d< if   lo_2<lo_1 --> BC<HL --> BC-HL<0 --> carry if true
    sub   L             ; 1:4       d< if   lo_2<lo_1 --> BC<HL --> BC-HL<0 --> carry if true
    ld    A, B          ; 1:4       d< if   lo_2<lo_1 --> BC<HL --> BC-HL<0 --> carry if true
    sbc   A, H          ; 1:4       d< if   lo_2<lo_1 --> BC<HL --> BC-HL<0 --> carry if true
    pop  HL             ; 1:10      d< if   hi_2
    ld    A, L          ; 1:4       d< if   hi_2<hi_1 --> HL<DE --> HL-DE<0 --> carry if true
    sbc   A, E          ; 1:4       d< if   hi_2<hi_1 --> HL<DE --> HL-DE<0 --> carry if true
    ld    A, H          ; 1:4       d< if   hi_2<hi_1 --> HL<DE --> HL-DE<0 --> carry if true
    sbc   A, D          ; 1:4       d< if   hi_2<hi_1 --> HL<DE --> HL-DE<0 --> carry if true
    rra                 ; 1:4       d< if                                   --> sign  if true
    xor   H             ; 1:4       d< if
    xor   D             ; 1:4       d< if
    pop  HL             ; 1:10      d< if
    pop  DE             ; 1:10      d< if
    jp    p, else445    ; 3:10      d< if
    ld   BC, string406  ; 3:10      print_i   Address of string451 ending with inverted most significant bit == string406
    call PRINT_STRING_I ; 3:17      print_i
else445  EQU $          ;           then  = endif
endif445:               ;           then
                        ;[6:27]     4dup D<= if   ( d2 d1 -- d2 d1 )
    call FCE_4DUP_DGT   ; 3:17      4dup D<= if   D> carry if true --> D<= carry if false
    jp    c, else446    ; 3:10      4dup D<= if
    ld   BC, string407  ; 3:10      print_i   Address of string452 ending with inverted most significant bit == string407
    call PRINT_STRING_I ; 3:17      print_i
else446  EQU $          ;           then  = endif
endif446:               ;           then
                        ;[6:27]     4dup D<= if   ( d2 d1 -- d2 d1 )
    call FCE_4DUP_DGT   ; 3:17      4dup D<= if   D> carry if true --> D<= carry if false
    jp    c, else447    ; 3:10      4dup D<= if
    ld   BC, string407  ; 3:10      print_i   Address of string453 ending with inverted most significant bit == string407
    call PRINT_STRING_I ; 3:17      print_i
else447  EQU $          ;           then  = endif
endif447:               ;           then
                        ;[8:86]     4dup   ( d c b a -- d c b a d c b a )
    pop  BC             ; 1:10      4dup
    pop  AF             ; 1:10      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
    push DE             ; 1:11      4dup
    push HL             ; 1:11      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
                       ;[18:94]     D<= if   ( d2 d1 -- )   # default version can be changed with "define({_TYP_DOUBLE},{fast})"
    pop  BC             ; 1:10      D<= if   lo_2
    or    A             ; 1:4       D<= if
    sbc  HL, BC         ; 2:15      D<= if   lo_2<=lo_1 --> BC<=HL --> 0<=HL-BC --> no carry if true
    pop  BC             ; 1:10      D<= if   hi_2
    ld    A, E          ; 1:4       D<= if   hi_2<=hi_1 --> BC<=DE --> 0<=DE-BC --> no carry if true
    sbc   A, C          ; 1:4       D<= if   hi_2<=hi_1 --> BC<=DE --> 0<=DE-BC --> no carry if true
    ld    A, D          ; 1:4       D<= if   hi_2<=hi_1 --> BC<=DE --> 0<=DE-BC --> no carry if true
    sbc   A, B          ; 1:4       D<= if   hi_2<=hi_1 --> BC<=DE --> 0<=DE-BC --> no carry if true
    rra                 ; 1:4       D<= if                                      --> no sign  if true
    xor   B             ; 1:4       D<= if
    xor   D             ; 1:4       D<= if
    pop  HL             ; 1:10      D<= if
    pop  DE             ; 1:10      D<= if
    jp    m, else448    ; 3:10      D<= if
    ld   BC, string410  ; 3:10      print_i   Address of string454 ending with inverted most significant bit == string410
    call PRINT_STRING_I ; 3:17      print_i
else448  EQU $          ;           then  = endif
endif448:               ;           then
                        ;[6:27]     4dup D> if   ( d2 d1 -- d2 d1 )
    call FCE_4DUP_DGT   ; 3:17      4dup D> if   carry if true
    jp   nc, else449    ; 3:10      4dup D> if
    ld   BC, string411  ; 3:10      print_i   Address of string455 ending with inverted most significant bit == string411
    call PRINT_STRING_I ; 3:17      print_i
else449  EQU $          ;           then  = endif
endif449:               ;           then
                        ;[6:27]     4dup D> if   ( d2 d1 -- d2 d1 )
    call FCE_4DUP_DGT   ; 3:17      4dup D> if   carry if true
    jp   nc, else450    ; 3:10      4dup D> if
    ld   BC, string411  ; 3:10      print_i   Address of string456 ending with inverted most significant bit == string411
    call PRINT_STRING_I ; 3:17      print_i
else450  EQU $          ;           then  = endif
endif450:               ;           then
                        ;[8:86]     4dup   ( d c b a -- d c b a d c b a )
    pop  BC             ; 1:10      4dup
    pop  AF             ; 1:10      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
    push DE             ; 1:11      4dup
    push HL             ; 1:11      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
                       ;[17:97]     D> if   ( d2 d1 -- )   # default version can be changed with "define({_TYP_DOUBLE},{fast})"
    pop  BC             ; 1:10      D> if   lo_2
    or    A             ; 1:4       D> if
    sbc  HL, BC         ; 2:15      D> if   lo_2>lo_1 --> BC>HL --> 0>HL-BC --> carry if true
    pop  BC             ; 1:10      D> if   hi_2
    ld    A, E          ; 1:4       D> if   hi_2>hi_1 --> BC>DE --> 0>DE-BC --> carry if true
    sbc   A, C          ; 1:4       D> if   hi_2>hi_1 --> BC>DE --> 0>DE-BC --> carry if true
    ld    A, D          ; 1:4       D> if   hi_2>hi_1 --> BC>DE --> 0>DE-BC --> carry if true
    sbc   A, B          ; 1:4       D> if   hi_2>hi_1 --> BC>DE --> 0>DE-BC --> carry if true
    rra                 ; 1:4       D> if                                   --> sign  if true
    xor   B             ; 1:4       D> if
    xor   D             ; 1:4       D> if
    pop  HL             ; 1:10      D> if
    pop  DE             ; 1:10      D> if
    jp    p, else451    ; 3:10      D> if
    ld   BC, string414  ; 3:10      print_i   Address of string457 ending with inverted most significant bit == string414
    call PRINT_STRING_I ; 3:17      print_i
else451  EQU $          ;           then  = endif
endif451:               ;           then
                        ;[6:27]     4dup D>= if   ( d2 d1 -- d2 d1 )
    call FCE_4DUP_DLT   ; 3:17      4dup D>= if   D< carry if true --> D>= carry if false
    jp    c, else452    ; 3:10      4dup D>= if
    ld   BC, string415  ; 3:10      print_i   Address of string458 ending with inverted most significant bit == string415
    call PRINT_STRING_I ; 3:17      print_i
else452  EQU $          ;           then  = endif
endif452:               ;           then
                        ;[6:27]     4dup D>= if   ( d2 d1 -- d2 d1 )
    call FCE_4DUP_DLT   ; 3:17      4dup D>= if   D< carry if true --> D>= carry if false
    jp    c, else453    ; 3:10      4dup D>= if
    ld   BC, string415  ; 3:10      print_i   Address of string459 ending with inverted most significant bit == string415
    call PRINT_STRING_I ; 3:17      print_i
else453  EQU $          ;           then  = endif
endif453:               ;           then
                        ;[8:86]     4dup   ( d c b a -- d c b a d c b a )
    pop  BC             ; 1:10      4dup
    pop  AF             ; 1:10      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
    push DE             ; 1:11      4dup
    push HL             ; 1:11      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
                       ;[18:94]     D>= if   ( d2 d1 -- )   # default version can be changed with "define({_TYP_DOUBLE},{fast})"
    pop  BC             ; 1:10      D>= if   lo_2
    ld    A, C          ; 1:4       D>= if   lo_2>=lo_1 --> BC>=HL --> BC-HL>=0 --> no carry if true
    sub   L             ; 1:4       D>= if   lo_2>=lo_1 --> BC>=HL --> BC-HL>=0 --> no carry if true
    ld    A, B          ; 1:4       D>= if   lo_2>=lo_1 --> BC>=HL --> BC-HL>=0 --> no carry if true
    sbc   A, H          ; 1:4       D>= if   lo_2>=lo_1 --> BC>=HL --> BC-HL>=0 --> no carry if true
    pop  HL             ; 1:10      D>= if   hi_2
    ld    A, L          ; 1:4       D>= if   hi_2>=hi_1 --> HL>=DE --> HL-DE>=0 --> no carry if true
    sbc   A, E          ; 1:4       D>= if   hi_2>=hi_1 --> HL>=DE --> HL-DE>=0 --> no carry if true
    ld    A, H          ; 1:4       D>= if   hi_2>=hi_1 --> HL>=DE --> HL-DE>=0 --> no carry if true
    sbc   A, D          ; 1:4       D>= if   hi_2>=hi_1 --> HL>=DE --> HL-DE>=0 --> no carry if true
    rra                 ; 1:4       D>= if                                      --> no sign  if true
    xor   H             ; 1:4       D>= if
    xor   D             ; 1:4       D>= if
    pop  HL             ; 1:10      D>= if
    pop  DE             ; 1:10      D>= if
    jp    m, else454    ; 3:10      D>= if
    ld   BC, string418  ; 3:10      print_i   Address of string460 ending with inverted most significant bit == string418
    call PRINT_STRING_I ; 3:17      print_i
else454  EQU $          ;           then  = endif
endif454:               ;           then
                        ;[9:91]     2over   ( d c b a -- d c b a d c )
    pop  AF             ; 1:10      2over   d       . b a     AF = c
    pop  BC             ; 1:10      2over           . b a     BC = d
    push BC             ; 1:11      2over   d       . b a
    push AF             ; 1:11      2over   d c     . b a
    push DE             ; 1:11      2over   d c b   . b a
    push AF             ; 1:11      2over   d c b c . b a
    ex  (SP),HL         ; 1:19      2over   d c b a . b c
    ld    D, B          ; 1:4       2over
    ld    E, C          ; 1:4       2over   d c b a . d c
    call PRT_S32        ; 3:17      d.   ( d -- )
    push DE             ; 1:11      2dup
    push HL             ; 1:11      2dup   ( b a -- b a b a )
    call PRT_SP_S32     ; 3:17      space d.   ( d -- )
    ld    A, 0x0D       ; 2:7       cr   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      cr   putchar(reg A) with ZX 48K ROM
                   ;[16:132/73,132] 4dup D= if   ( d2 d1 -- d2 d1 )   # default version can be changed with "define({_TYP_DOUBLE},{function})"
    or   A              ; 1:4       4dup D= if   h2 l2 . h1 l1
    pop  BC             ; 1:10      4dup D= if   h2    . h1 l1  BC = l2 = lo16(d2)
    sbc  HL, BC         ; 2:15      4dup D= if   h2    . h1 --  cp l1-l2
    add  HL, BC         ; 1:11      4dup D= if   h2    . h1 l1  cp l1-l2
    jr   nz, $+7        ; 2:7/12    4dup D= if   h2    . h1 h2
    ex  (SP),HL         ; 1:19      4dup D= if   l1    . h1 h2  HL = h2 = hi16(d2)
    sbc  HL, DE         ; 2:15      4dup D= if   l1    . h1 --  cp h2-h1
    add  HL, DE         ; 1:11      4dup D= if   l1    . h1 h2  cp h2-h1
    ex  (SP),HL         ; 1:19      4dup D= if   h2    . h1 l1  HL = l1
    push BC             ; 1:11      4dup D= if   h2 l2 . h1 l1
    jp   nz, else455    ; 3:10      4dup D= if   h2 l2 . h1 l1
    ld   BC, string395  ; 3:10      print_i   Address of string461 ending with inverted most significant bit == string395
    call PRINT_STRING_I ; 3:17      print_i
else455  EQU $          ;           then  = endif
endif455:               ;           then
                   ;[16:132/73,132] 4dup D= if   ( d2 d1 -- d2 d1 )   # default version can be changed with "define({_TYP_DOUBLE},{function})"
    or   A              ; 1:4       4dup D= if   h2 l2 . h1 l1
    pop  BC             ; 1:10      4dup D= if   h2    . h1 l1  BC = l2 = lo16(d2)
    sbc  HL, BC         ; 2:15      4dup D= if   h2    . h1 --  cp l1-l2
    add  HL, BC         ; 1:11      4dup D= if   h2    . h1 l1  cp l1-l2
    jr   nz, $+7        ; 2:7/12    4dup D= if   h2    . h1 h2
    ex  (SP),HL         ; 1:19      4dup D= if   l1    . h1 h2  HL = h2 = hi16(d2)
    sbc  HL, DE         ; 2:15      4dup D= if   l1    . h1 --  cp h2-h1
    add  HL, DE         ; 1:11      4dup D= if   l1    . h1 h2  cp h2-h1
    ex  (SP),HL         ; 1:19      4dup D= if   h2    . h1 l1  HL = l1
    push BC             ; 1:11      4dup D= if   h2 l2 . h1 l1
    jp   nz, else456    ; 3:10      4dup D= if   h2 l2 . h1 l1
    ld   BC, string395  ; 3:10      print_i   Address of string462 ending with inverted most significant bit == string395
    call PRINT_STRING_I ; 3:17      print_i
else456  EQU $          ;           then  = endif
endif456:               ;           then
                        ;[8:86]     4dup   ( d c b a -- d c b a d c b a )
    pop  BC             ; 1:10      4dup
    pop  AF             ; 1:10      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
    push DE             ; 1:11      4dup
    push HL             ; 1:11      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
                       ;[14:91]     du= if   ( d2 d1 -- )  flag: d2 == d1
    pop  BC             ; 1:10      du= if   lo_2
    or    A             ; 1:4       du= if
    sbc  HL, BC         ; 2:15      du= if   lo_2=lo_1 --> BC=HL --> 0=HL-BC --> nz if false
    pop  HL             ; 1:10      du= if   hi_2
    jr   nz, $+4        ; 2:7/12    du= if
    sbc  HL, DE         ; 2:15      du= if   hi_2=hi_1 --> DE=HL --> 0=HL-DE --> nz if false
    pop  HL             ; 1:10      du= if
    pop  DE             ; 1:10      du= if
    jp   nz, else457    ; 3:10      du= if
    ld   BC, string398  ; 3:10      print_i   Address of string463 ending with inverted most significant bit == string398
    call PRINT_STRING_I ; 3:17      print_i
else457  EQU $          ;           then  = endif
endif457:               ;           then
            ;[21:51,66,123,122/122] 4dup D<> if  ( d2 d1 -- d2 d1 )   # "define({_TYP_DOUBLE},{default})" version can be changed with function,small,fast,default
    pop  BC             ; 1:10      4dup D<> if   h2    . h1 l1  BC= lo(d2) = l2
    ld    A, C          ; 1:4       4dup D<> if   h2    . h1 l1  A = lo(l2)
    sub   L             ; 1:4       4dup D<> if   h2    . h1 l1  lo(l2) - lo(l1)
    jr   nz, $+14       ; 2:7/12    4dup D<> if   h2    . h1 l1  --> push bc
    ld    A, B          ; 1:4       4dup D<> if   h2    . h1 l1  A = hi(l2)
    sub   H             ; 1:4       4dup D<> if   h2    . h1 l1  hi(l2) - hi(l1)
    jr   nz, $+10       ; 2:7/12    4dup D<> if   h2    . h1 l1  --> push bc
    ex (SP), HL         ; 1:19      4dup D<> if   l1    . h1 h2  HL= hi(d2) = h2
    ld    A, L          ; 1:4       4dup D<> if   l1    . h1 h2  A = lo(h2)
    sub   E             ; 1:4       4dup D<> if   l1    . h1 h2  lo(h2) - lo(l1)
    ld    A, H          ; 1:4       4dup D<> if   l1    . h1 h2  A = hi(h2)
    ex (SP), HL         ; 1:19      4dup D<> if   h2    . h1 l1
    jr   nz, $+3        ; 2:7/12    4dup D<> if   h2    . h1 l1  --> push bc
    sub   D             ; 1:4       4dup D<> if   h2    . h1 l1  hi(h2) - hi(h1)
    push BC             ; 1:11      4dup D<> if   h2 l2 . h1 l1
    jp    z, else458    ; 3:10      4dup D<> if
    ld   BC, string399  ; 3:10      print_i   Address of string464 ending with inverted most significant bit == string399
    call PRINT_STRING_I ; 3:17      print_i
else458  EQU $          ;           then  = endif
endif458:               ;           then
            ;[21:51,66,123,122/122] 4dup D<> if  ( d2 d1 -- d2 d1 )   # "define({_TYP_DOUBLE},{default})" version can be changed with function,small,fast,default
    pop  BC             ; 1:10      4dup D<> if   h2    . h1 l1  BC= lo(d2) = l2
    ld    A, C          ; 1:4       4dup D<> if   h2    . h1 l1  A = lo(l2)
    sub   L             ; 1:4       4dup D<> if   h2    . h1 l1  lo(l2) - lo(l1)
    jr   nz, $+14       ; 2:7/12    4dup D<> if   h2    . h1 l1  --> push bc
    ld    A, B          ; 1:4       4dup D<> if   h2    . h1 l1  A = hi(l2)
    sub   H             ; 1:4       4dup D<> if   h2    . h1 l1  hi(l2) - hi(l1)
    jr   nz, $+10       ; 2:7/12    4dup D<> if   h2    . h1 l1  --> push bc
    ex (SP), HL         ; 1:19      4dup D<> if   l1    . h1 h2  HL= hi(d2) = h2
    ld    A, L          ; 1:4       4dup D<> if   l1    . h1 h2  A = lo(h2)
    sub   E             ; 1:4       4dup D<> if   l1    . h1 h2  lo(h2) - lo(l1)
    ld    A, H          ; 1:4       4dup D<> if   l1    . h1 h2  A = hi(h2)
    ex (SP), HL         ; 1:19      4dup D<> if   h2    . h1 l1
    jr   nz, $+3        ; 2:7/12    4dup D<> if   h2    . h1 l1  --> push bc
    sub   D             ; 1:4       4dup D<> if   h2    . h1 l1  hi(h2) - hi(h1)
    push BC             ; 1:11      4dup D<> if   h2 l2 . h1 l1
    jp    z, else459    ; 3:10      4dup D<> if
    ld   BC, string399  ; 3:10      print_i   Address of string465 ending with inverted most significant bit == string399
    call PRINT_STRING_I ; 3:17      print_i
else459  EQU $          ;           then  = endif
endif459:               ;           then
                        ;[8:86]     4dup   ( d c b a -- d c b a d c b a )
    pop  BC             ; 1:10      4dup
    pop  AF             ; 1:10      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
    push DE             ; 1:11      4dup
    push HL             ; 1:11      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
                       ;[14:91]     du<> if   ( d2 d1 -- )  flag: d2 <> d1
    pop  BC             ; 1:10      du<> if   lo_2
    or    A             ; 1:4       du<> if
    sbc  HL, BC         ; 2:15      du<> if   lo_2=lo_1 --> BC=HL --> 0=HL-BC --> nz if true
    pop  HL             ; 1:10      du<> if   hi_2
    jr   nz, $+4        ; 2:7/12    du<> if
    sbc  HL, DE         ; 2:15      du<> if   hi_2=hi_1 --> DE=HL --> 0=HL-DE --> nz if true
    pop  HL             ; 1:10      du<> if
    pop  DE             ; 1:10      du<> if
    jp    z, else460    ; 3:10      du<> if
    ld   BC, string402  ; 3:10      print_i   Address of string466 ending with inverted most significant bit == string402
    call PRINT_STRING_I ; 3:17      print_i
else460  EQU $          ;           then  = endif
endif460:               ;           then
                       ;[15:101]    4dup Du< if   ( ud2 ud1 -- ud2 ud1 )   # default version can be changed with "define({_TYP_DOUBLE},{function})"
    pop  BC             ; 1:10      4dup Du< if   ud2 < ud1 --> ud2-ud1<0 --> (SP)BC-DEHL<0 --> carry if true
    ld    A, C          ; 1:4       4dup Du< if
    sub   L             ; 1:4       4dup Du< if   C-L<0 --> carry if true
    ld    A, B          ; 1:4       4dup Du< if
    sbc   A, H          ; 1:4       4dup Du< if   B-H<0 --> carry if true
    ex  (SP),HL         ; 1:19      4dup Du< if   HL = hi2
    ld    A, L          ; 1:4       4dup Du< if   HLBC-DE(SP)<0 -- carry if true
    sbc   A, E          ; 1:4       4dup Du< if   L-E<0 --> carry if true
    ld    A, H          ; 1:4       4dup Du< if
    sbc   A, D          ; 1:4       4dup Du< if   H-D<0 --> carry if true
    ex  (SP),HL         ; 1:19      4dup Du< if
    push BC             ; 1:11      4dup Du< if
    jp   nc, else461    ; 3:10      4dup Du< if
    ld   BC, string403  ; 3:10      print_i   Address of string467 ending with inverted most significant bit == string403
    call PRINT_STRING_I ; 3:17      print_i
else461  EQU $          ;           then  = endif
endif461:               ;           then
                       ;[15:101]    4dup Du< if   ( ud2 ud1 -- ud2 ud1 )   # default version can be changed with "define({_TYP_DOUBLE},{function})"
    pop  BC             ; 1:10      4dup Du< if   ud2 < ud1 --> ud2-ud1<0 --> (SP)BC-DEHL<0 --> carry if true
    ld    A, C          ; 1:4       4dup Du< if
    sub   L             ; 1:4       4dup Du< if   C-L<0 --> carry if true
    ld    A, B          ; 1:4       4dup Du< if
    sbc   A, H          ; 1:4       4dup Du< if   B-H<0 --> carry if true
    ex  (SP),HL         ; 1:19      4dup Du< if   HL = hi2
    ld    A, L          ; 1:4       4dup Du< if   HLBC-DE(SP)<0 -- carry if true
    sbc   A, E          ; 1:4       4dup Du< if   L-E<0 --> carry if true
    ld    A, H          ; 1:4       4dup Du< if
    sbc   A, D          ; 1:4       4dup Du< if   H-D<0 --> carry if true
    ex  (SP),HL         ; 1:19      4dup Du< if
    push BC             ; 1:11      4dup Du< if
    jp   nc, else462    ; 3:10      4dup Du< if
    ld   BC, string403  ; 3:10      print_i   Address of string468 ending with inverted most significant bit == string403
    call PRINT_STRING_I ; 3:17      print_i
else462  EQU $          ;           then  = endif
endif462:               ;           then
                        ;[8:86]     4dup   ( d c b a -- d c b a d c b a )
    pop  BC             ; 1:10      4dup
    pop  AF             ; 1:10      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
    push DE             ; 1:11      4dup
    push HL             ; 1:11      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
                       ;[13:81]     Du< if   ( ud2 ud1 -- )
    pop  BC             ; 1:10      Du< if   lo_2
    ld    A, C          ; 1:4       Du< if   lo_2<lo_1 --> BC<HL --> BC-HL<0 --> carry if true
    sub   L             ; 1:4       Du< if   lo_2<lo_1 --> BC<HL --> BC-HL<0 --> carry if true
    ld    A, B          ; 1:4       Du< if   lo_2<lo_1 --> BC<HL --> BC-HL<0 --> carry if true
    sbc   A, H          ; 1:4       Du< if   lo_2<lo_1 --> BC<HL --> BC-HL<0 --> carry if true
    pop  HL             ; 1:10      Du< if   hi_2
    sbc  HL, DE         ; 2:15      Du< if   hi_2<hi_1 --> HL<DE --> HL-DE<0 --> carry if true
    pop  HL             ; 1:10      Du< if
    pop  DE             ; 1:10      Du< if
    jp   nc, else463    ; 3:10      Du< if
    ld   BC, string406  ; 3:10      print_i   Address of string469 ending with inverted most significant bit == string406
    call PRINT_STRING_I ; 3:17      print_i
else463  EQU $          ;           then  = endif
endif463:               ;           then
                       ;[15:101]    4dup Du<= if   ( ud2 ud1 -- ud2 ud1 )   # default version can be changed with "define({_TYP_DOUBLE},{function})"
    pop  BC             ; 1:10      4dup Du<= if   ud2 <= ud1 --> 0<=ud1-ud2 --> 0<=DEHL-(SP)BC --> no carry if true
    ld    A, L          ; 1:4       4dup Du<= if
    sub   C             ; 1:4       4dup Du<= if   0<=L-C --> no carry if true
    ld    A, H          ; 1:4       4dup Du<= if
    sbc   A, B          ; 1:4       4dup Du<= if   0<=H-B --> no carry if true
    ex  (SP),HL         ; 1:19      4dup Du<= if   HL = hi2
    ld    A, E          ; 1:4       4dup Du<= if   0<=DE(SP)-HLBC -- no carry if true
    sbc   A, L          ; 1:4       4dup Du<= if   0<=E-L --> no carry if true
    ld    A, D          ; 1:4       4dup Du<= if
    sbc   A, H          ; 1:4       4dup Du<= if   0<=D-H --> no carry if true
    ex  (SP),HL         ; 1:19      4dup Du<= if
    push BC             ; 1:11      4dup Du<= if
    jp    c, else464    ; 3:10      4dup Du<= if
    ld   BC, string407  ; 3:10      print_i   Address of string470 ending with inverted most significant bit == string407
    call PRINT_STRING_I ; 3:17      print_i
else464  EQU $          ;           then  = endif
endif464:               ;           then
                       ;[15:101]    4dup Du<= if   ( ud2 ud1 -- ud2 ud1 )   # default version can be changed with "define({_TYP_DOUBLE},{function})"
    pop  BC             ; 1:10      4dup Du<= if   ud2 <= ud1 --> 0<=ud1-ud2 --> 0<=DEHL-(SP)BC --> no carry if true
    ld    A, L          ; 1:4       4dup Du<= if
    sub   C             ; 1:4       4dup Du<= if   0<=L-C --> no carry if true
    ld    A, H          ; 1:4       4dup Du<= if
    sbc   A, B          ; 1:4       4dup Du<= if   0<=H-B --> no carry if true
    ex  (SP),HL         ; 1:19      4dup Du<= if   HL = hi2
    ld    A, E          ; 1:4       4dup Du<= if   0<=DE(SP)-HLBC -- no carry if true
    sbc   A, L          ; 1:4       4dup Du<= if   0<=E-L --> no carry if true
    ld    A, D          ; 1:4       4dup Du<= if
    sbc   A, H          ; 1:4       4dup Du<= if   0<=D-H --> no carry if true
    ex  (SP),HL         ; 1:19      4dup Du<= if
    push BC             ; 1:11      4dup Du<= if
    jp    c, else465    ; 3:10      4dup Du<= if
    ld   BC, string407  ; 3:10      print_i   Address of string471 ending with inverted most significant bit == string407
    call PRINT_STRING_I ; 3:17      print_i
else465  EQU $          ;           then  = endif
endif465:               ;           then
                        ;[8:86]     4dup   ( d c b a -- d c b a d c b a )
    pop  BC             ; 1:10      4dup
    pop  AF             ; 1:10      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
    push DE             ; 1:11      4dup
    push HL             ; 1:11      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
                       ;[13:88]     Du<= if   ( ud2 ud1 -- )   # default version can be changed with "define({_TYP_DOUBLE},{fast})"
    pop  BC             ; 1:10      Du<= if   lo_2
    or    A             ; 1:4       Du<= if
    sbc  HL, BC         ; 2:15      Du<= if   lo_2<=lo_1 --> BC<=HL --> 0<=HL-BC --> no carry if true
    pop  BC             ; 1:10      Du<= if   hi_2
    ex   DE, HL         ; 1:4       Du<= if
    sbc  HL, BC         ; 2:15      Du<= if   hi_2<=hi_1 --> BC<=HL --> 0<=HL-BC --> no carry if true
    pop  HL             ; 1:10      Du<= if
    pop  DE             ; 1:10      Du<= if
    jp    c, else466    ; 3:10      Du<= if
    ld   BC, string410  ; 3:10      print_i   Address of string472 ending with inverted most significant bit == string410
    call PRINT_STRING_I ; 3:17      print_i
else466  EQU $          ;           then  = endif
endif466:               ;           then
                       ;[15:101]    4dup Du> if   ( ud2 ud1 -- ud2 ud1 )   # default version can be changed with "define({_TYP_DOUBLE},{function})"
    pop  BC             ; 1:10      4dup Du> if   ud2 > ud1 --> 0>ud1-ud2 --> 0>DEHL-(SP)BC --> carry if true
    ld    A, L          ; 1:4       4dup Du> if
    sub   C             ; 1:4       4dup Du> if   0>L-C --> carry if true
    ld    A, H          ; 1:4       4dup Du> if
    sbc   A, B          ; 1:4       4dup Du> if   0>H-B --> carry if true
    ex  (SP),HL         ; 1:19      4dup Du> if   HL = hi2
    ld    A, E          ; 1:4       4dup Du> if   0>DE(SP)-HLBC -- carry if true
    sbc   A, L          ; 1:4       4dup Du> if   0>E-L --> carry if true
    ld    A, D          ; 1:4       4dup Du> if
    sbc   A, H          ; 1:4       4dup Du> if   0>D-H --> carry if true
    ex  (SP),HL         ; 1:19      4dup Du> if
    push BC             ; 1:11      4dup Du> if
    jp   nc, else467    ; 3:10      4dup Du> if
    ld   BC, string411  ; 3:10      print_i   Address of string473 ending with inverted most significant bit == string411
    call PRINT_STRING_I ; 3:17      print_i
else467  EQU $          ;           then  = endif
endif467:               ;           then
                       ;[15:101]    4dup Du> if   ( ud2 ud1 -- ud2 ud1 )   # default version can be changed with "define({_TYP_DOUBLE},{function})"
    pop  BC             ; 1:10      4dup Du> if   ud2 > ud1 --> 0>ud1-ud2 --> 0>DEHL-(SP)BC --> carry if true
    ld    A, L          ; 1:4       4dup Du> if
    sub   C             ; 1:4       4dup Du> if   0>L-C --> carry if true
    ld    A, H          ; 1:4       4dup Du> if
    sbc   A, B          ; 1:4       4dup Du> if   0>H-B --> carry if true
    ex  (SP),HL         ; 1:19      4dup Du> if   HL = hi2
    ld    A, E          ; 1:4       4dup Du> if   0>DE(SP)-HLBC -- carry if true
    sbc   A, L          ; 1:4       4dup Du> if   0>E-L --> carry if true
    ld    A, D          ; 1:4       4dup Du> if
    sbc   A, H          ; 1:4       4dup Du> if   0>D-H --> carry if true
    ex  (SP),HL         ; 1:19      4dup Du> if
    push BC             ; 1:11      4dup Du> if
    jp   nc, else468    ; 3:10      4dup Du> if
    ld   BC, string411  ; 3:10      print_i   Address of string474 ending with inverted most significant bit == string411
    call PRINT_STRING_I ; 3:17      print_i
else468  EQU $          ;           then  = endif
endif468:               ;           then
                        ;[8:86]     4dup   ( d c b a -- d c b a d c b a )
    pop  BC             ; 1:10      4dup
    pop  AF             ; 1:10      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
    push DE             ; 1:11      4dup
    push HL             ; 1:11      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
                       ;[13:88]     Du> if   ( ud2 ud1 -- )   # default version can be changed with "define({_TYP_DOUBLE},{fast})"
    pop  BC             ; 1:10      Du> if   lo_2
    or    A             ; 1:4       Du> if
    sbc  HL, BC         ; 2:15      Du> if   lo_2>lo_1 --> BC>HL --> 0>HL-BC --> carry if true
    pop  BC             ; 1:10      Du> if   hi_2
    ex   DE, HL         ; 1:4       Du> if
    sbc  HL, BC         ; 2:15      Du> if   hi_2>hi_1 --> BC>HL --> 0>HL-BC --> carry if true
    pop  HL             ; 1:10      Du> if
    pop  DE             ; 1:10      Du> if
    jp   nc, else469    ; 3:10      Du> if
    ld   BC, string414  ; 3:10      print_i   Address of string475 ending with inverted most significant bit == string414
    call PRINT_STRING_I ; 3:17      print_i
else469  EQU $          ;           then  = endif
endif469:               ;           then
                       ;[15:101]    4dup Du>= if   ( ud2 ud1 -- ud2 ud1 )   # default version can be changed with "define({_TYP_DOUBLE},{function})"
    pop  BC             ; 1:10      4dup Du>= if   ud2 >= ud1 --> ud2-ud1>=0 --> (SP)BC-DEHL>=0 --> no carry if true
    ld    A, C          ; 1:4       4dup Du>= if
    sub   L             ; 1:4       4dup Du>= if   C-L>=0 --> no carry if true
    ld    A, B          ; 1:4       4dup Du>= if
    sbc   A, H          ; 1:4       4dup Du>= if   B-H>=0 --> no carry if true
    ex  (SP),HL         ; 1:19      4dup Du>= if   HL = hi2
    ld    A, L          ; 1:4       4dup Du>= if   HLBC-DE(SP)>=0 -- no carry if true
    sbc   A, E          ; 1:4       4dup Du>= if   L-E>=0 --> no carry if true
    ld    A, H          ; 1:4       4dup Du>= if
    sbc   A, D          ; 1:4       4dup Du>= if   H-D>=0 --> no carry if true
    ex  (SP),HL         ; 1:19      4dup Du>= if
    push BC             ; 1:11      4dup Du>= if
    jp    c, else470    ; 3:10      4dup Du>= if
    ld   BC, string415  ; 3:10      print_i   Address of string476 ending with inverted most significant bit == string415
    call PRINT_STRING_I ; 3:17      print_i
else470  EQU $          ;           then  = endif
endif470:               ;           then
                       ;[15:101]    4dup Du>= if   ( ud2 ud1 -- ud2 ud1 )   # default version can be changed with "define({_TYP_DOUBLE},{function})"
    pop  BC             ; 1:10      4dup Du>= if   ud2 >= ud1 --> ud2-ud1>=0 --> (SP)BC-DEHL>=0 --> no carry if true
    ld    A, C          ; 1:4       4dup Du>= if
    sub   L             ; 1:4       4dup Du>= if   C-L>=0 --> no carry if true
    ld    A, B          ; 1:4       4dup Du>= if
    sbc   A, H          ; 1:4       4dup Du>= if   B-H>=0 --> no carry if true
    ex  (SP),HL         ; 1:19      4dup Du>= if   HL = hi2
    ld    A, L          ; 1:4       4dup Du>= if   HLBC-DE(SP)>=0 -- no carry if true
    sbc   A, E          ; 1:4       4dup Du>= if   L-E>=0 --> no carry if true
    ld    A, H          ; 1:4       4dup Du>= if
    sbc   A, D          ; 1:4       4dup Du>= if   H-D>=0 --> no carry if true
    ex  (SP),HL         ; 1:19      4dup Du>= if
    push BC             ; 1:11      4dup Du>= if
    jp    c, else471    ; 3:10      4dup Du>= if
    ld   BC, string415  ; 3:10      print_i   Address of string477 ending with inverted most significant bit == string415
    call PRINT_STRING_I ; 3:17      print_i
else471  EQU $          ;           then  = endif
endif471:               ;           then
                        ;[8:86]     4dup   ( d c b a -- d c b a d c b a )
    pop  BC             ; 1:10      4dup
    pop  AF             ; 1:10      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
    push DE             ; 1:11      4dup
    push HL             ; 1:11      4dup
    push AF             ; 1:11      4dup
    push BC             ; 1:11      4dup
                       ;[13:81]     Du>= if   ( ud2 ud1 -- )
    pop  BC             ; 1:10      Du>= if   lo_2
    ld    A, C          ; 1:4       Du>= if   lo_2>=lo_1 --> BC>=HL --> BC-HL>=0 --> no carry if true
    sub   L             ; 1:4       Du>= if   lo_2>=lo_1 --> BC>=HL --> BC-HL>=0 --> no carry if true
    ld    A, B          ; 1:4       Du>= if   lo_2>=lo_1 --> BC>=HL --> BC-HL>=0 --> no carry if true
    sbc   A, H          ; 1:4       Du>= if   lo_2>=lo_1 --> BC>=HL --> BC-HL>=0 --> no carry if true
    pop  HL             ; 1:10      Du>= if   hi_2
    sbc  HL, DE         ; 2:15      Du>= if   hi_2>=hi_1 --> HL>=DE --> HL-DE>=0 --> no carry if true
    pop  HL             ; 1:10      Du>= if
    pop  DE             ; 1:10      Du>= if
    jp    c, else472    ; 3:10      Du>= if
    ld   BC, string418  ; 3:10      print_i   Address of string478 ending with inverted most significant bit == string418
    call PRINT_STRING_I ; 3:17      print_i
else472  EQU $          ;           then  = endif
endif472:               ;           then
                        ;[6:67]     2swap   ( d c b a -- b a d c ) # default version can be changed with "define({TYP_2SWAP},{name})", name=fast
    ex  (SP),HL         ; 1:19      2swap   d a . b c
    ex   DE, HL         ; 1:4       2swap   d a . c b
    pop  AF             ; 1:10      2swap   d   . c b     AF = a
    ex  (SP),HL         ; 1:19      2swap   b   . c d
    ex   DE, HL         ; 1:4       2swap   b   . d c
    push AF             ; 1:11      2swap   b a . d c
    call PRT_U32        ; 3:17      ud.   ( ud -- )
    call PRT_SP_U32     ; 3:17      space ud.   ( ud -- )
    ld    A, 0x0D       ; 2:7       cr   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      cr   putchar(reg A) with ZX 48K ROM
d_d_test_end:
    jp   0x0000         ; 3:10      ;
;   ---------  end of non-recursive function  ---------
;   ---  the beginning of a non-recursive function  ---
x_p3_test:              ;           
    pop  BC             ; 1:10      : ret
    ld  (x_p3_test_end+1),BC; 4:20      : ( ret -- )
                        ;[7:25]     dup 3 = if   ( x1 -- x1 )   3 == HL
    ld    A, 0x03       ; 2:7       dup 3 = if
    xor   L             ; 1:4       dup 3 = if   x[1] = 0x03
    or    H             ; 1:4       dup 3 = if   x[2] = 0
    jp   nz, else473    ; 3:10      dup 3 = if
    ld   BC, string398  ; 3:10      print_i   Address of string479 ending with inverted most significant bit == string398
    call PRINT_STRING_I ; 3:17      print_i
else473  EQU $          ;           then  = endif
endif473:               ;           then
                        ;[7:25]     dup 3 <> if   ( x1 -- x1 )   3 <> HL
    ld    A, 0x03       ; 2:7       dup 3 <> if
    xor   L             ; 1:4       dup 3 <> if   x[1] = 0x03
    or    H             ; 1:4       dup 3 <> if   x[2] = 0
    jp    z, else474    ; 3:10      dup 3 <> if
    ld   BC, string402  ; 3:10      print_i   Address of string480 ending with inverted most significant bit == string402
    call PRINT_STRING_I ; 3:17      print_i
else474  EQU $          ;           then  = endif
endif474:               ;           then
                       ;[11:40]     dup 3 < if   ( x -- x )  flag: x < 3 #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4       dup 3 < if   HL<3 --> L-0x03<0 --> false if not carry
    sub  0x03           ; 2:7       dup 3 < if   HL<3 --> L-0x03<0 --> false if not carry
    ld    A, H          ; 1:4       dup 3 < if   HL<3 --> H-0x00<0 --> false if not carry
    sbc   A, 0x00       ; 2:7       dup 3 < if   HL<3 --> H-0x00<0 --> false if not carry
    rra                 ; 1:4       dup 3 < if
    xor   H             ; 1:4       dup 3 < if   invert sign if HL is negative
    jp    p, else475    ; 3:10      dup 3 < if   positive constant --> false if not sign
    ld   BC, string406  ; 3:10      print_i   Address of string481 ending with inverted most significant bit == string406
    call PRINT_STRING_I ; 3:17      print_i
else475  EQU $          ;           then  = endif
endif475:               ;           then
                       ;[11:40]     dup 3 <= if   ( x -- x )  flag: x <= 3 #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0x03       ; 2:7       dup 3 <= if   HL<=3 --> 0<=0x03-L --> false if carry
    sub   L             ; 1:4       dup 3 <= if   HL<=3 --> 0<=0x03-L --> false if carry
    ld    A, 0x00       ; 2:7       dup 3 <= if   HL<=3 --> 0<=0x00-H --> false if carry
    sbc   A, H          ; 1:4       dup 3 <= if   HL<=3 --> 0<=0x00-H --> false if carry
    rra                 ; 1:4       dup 3 <= if
    xor   H             ; 1:4       dup 3 <= if   invert sign if HL is negative
    jp    m, else476    ; 3:10      dup 3 <= if   positive constant --> false if sign
    ld   BC, string410  ; 3:10      print_i   Address of string482 ending with inverted most significant bit == string410
    call PRINT_STRING_I ; 3:17      print_i
else476  EQU $          ;           then  = endif
endif476:               ;           then
                       ;[11:40]     dup 3 > if   ( x -- x )  flag: x > 3 #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0x03       ; 2:7       dup 3 > if   HL>3 --> 0>0x03-L --> false if not carry
    sub   L             ; 1:4       dup 3 > if   HL>3 --> 0>0x03-L --> false if not carry
    ld    A, 0x00       ; 2:7       dup 3 > if   HL>3 --> 0>0x00-H --> false if not carry
    sbc   A, H          ; 1:4       dup 3 > if   HL>3 --> 0>0x00-H --> false if not carry
    rra                 ; 1:4       dup 3 > if
    xor   H             ; 1:4       dup 3 > if   invert sign if HL is negative
    jp    p, else477    ; 3:10      dup 3 > if   positive constant --> false if not sign
    ld   BC, string414  ; 3:10      print_i   Address of string483 ending with inverted most significant bit == string414
    call PRINT_STRING_I ; 3:17      print_i
else477  EQU $          ;           then  = endif
endif477:               ;           then
                       ;[11:40]     dup 3 >= if   ( x -- x )  flag: x >= 3 #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4       dup 3 >= if   HL>=3 --> L-0x03>=0 --> false if carry
    sub  0x03           ; 2:7       dup 3 >= if   HL>=3 --> L-0x03>=0 --> false if carry
    ld    A, H          ; 1:4       dup 3 >= if   HL>=3 --> H-0x00>=0 --> false if carry
    sbc   A, 0x00       ; 2:7       dup 3 >= if   HL>=3 --> H-0x00>=0 --> false if carry
    rra                 ; 1:4       dup 3 >= if
    xor   H             ; 1:4       dup 3 >= if   invert sign if HL is negative
    jp    m, else478    ; 3:10      dup 3 >= if   positive constant --> false if sign
    ld   BC, string418  ; 3:10      print_i   Address of string484 ending with inverted most significant bit == string418
    call PRINT_STRING_I ; 3:17      print_i
else478  EQU $          ;           then  = endif
endif478:               ;           then
    push HL             ; 1:11      dup .   x3 x1 x2 x1
    call PRT_S16        ; 3:17      .   ( s -- )
    ex   DE, HL         ; 1:4       dup .   x3 x2 x1
    push DE             ; 1:11      3
    ex   DE, HL         ; 1:4       3
    ld   HL, 3          ; 3:10      3
    call PRT_SP_S16     ; 3:17      space .   ( s -- )
    ld    A, 0x0D       ; 2:7       cr   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      cr   putchar(reg A) with ZX 48K ROM
                        ;[7:25]     dup 3 u= if   ( x1 -- x1 )   3 == HL
    ld    A, 0x03       ; 2:7       dup 3 u= if
    xor   L             ; 1:4       dup 3 u= if   x[1] = 0x03
    or    H             ; 1:4       dup 3 u= if   x[2] = 0
    jp   nz, else479    ; 3:10      dup 3 u= if
    ld   BC, string398  ; 3:10      print_i   Address of string485 ending with inverted most significant bit == string398
    call PRINT_STRING_I ; 3:17      print_i
else479  EQU $          ;           then  = endif
endif479:               ;           then
                        ;[7:25]     dup 3 u<> if   ( x1 -- x1 )   3 <> HL
    ld    A, 0x03       ; 2:7       dup 3 u<> if
    xor   L             ; 1:4       dup 3 u<> if   x[1] = 0x03
    or    H             ; 1:4       dup 3 u<> if   x[2] = 0
    jp    z, else480    ; 3:10      dup 3 u<> if
    ld   BC, string402  ; 3:10      print_i   Address of string486 ending with inverted most significant bit == string402
    call PRINT_STRING_I ; 3:17      print_i
else480  EQU $          ;           then  = endif
endif480:               ;           then
                        ;[9:32]     dup 3 u< if   ( u -- u ) flag: u<3 #variant: default
    ld    A, L          ; 1:4       dup 3 u< if   HL<3 --> L-0x03<0 --> false if not carry
    sub  0x03           ; 2:7       dup 3 u< if   HL<3 --> L-0x03<0 --> false if not carry
    ld    A, H          ; 1:4       dup 3 u< if   HL<3 --> H-0x00<0 --> false if not carry
    sbc   A, 0x00       ; 2:7       dup 3 u< if   HL<3 --> H-0x00<0 --> false if not carry
    jp   nc, else481    ; 3:10      dup 3 u< if   false if not carry
    ld   BC, string406  ; 3:10      print_i   Address of string487 ending with inverted most significant bit == string406
    call PRINT_STRING_I ; 3:17      print_i
else481  EQU $          ;           then  = endif
endif481:               ;           then
                        ;[9:32]     dup 3 u<= if   ( u -- u ) flag: u<=3 #variant: default
    ld    A, 0x03       ; 2:7       dup 3 u<= if   HL<=3 --> 0<=0x03-L --> false if carry
    sub   L             ; 1:4       dup 3 u<= if   HL<=3 --> 0<=0x03-L --> false if carry
    ld    A, 0x00       ; 2:7       dup 3 u<= if   HL<=3 --> 0<=0x00-H --> false if carry
    sbc   A, H          ; 1:4       dup 3 u<= if   HL<=3 --> 0<=0x00-H --> false if carry
    jp    c, else482    ; 3:10      dup 3 u<= if   false if carry
    ld   BC, string410  ; 3:10      print_i   Address of string488 ending with inverted most significant bit == string410
    call PRINT_STRING_I ; 3:17      print_i
else482  EQU $          ;           then  = endif
endif482:               ;           then
                        ;[9:32]     dup 3 u> if   ( u -- u ) flag: u>3 #variant: default
    ld    A, 0x03       ; 2:7       dup 3 u> if   HL>3 --> 0>0x03-L --> false if not carry
    sub   L             ; 1:4       dup 3 u> if   HL>3 --> 0>0x03-L --> false if not carry
    ld    A, 0x00       ; 2:7       dup 3 u> if   HL>3 --> 0>0x00-H --> false if not carry
    sbc   A, H          ; 1:4       dup 3 u> if   HL>3 --> 0>0x00-H --> false if not carry
    jp   nc, else483    ; 3:10      dup 3 u> if   false if not carry
    ld   BC, string414  ; 3:10      print_i   Address of string489 ending with inverted most significant bit == string414
    call PRINT_STRING_I ; 3:17      print_i
else483  EQU $          ;           then  = endif
endif483:               ;           then
                        ;[9:32]     dup 3 u>= if   ( u -- u ) flag: u>=3 #variant: default
    ld    A, L          ; 1:4       dup 3 u>= if   HL>=3 --> L-0x03>=0 --> false if carry
    sub  0x03           ; 2:7       dup 3 u>= if   HL>=3 --> L-0x03>=0 --> false if carry
    ld    A, H          ; 1:4       dup 3 u>= if   HL>=3 --> H-0x00>=0 --> false if carry
    sbc   A, 0x00       ; 2:7       dup 3 u>= if   HL>=3 --> H-0x00>=0 --> false if carry
    jp    c, else484    ; 3:10      dup 3 u>= if   false if carry
    ld   BC, string418  ; 3:10      print_i   Address of string490 ending with inverted most significant bit == string418
    call PRINT_STRING_I ; 3:17      print_i
else484  EQU $          ;           then  = endif
endif484:               ;           then
    call PRT_U16        ; 3:17      u.   ( u -- )
    push DE             ; 1:11      3
    ex   DE, HL         ; 1:4       3
    ld   HL, 3          ; 3:10      3
    call PRT_SP_U16     ; 3:17      space u.   ( u -- )
    ld    A, 0x0D       ; 2:7       cr   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      cr   putchar(reg A) with ZX 48K ROM
x_p3_test_end:
    jp   0x0000         ; 3:10      ;
;   ---------  end of non-recursive function  ---------
;   ---  the beginning of a non-recursive function  ---
x_m3_test:              ;           
    pop  BC             ; 1:10      : ret
    ld  (x_m3_test_end+1),BC; 4:20      : ( ret -- )
                        ;[8:29]     dup -3 = if   ( x1 -- x1 )   -3 == HL
    ld    A, L          ; 1:4       dup -3 = if
    xor   0x02          ; 2:7       dup -3 = if   x[1] = 0xFF ^ 0x02
    and   H             ; 1:4       dup -3 = if
    inc   A             ; 1:4       dup -3 = if   x[2] = 0xFF
    jp   nz, else485    ; 3:10      dup -3 = if
    ld   BC, string398  ; 3:10      print_i   Address of string491 ending with inverted most significant bit == string398
    call PRINT_STRING_I ; 3:17      print_i
else485  EQU $          ;           then  = endif
endif485:               ;           then
                        ;[8:29]     dup -3 <> if   ( x1 -- x1 )   -3 <> HL
    ld    A, L          ; 1:4       dup -3 <> if
    xor   0x02          ; 2:7       dup -3 <> if   x[1] = 0xFF ^ 0x02
    and   H             ; 1:4       dup -3 <> if
    inc   A             ; 1:4       dup -3 <> if   x[2] = 0xFF
    jp    z, else486    ; 3:10      dup -3 <> if
    ld   BC, string402  ; 3:10      print_i   Address of string492 ending with inverted most significant bit == string402
    call PRINT_STRING_I ; 3:17      print_i
else486  EQU $          ;           then  = endif
endif486:               ;           then
                       ;[11:40]     dup -3 < if   ( x -- x )  flag: x < -3 #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4       dup -3 < if   HL<-3 --> L-0xFD<0 --> false if not carry
    sub  0xFD           ; 2:7       dup -3 < if   HL<-3 --> L-0xFD<0 --> false if not carry
    ld    A, H          ; 1:4       dup -3 < if   HL<-3 --> H-0xFF<0 --> false if not carry
    sbc   A, 0xFF       ; 2:7       dup -3 < if   HL<-3 --> H-0xFF<0 --> false if not carry
    rra                 ; 1:4       dup -3 < if
    xor   H             ; 1:4       dup -3 < if   invert sign if HL is negative
    jp    m, else487    ; 3:10      dup -3 < if   negative constant --> false if sign
    ld   BC, string406  ; 3:10      print_i   Address of string493 ending with inverted most significant bit == string406
    call PRINT_STRING_I ; 3:17      print_i
else487  EQU $          ;           then  = endif
endif487:               ;           then
                       ;[11:40]     dup -3 <= if   ( x -- x )  flag: x <= -3 #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0xFD       ; 2:7       dup -3 <= if   HL<=-3 --> 0<=0xFD-L --> false if carry
    sub   L             ; 1:4       dup -3 <= if   HL<=-3 --> 0<=0xFD-L --> false if carry
    ld    A, 0xFF       ; 2:7       dup -3 <= if   HL<=-3 --> 0<=0xFF-H --> false if carry
    sbc   A, H          ; 1:4       dup -3 <= if   HL<=-3 --> 0<=0xFF-H --> false if carry
    rra                 ; 1:4       dup -3 <= if
    xor   H             ; 1:4       dup -3 <= if   invert sign if HL is negative
    jp    p, else488    ; 3:10      dup -3 <= if   negative constant --> false if not sign
    ld   BC, string410  ; 3:10      print_i   Address of string494 ending with inverted most significant bit == string410
    call PRINT_STRING_I ; 3:17      print_i
else488  EQU $          ;           then  = endif
endif488:               ;           then
                       ;[11:40]     dup -3 > if   ( x -- x )  flag: x > -3 #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, 0xFD       ; 2:7       dup -3 > if   HL>-3 --> 0>0xFD-L --> false if not carry
    sub   L             ; 1:4       dup -3 > if   HL>-3 --> 0>0xFD-L --> false if not carry
    ld    A, 0xFF       ; 2:7       dup -3 > if   HL>-3 --> 0>0xFF-H --> false if not carry
    sbc   A, H          ; 1:4       dup -3 > if   HL>-3 --> 0>0xFF-H --> false if not carry
    rra                 ; 1:4       dup -3 > if
    xor   H             ; 1:4       dup -3 > if   invert sign if HL is negative
    jp    m, else489    ; 3:10      dup -3 > if   negative constant --> false if sign
    ld   BC, string414  ; 3:10      print_i   Address of string495 ending with inverted most significant bit == string414
    call PRINT_STRING_I ; 3:17      print_i
else489  EQU $          ;           then  = endif
endif489:               ;           then
                       ;[11:40]     dup -3 >= if   ( x -- x )  flag: x >= -3 #variant: default, change: "define({_TYP_SINGLE},{sign_first})"
    ld    A, L          ; 1:4       dup -3 >= if   HL>=-3 --> L-0xFD>=0 --> false if carry
    sub  0xFD           ; 2:7       dup -3 >= if   HL>=-3 --> L-0xFD>=0 --> false if carry
    ld    A, H          ; 1:4       dup -3 >= if   HL>=-3 --> H-0xFF>=0 --> false if carry
    sbc   A, 0xFF       ; 2:7       dup -3 >= if   HL>=-3 --> H-0xFF>=0 --> false if carry
    rra                 ; 1:4       dup -3 >= if
    xor   H             ; 1:4       dup -3 >= if   invert sign if HL is negative
    jp    p, else490    ; 3:10      dup -3 >= if   negative constant --> false if not sign
    ld   BC, string418  ; 3:10      print_i   Address of string496 ending with inverted most significant bit == string418
    call PRINT_STRING_I ; 3:17      print_i
else490  EQU $          ;           then  = endif
endif490:               ;           then
    push HL             ; 1:11      dup .   x3 x1 x2 x1
    call PRT_S16        ; 3:17      .   ( s -- )
    ex   DE, HL         ; 1:4       dup .   x3 x2 x1
    push DE             ; 1:11      -3
    ex   DE, HL         ; 1:4       -3
    ld   HL, 0-3        ; 3:10      -3
    call PRT_SP_S16     ; 3:17      space .   ( s -- )
    ld    A, 0x0D       ; 2:7       cr   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      cr   putchar(reg A) with ZX 48K ROM
                        ;[8:29]     dup -3 u= if   ( x1 -- x1 )   -3 == HL
    ld    A, L          ; 1:4       dup -3 u= if
    xor   0x02          ; 2:7       dup -3 u= if   x[1] = 0xFF ^ 0x02
    and   H             ; 1:4       dup -3 u= if
    inc   A             ; 1:4       dup -3 u= if   x[2] = 0xFF
    jp   nz, else491    ; 3:10      dup -3 u= if
    ld   BC, string398  ; 3:10      print_i   Address of string497 ending with inverted most significant bit == string398
    call PRINT_STRING_I ; 3:17      print_i
else491  EQU $          ;           then  = endif
endif491:               ;           then
                        ;[8:29]     dup -3 u<> if   ( x1 -- x1 )   -3 <> HL
    ld    A, L          ; 1:4       dup -3 u<> if
    xor   0x02          ; 2:7       dup -3 u<> if   x[1] = 0xFF ^ 0x02
    and   H             ; 1:4       dup -3 u<> if
    inc   A             ; 1:4       dup -3 u<> if   x[2] = 0xFF
    jp    z, else492    ; 3:10      dup -3 u<> if
    ld   BC, string402  ; 3:10      print_i   Address of string498 ending with inverted most significant bit == string402
    call PRINT_STRING_I ; 3:17      print_i
else492  EQU $          ;           then  = endif
endif492:               ;           then
                        ;[9:32]     dup -3 u< if   ( u -- u ) flag: u<-3 #variant: default
    ld    A, L          ; 1:4       dup -3 u< if   HL<-3 --> L-0xFD<0 --> false if not carry
    sub  0xFD           ; 2:7       dup -3 u< if   HL<-3 --> L-0xFD<0 --> false if not carry
    ld    A, H          ; 1:4       dup -3 u< if   HL<-3 --> H-0xFF<0 --> false if not carry
    sbc   A, 0xFF       ; 2:7       dup -3 u< if   HL<-3 --> H-0xFF<0 --> false if not carry
    jp   nc, else493    ; 3:10      dup -3 u< if   false if not carry
    ld   BC, string406  ; 3:10      print_i   Address of string499 ending with inverted most significant bit == string406
    call PRINT_STRING_I ; 3:17      print_i
else493  EQU $          ;           then  = endif
endif493:               ;           then
                        ;[9:32]     dup -3 u<= if   ( u -- u ) flag: u<=-3 #variant: default
    ld    A, 0xFD       ; 2:7       dup -3 u<= if   HL<=-3 --> 0<=0xFD-L --> false if carry
    sub   L             ; 1:4       dup -3 u<= if   HL<=-3 --> 0<=0xFD-L --> false if carry
    ld    A, 0xFF       ; 2:7       dup -3 u<= if   HL<=-3 --> 0<=0xFF-H --> false if carry
    sbc   A, H          ; 1:4       dup -3 u<= if   HL<=-3 --> 0<=0xFF-H --> false if carry
    jp    c, else494    ; 3:10      dup -3 u<= if   false if carry
    ld   BC, string410  ; 3:10      print_i   Address of string500 ending with inverted most significant bit == string410
    call PRINT_STRING_I ; 3:17      print_i
else494  EQU $          ;           then  = endif
endif494:               ;           then
                        ;[9:32]     dup -3 u> if   ( u -- u ) flag: u>-3 #variant: default
    ld    A, 0xFD       ; 2:7       dup -3 u> if   HL>-3 --> 0>0xFD-L --> false if not carry
    sub   L             ; 1:4       dup -3 u> if   HL>-3 --> 0>0xFD-L --> false if not carry
    ld    A, 0xFF       ; 2:7       dup -3 u> if   HL>-3 --> 0>0xFF-H --> false if not carry
    sbc   A, H          ; 1:4       dup -3 u> if   HL>-3 --> 0>0xFF-H --> false if not carry
    jp   nc, else495    ; 3:10      dup -3 u> if   false if not carry
    ld   BC, string414  ; 3:10      print_i   Address of string501 ending with inverted most significant bit == string414
    call PRINT_STRING_I ; 3:17      print_i
else495  EQU $          ;           then  = endif
endif495:               ;           then
                        ;[9:32]     dup -3 u>= if   ( u -- u ) flag: u>=-3 #variant: default
    ld    A, L          ; 1:4       dup -3 u>= if   HL>=-3 --> L-0xFD>=0 --> false if carry
    sub  0xFD           ; 2:7       dup -3 u>= if   HL>=-3 --> L-0xFD>=0 --> false if carry
    ld    A, H          ; 1:4       dup -3 u>= if   HL>=-3 --> H-0xFF>=0 --> false if carry
    sbc   A, 0xFF       ; 2:7       dup -3 u>= if   HL>=-3 --> H-0xFF>=0 --> false if carry
    jp    c, else496    ; 3:10      dup -3 u>= if   false if carry
    ld   BC, string418  ; 3:10      print_i   Address of string502 ending with inverted most significant bit == string418
    call PRINT_STRING_I ; 3:17      print_i
else496  EQU $          ;           then  = endif
endif496:               ;           then
    call PRT_U16        ; 3:17      u.   ( u -- )
    push DE             ; 1:11      -3
    ex   DE, HL         ; 1:4       -3
    ld   HL, 0-3        ; 3:10      -3
    call PRT_SP_U16     ; 3:17      space u.   ( u -- )
    ld    A, 0x0D       ; 2:7       cr   Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      cr   putchar(reg A) with ZX 48K ROM
x_m3_test_end:
    jp   0x0000         ; 3:10      ;
;   ---------  end of non-recursive function  ---------
;==============================================================================
; ( hi lo -- )
; Input: DEHL
; Output: Print space and signed decimal number in DEHL
; Pollutes: AF, BC, HL <- (SP), DE <- (SP-2)
PRT_SP_S32:             ;           prt_sp_s32
    ld    A, ' '        ; 2:7       prt_sp_s32   putchar Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      prt_sp_s32   putchar(reg A) with ZX 48K ROM
    ; fall to prt_s32
;------------------------------------------------------------------------------
; ( hi lo -- )
; Input: DEHL
; Output: Print signed decimal number in DEHL
; Pollutes: AF, BC, HL <- (SP), DE <- (SP-2)
PRT_S32:                ;           prt_s32
    ld    A, D          ; 1:4       prt_s32
    add   A, A          ; 1:4       prt_s32
    jr   nc, PRT_U32    ; 2:7/12    prt_s32
    ld    A, '-'        ; 2:7       prt_s32   putchar Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      prt_s32   putchar(reg A) with ZX 48K ROM
    call NEGATE_32      ; 3:17      prt_s32
    jr   PRT_U32        ; 2:12      prt_s32
;==============================================================================
; Input: DEHL
; Output: Print space and unsigned decimal number in DEHL
; Pollutes: AF, BC, HL <- (SP), DE <- (SP-2)
PRT_SP_U32:             ;           prt_sp_u32
    ld    A, ' '        ; 2:7       prt_sp_u32   putchar Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      prt_sp_u32   putchar(reg A) with ZX 48K ROM
    ; fall to prt_u32
;------------------------------------------------------------------------------
; Input: DEHL
; Output: Print unsigned decimal number in DEHL
; Pollutes: AF, BC, HL <- (SP), DE <- (SP-2)
PRT_U32:                ;           prt_u32
    xor   A             ; 1:4       prt_u32   HL = 103 & A=0 => 103, HL = 103 & A='0' => 00103
    push IX             ; 2:15      prt_u32
    ex   DE, HL         ; 1:4       prt_u32   HL = hi word
    ld  IXl, E          ; 2:8       prt_u32
    ld  IXh, D          ; 2:8       prt_u32   IX = lo word
    ld   DE, 0x3600     ; 3:10      prt_u32   C4 65 36 00 = -1000000000
    ld   BC, 0xC465     ; 3:10      prt_u32
    call BIN32_DEC      ; 3:17      prt_u32
    ld    D, 0x1F       ; 2:7       prt_u32   FA 0A 1F 00 = -100000000
    ld   BC, 0xFA0A     ; 3:10      prt_u32
    call BIN32_DEC      ; 3:17      prt_u32
    ld   DE, 0x6980     ; 3:10      prt_u32   FF 67 69 80 = -10000000
    ld   BC, 0xFF67     ; 3:10      prt_u32
    call BIN32_DEC      ; 3:17      prt_u32
    ld   DE, 0xBDC0     ; 3:10      prt_u32   FF F0 BD C0 = -1000000
    ld    C, 0xF0       ; 2:7       prt_u32
    call BIN32_DEC      ; 3:17      prt_u32
    ld   DE, 0x7960     ; 3:10      prt_u32   FF FE 79 60 = -100000
    ld    C, 0xFE       ; 2:7       prt_u32
    call BIN32_DEC      ; 3:17      prt_u32
    ld   DE, 0xD8F0     ; 3:10      prt_u32   FF FF D8 F0 = -10000
    ld    C, B          ; 1:4       prt_u32
    call BIN32_DEC      ; 3:17      prt_u32
    ld   DE, 0xFC18     ; 3:10      prt_u32   FF FF FC 18 = -1000
    call BIN32_DEC      ; 3:17      prt_u32
    ld   DE, 0xFF9C     ; 3:10      prt_u32   FF FF FF 9C = -100
    call BIN32_DEC      ; 3:17      prt_u32
    ld    E, 0xF6       ; 2:7       prt_u32   FF FF FF F6 = -10
    call BIN32_DEC      ; 3:17      prt_u32
    ld    A, IXl        ; 2:8       prt_u32
    pop  IX             ; 2:14      prt_u32
    pop  BC             ; 1:10      prt_u32   load ret
    pop  HL             ; 1:10      prt_u32
    pop  DE             ; 1:10      prt_u32
    push BC             ; 1:11      prt_u32   save ret
    jr   BIN32_DEC_CHAR ; 2:12      prt_u32
;------------------------------------------------------------------------------
; Input: A = 0 or A = '0' = 0x30 = 48, HL, IX, BC, DE
; Output: if ((HLIX/(-BCDE) > 0) || (A >= '0')) print number HLIX/(-BCDE)
; Pollutes: AF, AF', IX, HL
BIN32_DEC:              ;           bin32_dec
    add  IX, DE         ; 2:15      bin32_dec   lo word
    adc  HL, BC         ; 2:15      bin32_dec   hi word
    inc   A             ; 1:4       bin32_dec
    jr    c, $-5        ; 2:7/12    bin32_dec
    ex   AF, AF'        ; 1:4       bin32_dec
    ld    A, IXl        ; 2:8       bin32_dec
    sub   E             ; 1:4       bin32_dec
    ld  IXl, A          ; 2:8       bin32_dec
    ld    A, IXh        ; 2:8       bin32_dec
    sbc   A, D          ; 1:4       bin32_dec
    ld  IXh, A          ; 2:8       bin32_dec
    sbc  HL, BC         ; 2:15      bin32_dec   hi word
    ex   AF, AF'        ; 1:4       bin32_dec
    dec   A             ; 1:4       bin32_dec
    ret   z             ; 1:5/11    bin32_dec   does not print leading zeros
BIN32_DEC_CHAR:         ;           bin32_dec
    or   '0'            ; 2:7       bin32_dec   1..9 --> '1'..'9', unchanged '0'..'9'
    rst   0x10          ; 1:11      bin32_dec   putchar(reg A) with ZX 48K ROM
    ld    A, '0'        ; 2:7       bin32_dec   reset A to '0'
    ret                 ; 1:10      bin32_dec
;==============================================================================
; Input: HL
; Output: Print space and signed decimal number in HL
; Pollutes: AF, BC, HL <- DE, DE <- (SP)
PRT_SP_S16:             ;           prt_sp_s16
    ld    A, ' '        ; 2:7       prt_sp_s16   putchar Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      prt_sp_s16   putchar(reg A) with ZX 48K ROM
    ; fall to prt_s16
;------------------------------------------------------------------------------
; Input: HL
; Output: Print signed decimal number in HL
; Pollutes: AF, BC, HL <- DE, DE <- (SP)
PRT_S16:                ;           prt_s16
    ld    A, H          ; 1:4       prt_s16
    add   A, A          ; 1:4       prt_s16
    jr   nc, PRT_U16    ; 2:7/12    prt_s16
    ld    A, '-'        ; 2:7       prt_s16   putchar Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      prt_s16   putchar(reg A) with ZX 48K ROM
    xor   A             ; 1:4       prt_s16   neg
    sub   L             ; 1:4       prt_s16   neg
    ld    L, A          ; 1:4       prt_s16   neg
    sbc   A, H          ; 1:4       prt_s16   neg
    sub   L             ; 1:4       prt_s16   neg
    ld    H, A          ; 1:4       prt_s16   neg
    jr   PRT_U16        ; 2:12      prt_s16
;==============================================================================
; Input: HL
; Output: Print space and unsigned decimal number in HL
; Pollutes: AF, BC, HL <- DE, DE <- (SP)
PRT_SP_U16:             ;           prt_sp_u16
    ld    A, ' '        ; 2:7       prt_sp_u16   putchar Pollutes: AF, AF', DE', BC'
    rst   0x10          ; 1:11      prt_sp_u16   putchar(reg A) with ZX 48K ROM
    ; fall to prt_u16
;------------------------------------------------------------------------------
; Input: HL
; Output: Print unsigned decimal number in HL
; Pollutes: AF, BC, HL <- DE, DE <- (SP)
PRT_U16:                ;           prt_u16
    xor   A             ; 1:4       prt_u16   HL=103 & A=0 => 103, HL = 103 & A='0' => 00103
    ld   BC, -10000     ; 3:10      prt_u16
    call BIN16_DEC      ; 3:17      prt_u16
    ld   BC, -1000      ; 3:10      prt_u16
    call BIN16_DEC      ; 3:17      prt_u16
    ld   BC, -100       ; 3:10      prt_u16
    call BIN16_DEC      ; 3:17      prt_u16
    ld    C, -10        ; 2:7       prt_u16
    call BIN16_DEC      ; 3:17      prt_u16
    ld    A, L          ; 1:4       prt_u16
    pop  HL             ; 1:10      prt_u16   load ret
    ex  (SP),HL         ; 1:19      prt_u16
    ex   DE, HL         ; 1:4       prt_u16
    jr   BIN16_DEC_CHAR ; 2:12      prt_u16
;------------------------------------------------------------------------------
; Input: A = 0 or A = '0' = 0x30 = 48, HL, IX, BC, DE
; Output: if ((HL/(-BC) > 0) || (A >= '0')) print number -HL/BC
; Pollutes: AF, HL
    inc   A             ; 1:4       bin16_dec
BIN16_DEC:              ;           bin16_dec
    add  HL, BC         ; 1:11      bin16_dec
    jr    c, $-2        ; 2:7/12    bin16_dec
    sbc  HL, BC         ; 2:15      bin16_dec
    or    A             ; 1:4       bin16_dec
    ret   z             ; 1:5/11    bin16_dec   does not print leading zeros
BIN16_DEC_CHAR:         ;           bin16_dec
    or   '0'            ; 2:7       bin16_dec   1..9 --> '1'..'9', unchanged '0'..'9'
    rst   0x10          ; 1:11      bin16_dec   putchar(reg A) with ZX 48K ROM 
    ld    A, '0'        ; 2:7       bin16_dec   reset A to '0'
    ret                 ; 1:10      bin16_dec
;==============================================================================
; ( d -- -d )
NEGATE_32:              ;[14:62]    negate_32   ( hi lo -- 0-hi-carry 0-lo )
    xor   A             ; 1:4       negate_32
    ld    C, A          ; 1:4       negate_32
    sub   L             ; 1:4       negate_32
    ld    L, A          ; 1:4       negate_32
    ld    A, C          ; 1:4       negate_32
    sbc   A, H          ; 1:4       negate_32
    ld    H, A          ; 1:4       negate_32
    ld    A, C          ; 1:4       negate_32
    sbc   A, E          ; 1:4       negate_32
    ld    E, A          ; 1:4       negate_32
    ld    A, C          ; 1:4       negate_32
    sbc   A, D          ; 1:4       negate_32
    ld    D, A          ; 1:4       negate_32
    ret                 ; 1:10      negate_32
;==============================================================================
; ( d2 ret d1 -- d2 d1 )
;  In: (SP+4) = h2, (SP+2) = l2, (SP) = ret
; Out: (SP+2) = h2, (SP)   = l2, (SP) = ret, AF = h2, BC = l2
FCE_4DUP_DLT:           ;[9:75]     fce_4dup_dlt   ( d2 ret d1 -- d2 d1 )
    pop  AF             ; 1:10      fce_4dup_dlt   h2 l2 .. ..  AF = ret
    pop  BC             ; 1:10      fce_4dup_dlt   h2 .. .. ..  BC = l2
    ex   AF, AF'        ; 1:4       fce_4dup_dlt   h2 .. .. ..
    pop  AF             ; 1:10      fce_4dup_dlt   .. .. .. ..  AF'= h2
    push AF             ; 1:11      fce_4dup_dlt   h2 .. .. ..
    push BC             ; 1:11      fce_4dup_dlt   h2 l2 .. ..
    ex   AF, AF'        ; 1:4       fce_4dup_dlt   h2 l2 .. ..
    push AF             ; 1:11      fce_4dup_dlt   h2 l2 rt ..
    ex   AF, AF'        ; 1:4       fce_4dup_dlt   h2 l2 rt ..  AF = h2
    ; fall to fce_dlt
;==============================================================================
; ( d2 ret d1 -- d1 )
; set carry if d2<d1 is true
;  In: AF = h2, BC = l2, DE = h1, HL = l1
; Out:          BC = h2, DE = h1, HL = l1, set carry if true
FCE_DLT:               ;[18:58,71]  fce_dlt   ( d2 ret d1 -- d2 d1 )   # default version, changes using "define({_USE_FCE_DLT},{small})"
    push AF             ; 1:11      fce_dlt   h2 l2 rt h2 h1 l1  d2<d1 --> d2-d1<0 --> AFBC-DEHL<0 --> carry if true
    sub   D             ; 1:4       fce_dlt   h2 l2 rt h2 h1 l1  A-D<0 --> carry if true
    jr    z, $+8        ; 2:7/12    fce_dlt   h2 l2 rt h2 h1 l1
    rra                 ; 1:4       fce_dlt   h2 l2 rt h2 h1 l1        --> sign  if true
    pop  BC             ; 1:10      fce_dlt   h2 l2 rt .. h1 l1
    xor   B             ; 1:4       fce_dlt   h2 l2 rt .. h1 l1
    xor   D             ; 1:4       fce_dlt   h2 l2 rt .. h1 l1
    add   A, A          ; 1:4       fce_dlt   h2 l2 rt .. h1 l1        --> carry if true
    ret                 ; 1:10      fce_dlt   h2 l2 .. .. h1 l1
    ld    A, C          ; 1:4       fce_dlt   h2 l2 rt h2 h1 l1
    sub   L             ; 1:4       fce_dlt   h2 l2 rt h2 h1 l1  C-L<0 --> carry if true
    ld    A, B          ; 1:4       fce_dlt   h2 l2 rt h2 h1 l1
    sbc   A, H          ; 1:4       fce_dlt   h2 l2 rt h2 h1 l1  B-H<0 --> carry if true
    pop  BC             ; 1:10      fce_dlt   h2 l2 rt .. h1 l1  BC = hi16(d2)
    ld    A, C          ; 1:4       fce_dlt   h2 l2 rt .. h1 l1
    sbc   A, E          ; 1:4       fce_dlt   h2 l2 rt .. h1 l1  C-E<0 --> carry if true
    ret                 ; 1:10      fce_dlt   h2 l2 .. .. h1 l1
;==============================================================================
; ( d2 ret d1 -- d2 d1 )
;  In: (SP+4) = h2, (SP+2) = l2, (SP) = ret
; Out: (SP+2) = h2, (SP)   = l2, (SP) = ret, AF = h2, BC = l2
FCE_4DUP_DGT:           ;[9:75]     fce_4dup_dgt   ( d2 ret d1 -- d2 d1 )
    pop  AF             ; 1:10      fce_4dup_dgt   h2 l2 .. ..  AF = ret
    pop  BC             ; 1:10      fce_4dup_dgt   h2 .. .. ..  BC = l2
    ex   AF, AF'        ; 1:4       fce_4dup_dgt   h2 .. .. ..
    pop  AF             ; 1:10      fce_4dup_dgt   .. .. .. ..  AF'= h2
    push AF             ; 1:11      fce_4dup_dgt   h2 .. .. ..
    push BC             ; 1:11      fce_4dup_dgt   h2 l2 .. ..
    ex   AF, AF'        ; 1:4       fce_4dup_dgt   h2 l2 .. ..
    push AF             ; 1:11      fce_4dup_dgt   h2 l2 rt ..
    ex   AF, AF'        ; 1:4       fce_4dup_dgt   h2 l2 rt ..  AF = h2
    ; fall to fce_dgt
;==============================================================================
; ( d2 ret d1 -- d1 )
; carry if d2>d1 is true
;  In: AF = h2, BC = l2, DE = h1, HL = l1
; Out:          BC = h2, DE = h1, HL = l1, set carry if true
FCE_DGT:               ;[22:60,71]  fce_dgt   ( d2 ret d1 -- d2 d1 )   # default version, changes using "define({_USE_FCE_DGT},{small})"
    push AF             ; 1:11      fce_dgt   h2 l2 rt h2 h1 l1  d2>d1 --> 0>d1-d2 --> 0>DEHL-AFBC --> carry if true
    xor   D             ; 1:4       fce_dgt   h2 l2 rt h2 h1 l1  A==D?
    jr    z, $+12       ; 2:7/12    fce_dgt   h2 l2 rt h2 h1 l1
    pop  BC             ; 1:10      fce_dgt   h2 l2 rt .. h1 l1
    jp    p, $+6        ; 3:10      fce_dgt   h2 l2 rt .. h1 l1
    ld    A, B          ; 1:4       fce_dgt   h2 l2 rt .. h1 l1  opposite signs
    sub   D             ; 1:4       fce_dgt   h2 l2 rt .. h1 l1  0>B-D --> carry if true
    ret                 ; 1:10      fce_dgt   h2 l2 .. .. h1 l1
    ld    A, D          ; 1:4       fce_dgt   h2 l2 rt .. h1 l1  identical signs
    sub   B             ; 1:4       fce_dgt   h2 l2 rt .. h1 l1  0>D-B --> carry if true
    ret                 ; 1:10      fce_dgt   h2 l2 .. .. h1 l1
    ld    A, L          ; 1:4       fce_dgt   h2 l2 rt h2 h1 l1
    sub   C             ; 1:4       fce_dgt   h2 l2 rt h2 h1 l1  0>L-C --> carry if true
    ld    A, H          ; 1:4       fce_dgt   h2 l2 rt h2 h1 l1
    sbc   A, B          ; 1:4       fce_dgt   h2 l2 rt h2 h1 l1  0>H-B --> carry if true
    pop  BC             ; 1:10      fce_dgt   h2 l2 rt .. h1 l1
    ld    A, E          ; 1:4       fce_dgt   h2 l2 rt .. h1 l1
    sbc   A, C          ; 1:4       fce_dgt   h2 l2 rt .. h1 l1  0>E-C --> carry if true
    ret                 ; 1:10      fce_dgt   h2 l2 .. .. h1 l1
;------------------------------------------------------------------------------
; Print string ending with inverted most significant bit
; In: BC = addr string_imsb
; Out: BC = addr last_char + 1
    rst   0x10          ; 1:11      print_string_i   putchar(reg A) with ZX 48K ROM
PRINT_STRING_I:         ;           print_string_i
    ld    A,(BC)        ; 1:7       print_string_i
    inc  BC             ; 1:6       print_string_i
    or    A             ; 1:4       print_string_i
    jp    p, $-4        ; 3:10      print_string_i
    and  0x7f           ; 2:7       print_string_i
    rst   0x10          ; 1:11      print_string_i   putchar(reg A) with ZX 48K ROM
    ret                 ; 1:10      print_string_i
;==============================================================================
; Print text with 5x8 font
; entry point is "putchar"

MAX_X           equ 51       ; x = 0..50
MAX_Y           equ 24       ; y = 0..23
CURCHL          equ 0x5C51
PRINT_OUT       equ 0x5CBB
    
set_ink:                ;           putchar   0x10
    ld   HL, self_attr  ; 3:10      putchar
    xor (HL)            ; 1:7       putchar
    and 0x07            ; 2:7       putchar
    xor (HL)            ; 1:7       putchar
    jr  set_attr        ; 2:12      putchar
    
set_paper:              ;           putchar   0x11          
    ld   HL, self_attr  ; 3:10      putchar
    add   A, A          ; 1:4       putchar   2x
    add   A, A          ; 1:4       putchar   4x
    add   A, A          ; 1:4       putchar   8x
    xor (HL)            ; 1:7       putchar
    and 0x38            ; 2:7       putchar
    xor (HL)            ; 1:7       putchar
    jr  set_attr        ; 2:12      putchar
    
set_flash:              ;           putchar   0x12
    rra                 ; 1:4       putchar   carry = flash
    ld   HL, self_attr  ; 3:10      putchar
    ld    A,(HL)        ; 1:7       putchar
    adc   A, A          ; 1:4       putchar
    rrca                ; 1:4       putchar
    jr  set_attr        ; 2:12      putchar
    
set_bright:             ;           putchar   0x13
    ld   HL, self_attr  ; 3:10      putchar
    rrca                ; 1:4       putchar
    rrca                ; 1:4       putchar
    xor (HL)            ; 1:7       putchar
    and 0x40            ; 2:7       putchar
    xor (HL)            ; 1:7       putchar
    jr   set_attr       ; 2:12      putchar
    
set_inverse:            ;           putchar   0x14
    ld   HL, self_attr  ; 3:10      putchar
    ld    A,(HL)        ; 1:7       putchar
    and  0x38           ; 2:7       putchar   A = 00pp p000
    add   A, A          ; 1:4       putchar
    add   A, A          ; 1:4       putchar   A = ppp0 0000
    xor (HL)            ; 1:7       putchar
    and  0xF8           ; 2:7       putchar
    xor (HL)            ; 1:7       putchar   A = ppp0 0iii
    rlca                ; 1:4       putchar
    rlca                ; 1:4       putchar
    rlca                ; 1:4       putchar   A = 00ii ippp
    xor (HL)            ; 1:7       putchar
    and  0x3F           ; 2:7       putchar
    xor (HL)            ; 1:7       putchar   A = fbii ippp

set_attr:               ;           putchar
    ld  (HL),A          ; 1:7       putchar   save new attr   
clean_set_0:            ;           putchar
    xor   A             ; 1:4       putchar
clean_set_A:            ;           putchar
    ld  (self_jmp),A    ; 3:13      putchar
    pop  HL             ; 1:10      putchar
    ret                 ; 1:10      putchar
    
set_over:               ;           putchar   0x15
    jr   clean_set_0    ; 2:12      putchar

set_at:                 ;           putchar   0x16
    ld  (putchar_y),A   ; 3:13      putchar   save new Y
    neg                 ; 2:8       putchar
    add   A, 0x18       ; 2:7       putchar
    ld  (0x5C89),A      ; 3:13      putchar
    ld   A,$+4-jump_from; 2:7       putchar
    jr   clean_set_A    ; 2:12      putchar

set_at_x:               ;           putchar
    ld  (putchar_yx),A  ; 3:13      putchar   save new X
    jr   clean_set_0    ; 2:12      putchar

  if 0
    jr   print_comma    ; 2:12      putchar   0x06
    jr   print_edit     ; 2:12      putchar   0x07
    jr   cursor_left    ; 2:12      putchar   0x08
    jr   cursor_right   ; 2:12      putchar   0x09
    jr   cursor_down    ; 2:12      putchar   0x0A
    jr   cursor_up      ; 2:12      putchar   0x0B
    jr   delete         ; 2:12      putchar   0x0C
    jr   enter          ; 2:12      putchar   0x0D
    jr   not_used       ; 2:12      putchar   0x0E
    jr   not_used       ; 2:12      putchar   0x0F    
  endif
  
tab_spec:               ;           putchar 
    jr   set_ink        ; 2:12      putchar   0x10
    jr   set_paper      ; 2:12      putchar   0x11
    jr   set_flash      ; 2:12      putchar   0x12
    jr   set_bright     ; 2:12      putchar   0x13
    jr   set_inverse    ; 2:12      putchar   0x14
    jr   set_over       ; 2:12      putchar   0x15
    jr   set_at         ; 2:12      putchar   0x16
;   jr   set_tab        ; 2:12      putchar   0x17

set_tab:                ;           putchar
    ld   HL,(putchar_yx); 3:16      putchar   load origin cursor
    sub  MAX_X          ; 2:7       putchar
    jr   nc,$-2         ; 2:7/12    putchar
    add   A, MAX_X      ; 2:7       putchar   (new x) mod MAX_X
    cp    L             ; 1:4       putchar
    call  c, next_line  ; 3:10/17   putchar   new x < (old x+1) 
set_tab_A               ;           putchar
    ld    L, A          ; 1:4       putchar
    ld  (putchar_yx),HL ; 3:16      putchar   save new cursor
    jr   clean_set_0    ; 2:12      putchar

cursor_left:            ;           putchar   0x08
    ld   HL,(putchar_yx); 3:16      putchar
    inc   L             ; 1:4       putchar
    dec   L             ; 1:4       putchar
    dec  HL             ; 1:6       putchar
    jr   nz, $+4        ; 2:7/12    putchar
    ld    L, MAX_X-1    ; 2:7       putchar
    jr   enter_exit     ; 2:12      putchar

print_comma:            ;           putchar   0x06
    ld   HL,(putchar_yx); 3:16      putchar   H = next Y, L = next X
    ld    A, 17         ; 2:7       putchar
    cp    L             ; 1:4       putchar
    jr   nc, set_tab_A  ; 2:12      putchar
    add   A, A          ; 1:4       putchar
    cp    L             ; 1:4       putchar
    jr   nc, set_tab_A  ; 2:12      putchar
    xor   A             ; 1:4       putchar
    
enter:                  ;           putchar   0x0D
    call  z, next_line  ; 3:10/17   putchar
enter_exit:             ;           putchar
    ld  (putchar_yx),HL ; 3:16      putchar   save new cursor
    pop  HL             ; 1:10      putchar   load HL
    ret                 ; 3:10

    
print_edit:             ;           putchar   0x07
cursor_right:           ;           putchar   0x09
cursor_down:            ;           putchar   0x0A
cursor_up:              ;           putchar   0x0B
delete:                 ;           putchar   0x0C
not_used:               ;           putchar   0x0E, 0x0F

print_question          ;           putchar   0x00..0x05 + 0x0E..0x0F + 0x18..0x1F
    ld    A, '?'        ; 2:7       putchar
    jr   print_char_HL  ; 2:7/12    putchar

;------------------------------------------------------------------------------
;  Input: A = char
; Poluttes: AF, AF', DE', BC'
putchar:
    push HL                 ; 1:11
self_jmp    equ $+1
    jr   jump_from          ; 2:7/12    self-modifying
jump_from:
    cp   0xA5               ; 2:7       token 
    jr   nc, print_token    ; 2:7/12

    cp   0x20               ; 2:7
    jr   nc, print_char_HL  ; 2:7/12

    cp   0x06               ; 2:7       comma
    jr    z, print_comma    ; 2:7/12
    cp   0x08               ; 2:7       cursor_left
    jr    z, cursor_left    ; 2:7/12
    cp   0x09               ; 2:7       cursor_right
    jp    z, next_cursor    ; 3:10
    cp   0x0D               ; 2:7       enter
    jr    z, enter          ; 2:7/12

    sub  0x10               ; 2:7       set_ink
    jr    c, print_question ; 2:7/12

    cp   0x08               ; 2:7       >print_tab
    jr   nc, print_question ; 2:7/12

draw_spec:    
    add   A,A               ; 1:4       2x
    sub  jump_from-tab_spec ; 2:7
    ld  (self_jmp),A        ; 3:13
draw_spec_exit:             ;
    pop  HL                 ; 1:10
    ret                     ; 1:10
    
print_token:
    ex   DE, HL             ; 1:4
    ld   DE, 0x0095	        ; 3:10      The base address of the token table
    sub  0xA5               ; 2:7
    push AF                 ; 1:11      Save the code on the stack. (Range +00 to +5A,  to COPY).
    
; Input
;   A   Message table entry number
;   DE  Message table start address
; Output
;   DE  Address of the first character of message number A
;   F   Carry flag: suppress (set) or allow (reset) a leading space
    call 0x0C41             ; 3:17      THE 'TABLE SEARCH' SUBROUTINE 
    ex   DE, HL             ; 1:4

    ld    A,' '             ; 2:7       A 'space' will be printed before the message/token if required (bit 0 of FLAGS reset).
    bit   0,(IY+0x01)       ;
    call  z, print_char     ; 3:17

; The characters of the message/token are printed in turn.

token_loop:
    ld    A,(HL)            ; 1:7       Collect a code.
    and  0x7F               ; 2:7       Cancel any 'inverted bit'.
    call print_char         ; 3:17      Print the character.
    ld    A,(HL)            ; 1:7       Collect the code again.
    inc  HL                 ; 1:6       Advance the pointer.
    add   A, A              ; 1:4       The 'inverted bit' goes to the carry flag and signals the end of the message/token; otherwise jump back.
    jr   nc, token_loop     ; 2:7/12
    
; Now consider whether a 'trailing space' is required.

    pop  HL                 ; 1:10      For messages, H holds +00; for tokens, H holds +00 to +5A.
    cp   0x48               ; 2:7       Jump forward if the last character was a '$'
    jr    z, $+6            ; 2:7/12
    cp   0x82               ; 2:7       Return if the last character was any other before 'A'.
    jr    c, draw_spec_exit ; 2:7/12
    ld    A, H              ; 1:4       Examine the value in H and return if it indicates a message, , INKEY$ or PI.
    cp   0x03               ; 2:7
    ld    A, ' '            ; 2:7       All other cases will require a 'trailing space'.    
    ret   c                 ; 1:5/11
    pop  HL                 ; 1:10
print_char:
    push HL                 ; 1:11    uschovat HL na zsobnk
print_char_HL:

    exx                     ; 1:4
    push DE                 ; 1:11    uschovat DE na zsobnk
    push BC                 ; 1:11    uschovat BC na zsobnk    

    push HL                 ; 1:11    uschovat HL na zsobnk

    ld    BC, FONT_ADR      ; 3:10    adresa, od n zanaj masky znak

    add   A, A              ; 1:4
    ld    L, A              ; 1:4     2x
    ld    H, 0x00           ; 1:4     C je nenulov
    add  HL, HL             ; 1:11    4x
    add  HL, BC             ; 1:11    pist bzovou adresu masek znak    
    exx                     ; 1:4

;# YX -> ATTR

putchar_yx     equ     $+1
putchar_y      equ     $+2

    ld   DE, 0x0000         ; 3:10
    ld    A, E              ; 1:4     X
    add   A, A              ; 1:4     2*X
    add   A, A              ; 1:4     4*X
    add   A, E              ; 1:4     5*X
    ld    B, A              ; 1:4     save 5*X
    
    xor   D                 ; 1:4
    and 0xF8                ; 2:7
    xor   D                 ; 1:4
    rrca                    ; 1:4
    rrca                    ; 1:4
    rrca                    ; 1:4
    ld    L, A              ; 1:4

    ld    A, D              ; 1:4   
    or  0xC7                ; 2:7     110y y111, reset carry
    rra                     ; 1:4     0110 yy11, set carry
    rrca                    ; 1:4     1011 0yy1, set carry
    ccf                     ; 1:4     reset carry
    rra                     ; 1:4     0101 10yy
    ld    H, A              ; 1:4

self_attr       equ $+1
    ld  (HL),0x38           ; 2:10    uloen atributu znaku

    ld    A, D              ; 1:4
    and 0x18                ; 2:7
    or  0x40                ; 2:7
    ld    H, A              ; 1:4
    
    ld    A, B              ; 1:4     load 5*X
    and 0x07                ; 2:7
    cpl                     ; 1:4
    add   A, 0x09           ; 2:7         
    ld    B, A              ; 2:7     pocitadlo pro pocatecni posun vlevo masky znaku
    exx                     ; 1:4
    ld    C, A              ; 1:4
    exx                     ; 1:4
    ex   DE, HL             ; 1:4
    ld   HL, 0x00F0         ; 3:10
    add  HL, HL             ; 1:11    pocatecni posun masky
    djnz  $-1               ; 2:8/13        
    ex   DE, HL             ; 1:4

    ld    C, 4          ; 2:7       putchar   draw        
putchar_c:              ;           putchar   draw
    exx                 ; 1:4       putchar   draw
    ld    A,(HL)        ; 1:7       putchar   draw
    inc  HL             ; 1:6       putchar   draw
    ld    B, C          ; 1:4       putchar   draw
    rlca                ; 1:4       putchar   draw
    djnz  $-1           ; 2:8/13    putchar   draw
    ld    B, A          ; 1:4       putchar   draw
    exx                 ; 1:4       putchar   draw
    ld    B, 2          ; 2:7       putchar   draw 
putchar_b:              ;           putchar   draw
    xor (HL)            ; 1:7       putchar   draw
    and   D             ; 1:4       putchar   draw
    xor (HL)            ; 1:7       putchar   draw
    ld  (HL),A          ; 1:4       putchar   draw   ulozeni jednoho bajtu z masky

    exx                 ; 1:4       putchar   draw
    ld    A, B          ; 1:4       putchar   draw   naten druhe poloviny "bajtu" z masky
    exx                 ; 1:4       putchar   draw

    inc   L             ; 1:4       putchar   draw
    xor (HL)            ; 1:7       putchar   draw
    and   E             ; 1:4       putchar   draw
    xor (HL)            ; 1:7       putchar   draw
    ld  (HL),A          ; 1:4       putchar   draw   ulozeni jednoho bajtu z masky
    dec   L             ; 1:4       putchar   draw
    inc   H             ; 1:4       putchar   draw

    exx                 ; 1:4       putchar   draw
    ld    A, B          ; 1:4       putchar   draw   naten jednoho bajtu z masky
    rlca                ; 1:4       putchar   draw
    rlca                ; 1:4       putchar   draw
    rlca                ; 1:4       putchar   draw
    rlca                ; 1:4       putchar   draw
    ld    B, A          ; 1:4       putchar   draw
    exx                 ; 1:4       putchar   draw

;     halt
    
    djnz putchar_b      ; 2:8/13    putchar   draw
    
    dec   C             ; 2:7       putchar   draw 
    jr   nz, putchar_c  ; 2/7/12    putchar   draw


    pop  HL             ; 1:10      putchar   obnovit obsah HL ze zsobnku

    pop  BC             ; 1:10      putchar   obnovit obsah BC ze zsobnku
    pop  DE             ; 1:10      putchar   obnovit obsah DE ze zsobnku    
    exx                 ; 1:4       putchar
;   fall to next cursor    

; Output: [putchar_yx] = cursor right
next_cursor:            ;
    ld   HL,(putchar_yx); 3:16
; Input: HL = YX
next_cursor_HL:         ;
    inc   L             ; 1:4     0..50
    ld    A, L          ; 1:4
    sub  MAX_X          ; 2:7     -51
    call nc, next_line  ; 3:10/17
next_exit:
    ld  (putchar_yx),HL ; 3:16
exit_hl:                ;
    pop  HL             ; 1:10    obnovit obsah HL ze zsobnku
    ret                 ; 1:10

; Input:
; Output: H = Y+1/Y+0+scroll, L=0
next_line:
    push AF             ; 1:11      putchar
    ld   HL, 0x5C88     ; 3:10      putchar
    ld  (HL), 0x01      ; 2:10      putchar
    ld    A, 0x09       ; 2:7       putchar   cursor_right
    push HL             ; 1:11      putchar
    call 0x09F4         ; 3:17      putchar   rst 0x10 --> call 0x09F4
    ld   HL, putchar    ; 3:10      putchar
    ld  (PRINT_OUT),HL  ; 3:10      putchar
    pop  HL             ; 1:10      putchar
    ld    A, 0x18       ; 2:7       putchar
    inc   L             ; 1:4       putchar
    sub (HL)            ; 1:7       putchar
    ld    H, A          ; 1:7       putchar
    ld    L, 0x00       ; 2:7       putchar
    pop  AF             ; 1:10      putchar
    ret                 ; 1:10      putchar

FONT_ADR    equ     FONT_5x8-32*4
FONT_5x8:
    db %00000000,%00000000,%00000000,%00000000 ; 0x20 space
    db %00000010,%00100010,%00100000,%00100000 ; 0x21 !
    db %00000101,%01010000,%00000000,%00000000 ; 0x22 "
    db %00000000,%01011111,%01011111,%01010000 ; 0x23 #
    db %00000010,%01110110,%00110111,%00100000 ; 0x24 $
    db %00001100,%11010010,%01001011,%00110000 ; 0x25 %
    db %00000000,%11101010,%01011010,%11010000 ; 0x26 &
    db %00000011,%00010010,%00000000,%00000000 ; 0x27 '    
    db %00000010,%01000100,%01000100,%00100000 ; 0x28 (
    db %00000100,%00100010,%00100010,%01000000 ; 0x29 )
    db %00000000,%00001010,%01001010,%00000000 ; 0x2A *
    db %00000000,%00000100,%11100100,%00000000 ; 0x2B +
    db %00000000,%00000000,%00000010,%00100100 ; 0x2C ,
    db %00000000,%00000000,%11100000,%00000000 ; 0x2D -
    db %00000000,%00000000,%00000000,%01000000 ; 0x2E .
    db %00000000,%00010010,%01001000,%00000000 ; 0x2F /
    
    db %00000110,%10011011,%11011001,%01100000 ; 0x30 0
    db %00000010,%01100010,%00100010,%01110000 ; 0x31 1
    db %00000110,%10010001,%01101000,%11110000 ; 0x32 2
    db %00000110,%10010010,%00011001,%01100000 ; 0x33 3
    db %00000010,%01101010,%11110010,%00100000 ; 0x34 4
    db %00001111,%10001110,%00011001,%01100000 ; 0x35 5
    db %00000110,%10001110,%10011001,%01100000 ; 0x36 6
    db %00001111,%00010010,%01000100,%01000000 ; 0x37 7
    db %00000110,%10010110,%10011001,%01100000 ; 0x38 8
    db %00000110,%10011001,%01110001,%01100000 ; 0x39 9
    db %00000000,%00000010,%00000010,%00000000 ; 0x3A :
    db %00000000,%00000010,%00000010,%01000000 ; 0x3B ;
    db %00000000,%00010010,%01000010,%00010000 ; 0x3C <
    db %00000000,%00000111,%00000111,%00000000 ; 0x3D =
    db %00000000,%01000010,%00010010,%01000000 ; 0x3E >
    db %00001110,%00010010,%01000000,%01000000 ; 0x3F ?
    
    db %00000000,%01101111,%10111000,%01100000 ; 0x40 @
    db %00000110,%10011001,%11111001,%10010000 ; 0x41 A
    db %00001110,%10011110,%10011001,%11100000 ; 0x42 B
    db %00000110,%10011000,%10001001,%01100000 ; 0x43 C
    db %00001110,%10011001,%10011001,%11100000 ; 0x44 D
    db %00001111,%10001110,%10001000,%11110000 ; 0x45 E
    db %00001111,%10001110,%10001000,%10000000 ; 0x46 F
    db %00000110,%10011000,%10111001,%01110000 ; 0x47 G
    db %00001001,%10011111,%10011001,%10010000 ; 0x48 H
    db %00000111,%00100010,%00100010,%01110000 ; 0x49 I
    db %00000111,%00010001,%00011001,%01100000 ; 0x4A J
    db %00001001,%10101100,%10101001,%10010000 ; 0x4B K
    db %00001000,%10001000,%10001000,%11110000 ; 0x4C L
    db %00001001,%11111001,%10011001,%10010000 ; 0x4D M
    db %00001001,%11011011,%10011001,%10010000 ; 0x4E N
    db %00000110,%10011001,%10011001,%01100000 ; 0x4F O
    
    db %00001110,%10011001,%11101000,%10000000 ; 0x50 P
    db %00000110,%10011001,%10011010,%01010000 ; 0x51 Q
    db %00001110,%10011001,%11101001,%10010000 ; 0x52 R
    db %00000111,%10000110,%00010001,%11100000 ; 0x53 S
    db %00001111,%00100010,%00100010,%00100000 ; 0x54 T
    db %00001001,%10011001,%10011001,%01100000 ; 0x55 U
    db %00001001,%10011001,%10010101,%00100000 ; 0x56 V
    db %00001001,%10011001,%10011111,%10010000 ; 0x57 W
    db %00001001,%10010110,%10011001,%10010000 ; 0x58 X
    db %00001001,%10010101,%00100010,%00100000 ; 0x59 Y
    db %00001111,%00010010,%01001000,%11110000 ; 0x5A Z
    db %00000111,%01000100,%01000100,%01110000 ; 0x5B [
    db %00000000,%10000100,%00100001,%00000000 ; 0x5C \
    db %00001110,%00100010,%00100010,%11100000 ; 0x5D ]
    db %00000010,%01010000,%00000000,%00000000 ; 0x5E ^
    db %00000000,%00000000,%00000000,%11110000 ; 0x5F _
    
    db %00000011,%01001110,%01000100,%11110000 ; 0x60 ` GBP
    db %00000000,%01100001,%01111001,%01110000 ; 0x61 a
    db %00001000,%11101001,%10011001,%11100000 ; 0x62 b
    db %00000000,%01101001,%10001001,%01100000 ; 0x63 c
    db %00000001,%01111001,%10011001,%01110000 ; 0x64 d
    db %00000000,%01101001,%11111000,%01110000 ; 0x65 e
    db %00110100,%11100100,%01000100,%01000000 ; 0x66 f
    db %00000000,%01111001,%10010111,%00010110 ; 0x67 g
    db %00001000,%11101001,%10011001,%10010000 ; 0x68 h
    db %00100000,%01100010,%00100010,%01110000 ; 0x69 i
    db %00010000,%00110001,%00010001,%10010110 ; 0x6A j
    db %00001000,%10011010,%11001010,%10010000 ; 0x6B k
    db %00001100,%01000100,%01000100,%11100000 ; 0x6C l
    db %00000000,%11001011,%10111011,%10010000 ; 0x6D m
    db %00000000,%10101101,%10011001,%10010000 ; 0x6E n
    db %00000000,%01101001,%10011001,%01100000 ; 0x6F o
   
    db %00000000,%11101001,%10011001,%11101000 ; 0x70 p
    db %00000000,%01111001,%10011001,%01110001 ; 0x71 q
    db %00000000,%10101101,%10001000,%10000000 ; 0x72 r
    db %00000000,%01111000,%01100001,%11100000 ; 0x73 s
    db %00000100,%11100100,%01000100,%00110000 ; 0x74 t
    db %00000000,%10011001,%10011001,%01100000 ; 0x75 u
    db %00000000,%10011001,%10010101,%00100000 ; 0x76 v
    db %00000000,%10011001,%10011111,%10010000 ; 0x77 w
    db %00000000,%10011001,%01101001,%10010000 ; 0x78 x
    db %00000000,%10011001,%10010111,%00010110 ; 0x79 y
    db %00000000,%11110010,%01001000,%11110000 ; 0x7A z
    db %00010010,%00100100,%00100010,%00010000 ; 0x7B 
    db %01000100,%01000100,%01000100,%01000000 ; 0x7C |
    db %10000100,%01000010,%01000100,%10000000 ; 0x7D 
    db %00000101,%10100000,%00000000,%00000000 ; 0x7E ~
    db %00000110,%10011011,%10111001,%01100000 ; 0x7F (c)

STRING_SECTION:
string502   EQU  string418
  size502   EQU    size418
string501   EQU  string414
  size501   EQU    size414
string500   EQU  string410
  size500   EQU    size410
string499   EQU  string406
  size499   EQU    size406
string498   EQU  string402
  size498   EQU    size402
string497   EQU  string398
  size497   EQU    size398
string496   EQU  string418
  size496   EQU    size418
string495   EQU  string414
  size495   EQU    size414
string494   EQU  string410
  size494   EQU    size410
string493   EQU  string406
  size493   EQU    size406
string492   EQU  string402
  size492   EQU    size402
string491   EQU  string398
  size491   EQU    size398
string490   EQU  string418
  size490   EQU    size418
string489   EQU  string414
  size489   EQU    size414
string488   EQU  string410
  size488   EQU    size410
string487   EQU  string406
  size487   EQU    size406
string486   EQU  string402
  size486   EQU    size402
string485   EQU  string398
  size485   EQU    size398
string484   EQU  string418
  size484   EQU    size418
string483   EQU  string414
  size483   EQU    size414
string482   EQU  string410
  size482   EQU    size410
string481   EQU  string406
  size481   EQU    size406
string480   EQU  string402
  size480   EQU    size402
string479   EQU  string398
  size479   EQU    size398
string478   EQU  string418
  size478   EQU    size418
string477   EQU  string415
  size477   EQU    size415
string476   EQU  string415
  size476   EQU    size415
string475   EQU  string414
  size475   EQU    size414
string474   EQU  string411
  size474   EQU    size411
string473   EQU  string411
  size473   EQU    size411
string472   EQU  string410
  size472   EQU    size410
string471   EQU  string407
  size471   EQU    size407
string470   EQU  string407
  size470   EQU    size407
string469   EQU  string406
  size469   EQU    size406
string468   EQU  string403
  size468   EQU    size403
string467   EQU  string403
  size467   EQU    size403
string466   EQU  string402
  size466   EQU    size402
string465   EQU  string399
  size465   EQU    size399
string464   EQU  string399
  size464   EQU    size399
string463   EQU  string398
  size463   EQU    size398
string462   EQU  string395
  size462   EQU    size395
string461   EQU  string395
  size461   EQU    size395
string460   EQU  string418
  size460   EQU    size418
string459   EQU  string415
  size459   EQU    size415
string458   EQU  string415
  size458   EQU    size415
string457   EQU  string414
  size457   EQU    size414
string456   EQU  string411
  size456   EQU    size411
string455   EQU  string411
  size455   EQU    size411
string454   EQU  string410
  size454   EQU    size410
string453   EQU  string407
  size453   EQU    size407
string452   EQU  string407
  size452   EQU    size407
string451   EQU  string406
  size451   EQU    size406
string450   EQU  string403
  size450   EQU    size403
string449   EQU  string403
  size449   EQU    size403
string448   EQU  string402
  size448   EQU    size402
string447   EQU  string399
  size447   EQU    size399
string446   EQU  string399
  size446   EQU    size399
string445   EQU  string398
  size445   EQU    size398
string444   EQU  string395
  size444   EQU    size395
string443   EQU  string395
  size443   EQU    size395
string442   EQU  string418
  size442   EQU    size418
string441   EQU  string415
  size441   EQU    size415
string440   EQU  string415
  size440   EQU    size415
string439   EQU  string415
  size439   EQU    size415
string438   EQU  string414
  size438   EQU    size414
string437   EQU  string411
  size437   EQU    size411
string436   EQU  string411
  size436   EQU    size411
string435   EQU  string411
  size435   EQU    size411
string434   EQU  string410
  size434   EQU    size410
string433   EQU  string407
  size433   EQU    size407
string432   EQU  string407
  size432   EQU    size407
string431   EQU  string407
  size431   EQU    size407
string430   EQU  string406
  size430   EQU    size406
string429   EQU  string403
  size429   EQU    size403
string428   EQU  string403
  size428   EQU    size403
string427   EQU  string403
  size427   EQU    size403
string426   EQU  string402
  size426   EQU    size402
string425   EQU  string399
  size425   EQU    size399
string424   EQU  string399
  size424   EQU    size399
string423   EQU  string399
  size423   EQU    size399
string422   EQU  string398
  size422   EQU    size398
string421   EQU  string395
  size421   EQU    size395
string420   EQU  string395
  size420   EQU    size395
string419   EQU  string395
  size419   EQU    size395
string418:
    db ">=","," + 0x80
size418              EQU $ - string418
string417   EQU  string415
  size417   EQU    size415
string416   EQU  string415
  size416   EQU    size415
string415:
    db ">","=" + 0x80
size415              EQU $ - string415
string414:
    db ">","," + 0x80
size414              EQU $ - string414
string413   EQU  string411
  size413   EQU    size411
string412   EQU  string411
  size412   EQU    size411
string411:
    db ">" + 0x80
size411              EQU $ - string411
string410:
    db "<=","," + 0x80
size410              EQU $ - string410
string409   EQU  string407
  size409   EQU    size407
string408   EQU  string407
  size408   EQU    size407
string407:
    db "<","=" + 0x80
size407              EQU $ - string407
string406:
    db "<","," + 0x80
size406              EQU $ - string406
string405   EQU  string403
  size405   EQU    size403
string404   EQU  string403
  size404   EQU    size403
string403:
    db "<" + 0x80
size403              EQU $ - string403
string402:
    db "<>","," + 0x80
size402              EQU $ - string402
string401   EQU  string399
  size401   EQU    size399
string400   EQU  string399
  size400   EQU    size399
string399:
    db "<",">" + 0x80
size399              EQU $ - string399
string398:
    db "=","," + 0x80
size398              EQU $ - string398
string397   EQU  string395
  size397   EQU    size395
string396   EQU  string395
  size396   EQU    size395
string395:
    db "=" + 0x80
size395              EQU $ - string395
string394:
    db 0x0D, 0x10, 0x00, "R.A.S",":" + 0x80
size394              EQU $ - string394
string393:
    db 0x0D, "Data stack",":" + 0x80
size393              EQU $ - string393
string392:
    db " u> m1 ", 0x10, 0x02, 0x0D + 0x80
size392              EQU $ - string392
string391:
    db " u> m1 ",0x0D + 0x80
size391              EQU $ - string391
string390   EQU  string389
  size390   EQU    size389
string389:
    db " u> -1 ",0x0D + 0x80
size389              EQU $ - string389
string388:
    db " u> m2 ", 0x10, 0x00, 0x0D + 0x80
size388              EQU $ - string388
string387:
    db " u> m2 ",0x0D + 0x80
size387              EQU $ - string387
string386   EQU  string385
  size386   EQU    size385
string385:
    db " u> -2 ",0x0D + 0x80
size385              EQU $ - string385
string384:
    db " u> x3334 ", 0x10, 0x02, 0x0D + 0x80
size384              EQU $ - string384
string383:
    db " u> x3334 ",0x0D + 0x80
size383              EQU $ - string383
string382   EQU  string381
  size382   EQU    size381
string381:
    db " u> +13108 ",0x0D + 0x80
size381              EQU $ - string381
string380:
    db " u> x3333 ", 0x10, 0x00, 0x0D + 0x80
size380              EQU $ - string380
string379:
    db " u> x3333 ",0x0D + 0x80
size379              EQU $ - string379
string378   EQU  string377
  size378   EQU    size377
string377:
    db " u> +13107 ",0x0D + 0x80
size377              EQU $ - string377
string376:
    db " u> x3332 ", 0x10, 0x02, 0x0D + 0x80
size376              EQU $ - string376
string375:
    db " u> x3332 ",0x0D + 0x80
size375              EQU $ - string375
string374   EQU  string373
  size374   EQU    size373
string373:
    db " u> +13106 ",0x0D + 0x80
size373              EQU $ - string373
string372:
    db " u> p1 ", 0x10, 0x00, 0x0D + 0x80
size372              EQU $ - string372
string371:
    db " u> p1 ",0x0D + 0x80
size371              EQU $ - string371
string370   EQU  string369
  size370   EQU    size369
string369:
    db " u> +1 ",0x0D + 0x80
size369              EQU $ - string369
string368:
    db " u> zero ", 0x10, 0x02, 0x0D + 0x80
size368              EQU $ - string368
string367:
    db " u> zero ",0x0D + 0x80
size367              EQU $ - string367
string366   EQU  string365
  size366   EQU    size365
string365:
    db " u> 0 ",0x0D + 0x80
size365              EQU $ - string365
string364:
    db " u>=m1 ", 0x10, 0x00, 0x0D + 0x80
size364              EQU $ - string364
string363:
    db " u>=m1 ",0x0D + 0x80
size363              EQU $ - string363
string362   EQU  string361
  size362   EQU    size361
string361:
    db " u>=-1 ",0x0D + 0x80
size361              EQU $ - string361
string360:
    db " u>=m2 ", 0x10, 0x02, 0x0D + 0x80
size360              EQU $ - string360
string359:
    db " u>=m2 ",0x0D + 0x80
size359              EQU $ - string359
string358   EQU  string357
  size358   EQU    size357
string357:
    db " u>=-2 ",0x0D + 0x80
size357              EQU $ - string357
string356:
    db " u>=x3334 ", 0x10, 0x00, 0x0D + 0x80
size356              EQU $ - string356
string355:
    db " u>=x3334 ",0x0D + 0x80
size355              EQU $ - string355
string354   EQU  string353
  size354   EQU    size353
string353:
    db " u>=+13108 ",0x0D + 0x80
size353              EQU $ - string353
string352:
    db " u>=x3333 ", 0x10, 0x02, 0x0D + 0x80
size352              EQU $ - string352
string351:
    db " u>=x3333 ",0x0D + 0x80
size351              EQU $ - string351
string350   EQU  string349
  size350   EQU    size349
string349:
    db " u>=+13107 ",0x0D + 0x80
size349              EQU $ - string349
string348:
    db " u>=x3332 ", 0x10, 0x00, 0x0D + 0x80
size348              EQU $ - string348
string347:
    db " u>=x3332 ",0x0D + 0x80
size347              EQU $ - string347
string346   EQU  string345
  size346   EQU    size345
string345:
    db " u>=+13106 ",0x0D + 0x80
size345              EQU $ - string345
string344:
    db " u>=p1 ", 0x10, 0x02, 0x0D + 0x80
size344              EQU $ - string344
string343:
    db " u>=p1 ",0x0D + 0x80
size343              EQU $ - string343
string342   EQU  string341
  size342   EQU    size341
string341:
    db " u>=+1 ",0x0D + 0x80
size341              EQU $ - string341
string340:
    db " u>=zero ", 0x10, 0x00, 0x0D + 0x80
size340              EQU $ - string340
string339:
    db " u>=zero ",0x0D + 0x80
size339              EQU $ - string339
string338   EQU  string337
  size338   EQU    size337
string337:
    db " u>=0 ",0x0D + 0x80
size337              EQU $ - string337
string336:
    db " u<=m1 ", 0x10, 0x02, 0x0D + 0x80
size336              EQU $ - string336
string335:
    db " u<=m1 ",0x0D + 0x80
size335              EQU $ - string335
string334   EQU  string333
  size334   EQU    size333
string333:
    db " u<=-1 ",0x0D + 0x80
size333              EQU $ - string333
string332:
    db " u<=m2 ", 0x10, 0x00, 0x0D + 0x80
size332              EQU $ - string332
string331:
    db " u<=m2 ",0x0D + 0x80
size331              EQU $ - string331
string330   EQU  string329
  size330   EQU    size329
string329:
    db " u<=-2 ",0x0D + 0x80
size329              EQU $ - string329
string328:
    db " u<=x3334 ", 0x10, 0x02, 0x0D + 0x80
size328              EQU $ - string328
string327:
    db " u<=x3334 ",0x0D + 0x80
size327              EQU $ - string327
string326   EQU  string325
  size326   EQU    size325
string325:
    db " u<=+13108 ",0x0D + 0x80
size325              EQU $ - string325
string324:
    db " u<=x3333 ", 0x10, 0x00, 0x0D + 0x80
size324              EQU $ - string324
string323:
    db " u<=x3333 ",0x0D + 0x80
size323              EQU $ - string323
string322   EQU  string321
  size322   EQU    size321
string321:
    db " u<=+13107 ",0x0D + 0x80
size321              EQU $ - string321
string320:
    db " u<=x3332 ", 0x10, 0x02, 0x0D + 0x80
size320              EQU $ - string320
string319:
    db " u<=x3332 ",0x0D + 0x80
size319              EQU $ - string319
string318   EQU  string317
  size318   EQU    size317
string317:
    db " u<=+13106 ",0x0D + 0x80
size317              EQU $ - string317
string316:
    db " u<=p1 ", 0x10, 0x00, 0x0D + 0x80
size316              EQU $ - string316
string315:
    db " u<=p1 ",0x0D + 0x80
size315              EQU $ - string315
string314   EQU  string313
  size314   EQU    size313
string313:
    db " u<=+1 ",0x0D + 0x80
size313              EQU $ - string313
string312:
    db " u<=zero ", 0x10, 0x02, 0x0D + 0x80
size312              EQU $ - string312
string311:
    db " u<=zero ",0x0D + 0x80
size311              EQU $ - string311
string310   EQU  string309
  size310   EQU    size309
string309:
    db " u<=0 ",0x0D + 0x80
size309              EQU $ - string309
string308:
    db " u< m1 ", 0x10, 0x00, 0x0D + 0x80
size308              EQU $ - string308
string307:
    db " u< m1 ",0x0D + 0x80
size307              EQU $ - string307
string306   EQU  string305
  size306   EQU    size305
string305:
    db " u< -1 ",0x0D + 0x80
size305              EQU $ - string305
string304:
    db " u< m2 ", 0x10, 0x02, 0x0D + 0x80
size304              EQU $ - string304
string303:
    db " u< m2 ",0x0D + 0x80
size303              EQU $ - string303
string302   EQU  string301
  size302   EQU    size301
string301:
    db " u< -2 ",0x0D + 0x80
size301              EQU $ - string301
string300:
    db " u< x3334 ", 0x10, 0x00, 0x0D + 0x80
size300              EQU $ - string300
string299:
    db " u< x3334 ",0x0D + 0x80
size299              EQU $ - string299
string298   EQU  string297
  size298   EQU    size297
string297:
    db " u< +13108 ",0x0D + 0x80
size297              EQU $ - string297
string296:
    db " u< x3333 ", 0x10, 0x02, 0x0D + 0x80
size296              EQU $ - string296
string295:
    db " u< x3333 ",0x0D + 0x80
size295              EQU $ - string295
string294   EQU  string293
  size294   EQU    size293
string293:
    db " u< +13107 ",0x0D + 0x80
size293              EQU $ - string293
string292:
    db " u< x3332 ", 0x10, 0x00, 0x0D + 0x80
size292              EQU $ - string292
string291:
    db " u< x3332 ",0x0D + 0x80
size291              EQU $ - string291
string290   EQU  string289
  size290   EQU    size289
string289:
    db " u< +13106 ",0x0D + 0x80
size289              EQU $ - string289
string288:
    db " u< p1 ", 0x10, 0x02, 0x0D + 0x80
size288              EQU $ - string288
string287:
    db " u< p1 ",0x0D + 0x80
size287              EQU $ - string287
string286   EQU  string285
  size286   EQU    size285
string285:
    db " u< +1 ",0x0D + 0x80
size285              EQU $ - string285
string284:
    db " u< zero ", 0x10, 0x00, 0x0D + 0x80
size284              EQU $ - string284
string283:
    db " u< zero ",0x0D + 0x80
size283              EQU $ - string283
string282   EQU  string281
  size282   EQU    size281
string281:
    db " u< 0 ",0x0D + 0x80
size281              EQU $ - string281
string280:
    db "0 1 2 3 4 m M ", 0x10, 0x02, 0x0D + 0x80
size280              EQU $ - string280
string279:
    db " > max ", 0x10, 0x00, 0x0D + 0x80
size279              EQU $ - string279
string278:
    db " > max ",0x0D + 0x80
size278              EQU $ - string278
string277   EQU  string276
  size277   EQU    size276
string276:
    db " > 0x7FFF ",0x0D + 0x80
size276              EQU $ - string276
string275:
    db " > x3334 ", 0x10, 0x02, 0x0D + 0x80
size275              EQU $ - string275
string274:
    db " > x3334 ",0x0D + 0x80
size274              EQU $ - string274
string273   EQU  string272
  size273   EQU    size272
string272:
    db " > +13108 ",0x0D + 0x80
size272              EQU $ - string272
string271:
    db " > x3333 ", 0x10, 0x00, 0x0D + 0x80
size271              EQU $ - string271
string270:
    db " > x3333 ",0x0D + 0x80
size270              EQU $ - string270
string269   EQU  string268
  size269   EQU    size268
string268:
    db " > +13107 ",0x0D + 0x80
size268              EQU $ - string268
string267:
    db " > x3332 ", 0x10, 0x02, 0x0D + 0x80
size267              EQU $ - string267
string266:
    db " > x3332 ",0x0D + 0x80
size266              EQU $ - string266
string265   EQU  string264
  size265   EQU    size264
string264:
    db " > +13106 ",0x0D + 0x80
size264              EQU $ - string264
string263:
    db " > p1 ", 0x10, 0x00, 0x0D + 0x80
size263              EQU $ - string263
string262:
    db " > p1 ",0x0D + 0x80
size262              EQU $ - string262
string261   EQU  string260
  size261   EQU    size260
string260:
    db " > +1 ",0x0D + 0x80
size260              EQU $ - string260
string259:
    db " > zero ", 0x10, 0x02, 0x0D + 0x80
size259              EQU $ - string259
string258:
    db " > zero ",0x0D + 0x80
size258              EQU $ - string258
string257   EQU  string256
  size257   EQU    size256
string256:
    db " > 0 ",0x0D + 0x80
size256              EQU $ - string256
string255:
    db " > m1 ", 0x10, 0x00, 0x0D + 0x80
size255              EQU $ - string255
string254:
    db " > m1 ",0x0D + 0x80
size254              EQU $ - string254
string253   EQU  string252
  size253   EQU    size252
string252:
    db " > -1 ",0x0D + 0x80
size252              EQU $ - string252
string251:
    db " > xFEFF ", 0x10, 0x02, 0x0D + 0x80
size251              EQU $ - string251
string250:
    db " > xFEFF ",0x0D + 0x80
size250              EQU $ - string250
string249   EQU  string248
  size249   EQU    size248
string248:
    db " > +65279 ",0x0D + 0x80
size248              EQU $ - string248
string247:
    db " > xFEFE ", 0x10, 0x00, 0x0D + 0x80
size247              EQU $ - string247
string246:
    db " > xFEFE ",0x0D + 0x80
size246              EQU $ - string246
string245   EQU  string244
  size245   EQU    size244
string244:
    db " > +65278 ",0x0D + 0x80
size244              EQU $ - string244
string243:
    db " > xFEFD ", 0x10, 0x02, 0x0D + 0x80
size243              EQU $ - string243
string242:
    db " > xFEFD ",0x0D + 0x80
size242              EQU $ - string242
string241   EQU  string240
  size241   EQU    size240
string240:
    db " > +65277 ",0x0D + 0x80
size240              EQU $ - string240
string239:
    db " > min ", 0x10, 0x00, 0x0D + 0x80
size239              EQU $ - string239
string238:
    db " > min ",0x0D + 0x80
size238              EQU $ - string238
string237   EQU  string236
  size237   EQU    size236
string236:
    db " > 0x8000 ",0x0D + 0x80
size236              EQU $ - string236
string235:
    db " >=max ", 0x10, 0x02, 0x0D + 0x80
size235              EQU $ - string235
string234:
    db " >=max ",0x0D + 0x80
size234              EQU $ - string234
string233   EQU  string232
  size233   EQU    size232
string232:
    db " >=0x7FFF ",0x0D + 0x80
size232              EQU $ - string232
string231:
    db " >=x3334 ", 0x10, 0x00, 0x0D + 0x80
size231              EQU $ - string231
string230:
    db " >=x3334 ",0x0D + 0x80
size230              EQU $ - string230
string229   EQU  string228
  size229   EQU    size228
string228:
    db " >=+13108 ",0x0D + 0x80
size228              EQU $ - string228
string227:
    db " >=x3333 ", 0x10, 0x02, 0x0D + 0x80
size227              EQU $ - string227
string226:
    db " >=x3333 ",0x0D + 0x80
size226              EQU $ - string226
string225   EQU  string224
  size225   EQU    size224
string224:
    db " >=+13107 ",0x0D + 0x80
size224              EQU $ - string224
string223:
    db " >=x3332 ", 0x10, 0x00, 0x0D + 0x80
size223              EQU $ - string223
string222:
    db " >=x3332 ",0x0D + 0x80
size222              EQU $ - string222
string221   EQU  string220
  size221   EQU    size220
string220:
    db " >=+13106 ",0x0D + 0x80
size220              EQU $ - string220
string219:
    db " >=p1 ", 0x10, 0x02, 0x0D + 0x80
size219              EQU $ - string219
string218:
    db " >=p1 ",0x0D + 0x80
size218              EQU $ - string218
string217   EQU  string216
  size217   EQU    size216
string216:
    db " >=+1 ",0x0D + 0x80
size216              EQU $ - string216
string215:
    db " >=zero ", 0x10, 0x00, 0x0D + 0x80
size215              EQU $ - string215
string214:
    db " >=zero ",0x0D + 0x80
size214              EQU $ - string214
string213   EQU  string212
  size213   EQU    size212
string212:
    db " >=0 ",0x0D + 0x80
size212              EQU $ - string212
string211:
    db " >=m1 ", 0x10, 0x02, 0x0D + 0x80
size211              EQU $ - string211
string210:
    db " >=m1 ",0x0D + 0x80
size210              EQU $ - string210
string209   EQU  string208
  size209   EQU    size208
string208:
    db " >=-1 ",0x0D + 0x80
size208              EQU $ - string208
string207:
    db " >=xFEFF ", 0x10, 0x00, 0x0D + 0x80
size207              EQU $ - string207
string206:
    db " >=xFEFF ",0x0D + 0x80
size206              EQU $ - string206
string205   EQU  string204
  size205   EQU    size204
string204:
    db " >=+65279 ",0x0D + 0x80
size204              EQU $ - string204
string203:
    db " >=xFEFE ", 0x10, 0x02, 0x0D + 0x80
size203              EQU $ - string203
string202:
    db " >=xFEFE ",0x0D + 0x80
size202              EQU $ - string202
string201   EQU  string200
  size201   EQU    size200
string200:
    db " >=+65278 ",0x0D + 0x80
size200              EQU $ - string200
string199:
    db " >=xFEFD ", 0x10, 0x00, 0x0D + 0x80
size199              EQU $ - string199
string198:
    db " >=xFEFD ",0x0D + 0x80
size198              EQU $ - string198
string197   EQU  string196
  size197   EQU    size196
string196:
    db " >=+65277 ",0x0D + 0x80
size196              EQU $ - string196
string195:
    db " >=min ", 0x10, 0x02, 0x0D + 0x80
size195              EQU $ - string195
string194:
    db " >=min ",0x0D + 0x80
size194              EQU $ - string194
string193   EQU  string192
  size193   EQU    size192
string192:
    db " >=0x8000 ",0x0D + 0x80
size192              EQU $ - string192
string191:
    db " <=max ", 0x10, 0x00, 0x0D + 0x80
size191              EQU $ - string191
string190:
    db " <=max ",0x0D + 0x80
size190              EQU $ - string190
string189   EQU  string188
  size189   EQU    size188
string188:
    db " <=0x7FFF ",0x0D + 0x80
size188              EQU $ - string188
string187:
    db " <=x3334 ", 0x10, 0x02, 0x0D + 0x80
size187              EQU $ - string187
string186:
    db " <=x3334 ",0x0D + 0x80
size186              EQU $ - string186
string185   EQU  string184
  size185   EQU    size184
string184:
    db " <=+13108 ",0x0D + 0x80
size184              EQU $ - string184
string183:
    db " <=x3333 ", 0x10, 0x00, 0x0D + 0x80
size183              EQU $ - string183
string182:
    db " <=x3333 ",0x0D + 0x80
size182              EQU $ - string182
string181   EQU  string180
  size181   EQU    size180
string180:
    db " <=+13107 ",0x0D + 0x80
size180              EQU $ - string180
string179:
    db " <=x3332 ", 0x10, 0x02, 0x0D + 0x80
size179              EQU $ - string179
string178:
    db " <=x3332 ",0x0D + 0x80
size178              EQU $ - string178
string177   EQU  string176
  size177   EQU    size176
string176:
    db " <=+13106 ",0x0D + 0x80
size176              EQU $ - string176
string175:
    db " <=p1 ", 0x10, 0x00, 0x0D + 0x80
size175              EQU $ - string175
string174:
    db " <=p1 ",0x0D + 0x80
size174              EQU $ - string174
string173   EQU  string172
  size173   EQU    size172
string172:
    db " <=+1 ",0x0D + 0x80
size172              EQU $ - string172
string171:
    db " <=zero ", 0x10, 0x02, 0x0D + 0x80
size171              EQU $ - string171
string170:
    db " <=zero ",0x0D + 0x80
size170              EQU $ - string170
string169   EQU  string168
  size169   EQU    size168
string168:
    db " <=0 ",0x0D + 0x80
size168              EQU $ - string168
string167:
    db " <=m1 ", 0x10, 0x00, 0x0D + 0x80
size167              EQU $ - string167
string166:
    db " <=m1 ",0x0D + 0x80
size166              EQU $ - string166
string165   EQU  string164
  size165   EQU    size164
string164:
    db " <=-1 ",0x0D + 0x80
size164              EQU $ - string164
string163:
    db " <=xFEFF ", 0x10, 0x02, 0x0D + 0x80
size163              EQU $ - string163
string162:
    db " <=xFEFF ",0x0D + 0x80
size162              EQU $ - string162
string161   EQU  string160
  size161   EQU    size160
string160:
    db " <=+65279 ",0x0D + 0x80
size160              EQU $ - string160
string159:
    db " <=xFEFE ", 0x10, 0x00, 0x0D + 0x80
size159              EQU $ - string159
string158:
    db " <=xFEFE ",0x0D + 0x80
size158              EQU $ - string158
string157   EQU  string156
  size157   EQU    size156
string156:
    db " <=+65278 ",0x0D + 0x80
size156              EQU $ - string156
string155:
    db " <=xFEFD ", 0x10, 0x02, 0x0D + 0x80
size155              EQU $ - string155
string154:
    db " <=xFEFD ",0x0D + 0x80
size154              EQU $ - string154
string153   EQU  string152
  size153   EQU    size152
string152:
    db " <=+65277 ",0x0D + 0x80
size152              EQU $ - string152
string151:
    db " <=min ", 0x10, 0x00, 0x0D + 0x80
size151              EQU $ - string151
string150:
    db " <=min ",0x0D + 0x80
size150              EQU $ - string150
string149   EQU  string148
  size149   EQU    size148
string148:
    db " <=0x8000 ",0x0D + 0x80
size148              EQU $ - string148
string147:
    db " < max ", 0x10, 0x02, 0x0D + 0x80
size147              EQU $ - string147
string146:
    db " < max ",0x0D + 0x80
size146              EQU $ - string146
string145   EQU  string144
  size145   EQU    size144
string144:
    db " < 0x7FFF ",0x0D + 0x80
size144              EQU $ - string144
string143:
    db " < x3334 ", 0x10, 0x00, 0x0D + 0x80
size143              EQU $ - string143
string142:
    db " < x3334 ",0x0D + 0x80
size142              EQU $ - string142
string141   EQU  string140
  size141   EQU    size140
string140:
    db " < +13108 ",0x0D + 0x80
size140              EQU $ - string140
string139:
    db " < x3333 ", 0x10, 0x02, 0x0D + 0x80
size139              EQU $ - string139
string138:
    db " < x3333 ",0x0D + 0x80
size138              EQU $ - string138
string137   EQU  string136
  size137   EQU    size136
string136:
    db " < +13107 ",0x0D + 0x80
size136              EQU $ - string136
string135:
    db " < x3332 ", 0x10, 0x00, 0x0D + 0x80
size135              EQU $ - string135
string134:
    db " < x3332 ",0x0D + 0x80
size134              EQU $ - string134
string133   EQU  string132
  size133   EQU    size132
string132:
    db " < +13106 ",0x0D + 0x80
size132              EQU $ - string132
string131:
    db " < p1 ", 0x10, 0x02, 0x0D + 0x80
size131              EQU $ - string131
string130:
    db " < p1 ",0x0D + 0x80
size130              EQU $ - string130
string129   EQU  string128
  size129   EQU    size128
string128:
    db " < +1 ",0x0D + 0x80
size128              EQU $ - string128
string127:
    db " < zero ", 0x10, 0x00, 0x0D + 0x80
size127              EQU $ - string127
string126:
    db " < zero ",0x0D + 0x80
size126              EQU $ - string126
string125   EQU  string124
  size125   EQU    size124
string124:
    db " < 0 ",0x0D + 0x80
size124              EQU $ - string124
string123:
    db " < m1 ", 0x10, 0x02, 0x0D + 0x80
size123              EQU $ - string123
string122:
    db " < m1 ",0x0D + 0x80
size122              EQU $ - string122
string121   EQU  string120
  size121   EQU    size120
string120:
    db " < -1 ",0x0D + 0x80
size120              EQU $ - string120
string119:
    db " < xFEFF ", 0x10, 0x00, 0x0D + 0x80
size119              EQU $ - string119
string118:
    db " < xFEFF ",0x0D + 0x80
size118              EQU $ - string118
string117   EQU  string116
  size117   EQU    size116
string116:
    db " < +65279 ",0x0D + 0x80
size116              EQU $ - string116
string115:
    db " < xFEFE ", 0x10, 0x02, 0x0D + 0x80
size115              EQU $ - string115
string114:
    db " < xFEFE ",0x0D + 0x80
size114              EQU $ - string114
string113   EQU  string112
  size113   EQU    size112
string112:
    db " < +65278 ",0x0D + 0x80
size112              EQU $ - string112
string111:
    db " < xFEFD ", 0x10, 0x00, 0x0D + 0x80
size111              EQU $ - string111
string110:
    db " < xFEFD ",0x0D + 0x80
size110              EQU $ - string110
string109   EQU  string108
  size109   EQU    size108
string108:
    db " < +65277 ",0x0D + 0x80
size108              EQU $ - string108
string107:
    db " < min ", 0x10, 0x02, 0x0D + 0x80
size107              EQU $ - string107
string106:
    db " < min ",0x0D + 0x80
size106              EQU $ - string106
string105   EQU  string104
  size105   EQU    size104
string104:
    db " < 0x8000 ",0x0D + 0x80
size104              EQU $ - string104
string103:
    db 0x0D, "m d e f 1 0 1 2 3 4 M ", 0x0D + 0x80
size103              EQU $ - string103
string102:
    db "( d2 d1 -- ) and ( ud2 ud1 -- ): ",0x0D + 0x80
size102              EQU $ - string102
string101:
    db "( x2 x1 -- ) and ( u2 u1 -- ): ",0x0D + 0x80
size101              EQU $ - string101


VARIABLE_SECTION:

_max:                   ;           variable _max 0x7FFF   = 32767
    dw 0x7FFF           ;           variable _max 0x7FFF
_p0x3334:               ;           variable _p0x3334 0x3334   = 13108
    dw 0x3334           ;           variable _p0x3334 0x3334
_p0x3333:               ;           variable _p0x3333 0x3333   = 13107
    dw 0x3333           ;           variable _p0x3333 0x3333
_p0x3332:               ;           variable _p0x3332 0x3332   = 13106
    dw 0x3332           ;           variable _p0x3332 0x3332
_p1:                    ;           variable _p1 1   = 0x0001
    dw 0x0001           ;           variable _p1 1
_zero:                  ;           variable _zero 0   = 0x0000
    dw 0x0000           ;           variable _zero 0
_m1:                    ;           variable _m1 -1   = 0xFFFF
    dw 0xFFFF           ;           variable _m1 -1
_xFEFF:                 ;           variable _xFEFF 0xFEFF   = 65279
    dw 0xFEFF           ;           variable _xFEFF 0xFEFF
_xFEFE:                 ;           variable _xFEFE 0xFEFE   = 65278
    dw 0xFEFE           ;           variable _xFEFE 0xFEFE
_xFEFD:                 ;           variable _xFEFD 0xFEFD   = 65277
    dw 0xFEFD           ;           variable _xFEFD 0xFEFD
_min:                   ;           variable _min 0x8000   = 32768
    dw 0x8000           ;           variable _min 0x8000
_umax:                  ;           variable _umax 0xFFFF   = 65535
    dw 0xFFFF           ;           variable _umax 0xFFFF
_m2:                    ;           variable _m2 0xFFFE   = 65534
    dw 0xFFFE           ;           variable _m2 0xFFFE
_u0x3334:               ;           variable _u0x3334 0x3334   = 13108
    dw 0x3334           ;           variable _u0x3334 0x3334
_u0x3333:               ;           variable _u0x3333 0x3333   = 13107
    dw 0x3333           ;           variable _u0x3333 0x3333
_u0x3332:               ;           variable _u0x3332 0x3332   = 13106
    dw 0x3332           ;           variable _u0x3332 0x3332
_u1:                    ;           variable _u1 1   = 0x0001
    dw 0x0001           ;           variable _u1 1
_uzero:                 ;           variable _uzero 0   = 0x0000
    dw 0x0000           ;           variable _uzero 0
